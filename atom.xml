<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南叶の小窝</title>
  <subtitle>欢迎来玩awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-10-23T09:49:56.661Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>更新日志</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>这里是更新日志</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>更新了个人简介</li>
<li>更新了rm笔记</li>
<li>更新了双指针的框架</li>
<li>评论没挂服务器所以不能用</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="日志"></category>
  </entry>
  <entry>
    <title>双指针</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>双指针常见技巧</summary>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">双指针在数组的运用</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">快慢指针</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">二分搜索</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">回文/反转</a></li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">数之和</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">双指针在链表的运用</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a></li>
<li><a href="#%E5%88%86%E8%A7%A3">分解</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr />
<h2>双指针在数组的运用</h2>
<hr />
<h2>快慢指针</h2>
<h3>数组的原地修改</h3>
<ul>
<li>力扣第 26 题「删除有序数组中的重复项」，让你在有序数组去重：
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</li>
</ul>
<hr />
<ul>
<li>给你一个<strong>非严格递增排列</strong>的数组<code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。然后返回 <code>nums</code> 中唯一元素的个数。</li>
<li>考虑 <code>nums </code>的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 k。</li>
<li><code>nums</code> 的前 k 个元素应包含 排序后 的唯一数字。下标 <code>k - 1 </code>之后的剩余元素可以忽略。</li>
</ul>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<pre><code>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案
int k = removeDuplicates(nums); // 调用
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>如果所有断言都通过，那么您的题解将被<strong>通过</strong>。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的
</code></pre>
<ul>
<li><strong>原地</strong>意味着只能对当前数组进行修改，不能新建一个数组</li>
<li>这里所需要用到的就是<strong>快慢指针</strong></li>
<li>简单来说就是一个快指针去识别，另一个慢指针去操作</li>
<li><strong>注意</strong>  这里指针是广义上的指针，数组的索引也可以是<strong>指针</strong></li>
<li>如果 <code>fast</code> 遇到值为 <code>val </code>的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow </code>前进一步。</li>
</ul>
<p>具体代码如下</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
</code></pre>
<ul>
<li>注意这里需要<strong>先<code>slow++</code>再赋值</strong>，要不然第一个会被吞掉</li>
</ul>
<hr />
<ul>
<li>下面一道题也是快慢指针的思想，如果掌握了前一道题，这题会很简单</li>
<li><strong>力扣283移动0</strong>https://leetcode.cn/problems/move-zeroes/</li>
<li>给定一个数组 <strong>nums</strong>，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li>
<li>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</li>
</ul>
<p>示例 1:</p>
<pre><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:
</code></pre>
<pre><code>输入: nums = [0]
输出: [0]
</code></pre>
<p>这里我就直接上代码了</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int slow = 0;  // 指向下一个非零应放置的位置
        for (int fast = 0; fast &lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow 之后的全部置为 0
        for (int i = slow; i &lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

</code></pre>
<hr />
<h2>二分搜索</h2>
<ul>
<li>
<p>在我们都玩过的猜数字游戏中，用的就是二分搜素的技巧</p>
</li>
<li>
<p>我们先看最笨的顺序查找，我们从1-100遍历全部数字，虽然说运气好可能一下会猜中，但是期望的次数还是很多，复杂度为O(n)</p>
</li>
<li>
<p>如果是凭感觉找，一样还是要看运气</p>
</li>
<li>
<p>如果第一次猜50，然后继续一半一半缩小区间，最坏也能在7次内解决</p>
<ul>
<li>如何数字来到1-1000000，二分搜索最坏20次就能找到答案</li>
</ul>
</li>
<li>
<p>二分搜索的时间复杂度是O(log  N)</p>
</li>
<li>
<p>下面是最基本代码</p>
</li>
</ul>
<pre><code>int binarySearch(vector&lt;int&gt;&amp; nums, int target) {
    // 一左一右两个指针相向而行
    int left = 0, right = nums.size() - 1;
    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; 
        else if (nums[mid] &gt; target)
            right = mid - 1;
    }
    return -1;
}
</code></pre>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>装甲板自动识别与位姿估计学习</title>
    <link href="https://www.nanye404.top/posts/armor/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>一些小笔记</summary>
    <content type="html"><![CDATA[<h2>目录</h2>
<ol>
<li><a href="#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88">总览：系统做的事情是什么</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A">关键知识点速通</a></li>
<li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86">端到端流程图（一帧图像如何被处理）</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">模块逐个拆解（含核心代码片段）</a>
<ul>
<li>4.1 数字分类器 <code>NumberClassifier</code></li>
<li>4.2 视觉检测器 <code>Detector</code></li>
<li>4.3 灯条角点精修 <code>LightCornerCorrector</code></li>
<li>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</li>
<li>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></li>
<li>4.6 ROS2 节点 <code>ArmorDetectorNode</code></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97">参数如何影响效果（调参指南）</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96">实战：从源码到运行与可视化</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF">常见问题与定位思路</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA">进阶练习题（带方向提示）</a></li>
<li><a href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84">术语与坐标系小抄</a></li>
</ol>
<hr />
<h2>总览：系统做的事情是什么</h2>
<p><strong>目标</strong>：从相机来的彩色图像中，自动找出“<strong>两根灯条组成的装甲板</strong>”，<strong>识别装甲数字</strong>，并估计装甲板在<strong>相机坐标系</strong>下的三维位姿（位置 + 姿态），最后通过 <strong>ROS2</strong> 发布结果与可视化。</p>
<p><strong>关键阶段</strong>：</p>
<ol>
<li>图像预处理 → 二值化轮廓 → <strong>灯条候选</strong>。</li>
<li>灯条几何筛选 &amp; 颜色判定 → <strong>灯条配对成装甲板</strong>。</li>
<li>透视展开中部区域 → <strong>数字分类</strong>（ONNX 模型）。</li>
<li>对灯条上下角点做<strong>几何细化</strong>（提升 PnP 稳定性）。</li>
<li>用 <strong>PnP 求初解</strong> → 条件允许时用 **BA（仅优化 yaw）**做小优化。</li>
<li>封装为 ROS2 节点：<strong>订阅图像/相机内参/TF</strong>，发布调试图像与 <strong>Marker</strong>。</li>
</ol>
<hr />
<h2>关键知识点速通</h2>
<ul>
<li><strong>轮廓检测与几何筛选（OpenCV）</strong>：<code>findContours</code>、旋转矩形、长短边比、倾角、区域颜色统计。</li>
<li><strong>透视展开</strong>：<code>getPerspectiveTransform</code> + <code>warpPerspective</code> 把斜着的装甲板拉直。</li>
<li><strong>二值化与分类（OpenCV DNN）</strong>：OTSU 自动阈值、<code>blobFromImage</code>、ONNX 前向。</li>
<li><strong>PnP 位姿估计</strong>：2D-3D 对应点 + 相机内参 → <code>solvePnPGeneric</code> 求 R/t。</li>
<li><strong>两解选择与稳定化</strong>：重投影误差、roll 限制、根据灯条倾斜推断 yaw 正负。</li>
<li><strong>BA（Bundle Adjustment）</strong>：这里<strong>只优化 yaw</strong>，用 g2o 把像素投影误差最小化。</li>
<li><strong>ROS2 组件化</strong>：参数声明、话题订阅/发布、动态参数回调、TF 查询、RViz 可视化。</li>
</ul>
<hr />
<h2>端到端流程图（一帧图像如何被处理）</h2>
<pre><code>Image(rgb8)
   └─► 预处理(灰度/阈值)
          └─► 轮廓→灯条(Light)
                 └─► 同色 + 几何关系 → 装甲(Armor)
                        ├─► (可选) 灯条角点精修
                        ├─► 透视展开数字ROI → 二值化 → 分类
                        └─► PnP求位姿 → (可选) BA优化yaw
                               └─► 发布Armors + RViz Marker + 调试图像
</code></pre>
<hr />
<h2>模块逐个拆解（含核心代码片段）</h2>
<h3>4.1 数字分类器 <code>NumberClassifier</code></h3>
<p><strong>职责</strong>：从装甲板两根灯条之间裁出数字图（固定尺寸），二值化后喂给 ONNX 分类网络，得到类别与置信度。</p>
<p><strong>核心：透视展开 + 二值化 + DNN 前向</strong></p>
<pre><code>// 透视展开并裁 ROI（宽度随大小装甲而变）
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp; src, const Armor&amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // 中部 ROI → 灰度&amp;OTSU → 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
</code></pre>
<pre><code>// 前向分类 + 结果解码
void NumberClassifier::classify(const cv::Mat&amp;, Armor&amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;conf, nullptr, &amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format("{}:{:.1f}%", armor.number, armor.confidence * 100.0);
}
</code></pre>
<pre><code>// 过滤：按阈值/忽略列表 + 大小装甲与类别的互斥规则
void NumberClassifier::eraseIgnoreClasses(std::vector&lt;Armor&gt;&amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;a) {
    if (a.confidence &lt; threshold) return true;
    for (auto&amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == "outpost" || a.number == "2" || a.number == "sentry");
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == "1"      || a.number == "base");
    return mismatch;
  }), armors.end());
}
</code></pre>
<p><strong>要点</strong>：ROI 宽度与装甲尺寸匹配；OTSU 让阈值更稳；<code>blobFromImage</code> 封装归一化与 NHWC→NCHW。</p>
<hr />
<h3>4.2 视觉检测器 <code>Detector</code></h3>
<p><strong>职责</strong>：灰度/阈值 → 轮廓 → 灯条（形状 + 倾角）→ 统计颜色 → 左右同色配对 → 装甲。若有分类器与角点修正器，则并行进行数字分类与角点细化。</p>
<p><strong>总体流程</strong></p>
<pre><code>std::vector&lt;Armor&gt; Detector::detect(const cv::Mat&amp; input) noexcept {
  binary_img = preprocessImage(input);               // 灰度+固定阈值
  lights_    = findLights(input, binary_img);        // 轮廓→Light（比例/角度/颜色）
  armors_    = matchLights(lights_);                 // 左右配对 → Armor

  if (!armors_.empty() &amp;&amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;input](Armor&amp; a){
      a.number_img = classifier-&gt;extractNumber(input, a);
      classifier-&gt;classify(input, a);
      if (corner_corrector) corner_corrector-&gt;correctCorners(a, gray_img_);
    });
    classifier-&gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
</code></pre>
<p><strong>关键判定：灯条与配对</strong></p>
<pre><code>// 灯条筛选：短长边比 + 倾角
bool Detector::isLight(const Light&amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &lt; ratio &amp;&amp; ratio &lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &lt; light_params.max_angle;
  return ratio_ok &amp;&amp; angle_ok;
}

// 颜色：在轮廓像素中统计R/B强度差（红/蓝）
for (auto&amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &gt; light_params.color_diff_thresh)
  light.color = (sum_r &gt; sum_b ? RED : BLUE);

// 夹灯检测：两灯条外接矩形内是否还“夹”着别的灯条（且排除数字/红点等干扰）
bool containLight(int i, int j, const std::vector&lt;Light&gt;&amp; lights);

// 配对：同色 + X方向扫描 + 中心距窗口（区分大小装甲）+ 两灯条长度相近 + 夹角限制
std::vector&lt;Armor&gt; Detector::matchLights(const std::vector&lt;Light&gt;&amp; lights) noexcept;
</code></pre>
<hr />
<h3>4.3 灯条角点精修 <code>LightCornerCorrector</code></h3>
<p><strong>职责</strong>：更精确地找到每根灯条的<strong>上下端点</strong>与<strong>中心/轴向</strong>，提升 PnP 的 2D-3D 对应精度（在二值化或噪声环境下尤其有用）。</p>
<p><strong>算法思路</strong>：</p>
<ol>
<li>以灯条外接框为基础做<strong>适度扩展</strong>并检查边界；</li>
<li>对该小区域做<strong>重心与主方向</strong>估计（亮度加权 + PCA/一阶矩），得到<strong>对称轴</strong>；</li>
<li>沿对称轴的上下方向，以多个平行“扫描线”寻找<strong>亮度突变最大</strong>的位置作为端点候选，最后求平均。</li>
</ol>
<p><strong>要点代码</strong></p>
<pre><code>// 角点修正入口：宽度太小则跳过，避免噪声
void LightCornerCorrector::correctCorners(Armor&amp; armor, const cv::Mat&amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
  if (armor.right_light.width &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
}

// 沿对称轴寻找“亮度突变最大”的点作为角点（多条平行线，取候选平均）
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp; gray, const Light&amp; light,
                                             const SymmetryAxis&amp; axis, std::string order) {
  // ... 扫描 START~END 的小段，累计亮度差最大处 ...
  // 返回均值点；无候选则返回 (-1,-1)
}
</code></pre>
<hr />
<h3>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</h3>
<p><strong>职责</strong>：把装甲四角的 2D 像素点与已知 3D 模型点（大/小装甲的真实尺寸）对应，解出 R/t。若 roll 小且开启 BA，则进一步仅在 <strong>yaw</strong> 维进行图优化，使投影误差更小。</p>
<p><strong>核心流程</strong></p>
<pre><code>// 1) PnP 初解（solvePnPGeneric 可能返回两组解）
if (pnp_solver_-&gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) 解的选择（误差/roll/灯条倾角→yaw正负）

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;&amp; roll &lt; 15) {
    // 3) BA：仅优化 yaw，小幅修正 R 以减小投影误差
    R = ba_solver_-&gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) 填充消息（位姿 + 文本）
}
</code></pre>
<p><strong>两解选择（直觉）</strong>：</p>
<ul>
<li>先看<strong>重投影误差</strong>与 <strong>roll</strong>（太差的解直接放弃切换）；</li>
<li>再用<strong>灯条在像面上的整体倾斜</strong>来判断当前<strong>yaw 的正负是否“合理”</strong>，必要时对调解。</li>
</ul>
<hr />
<h3>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></h3>
<p><strong>思想</strong>：只把<strong>装甲 yaw</strong> 当成优化变量（一个顶点 <code>VertexYaw</code>），装甲的 3D 角点为固定顶点。观测为每个角点在图像里的像素位置，误差就是<strong>观测像素</strong>减去<strong>投影像素</strong>。这样 BA 既轻量又能稳住姿态。</p>
<p><strong>构图与优化</strong></p>
<pre><code>// 填图：一个 yaw 顶点 + 四个固定的 3D 顶点 + 四条投影误差边（带 Huber 鲁棒核）
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&gt;setVertex(0, v_yaw); e-&gt;setVertex(1, vp);
  e-&gt;setMeasurement(pixel_observation);
  e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
</code></pre>
<pre><code>// 自定义顶点增量：在 SO3 上用李代数更新 yaw，避免角度跳变
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
</code></pre>
<pre><code>// 投影边误差：像素观测 - 投影(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&lt;VertexYaw*&gt;(_vertices[0])-&gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&lt;2&gt;();
  _error = obs - proj;
}
</code></pre>
<hr />
<h3>4.6 ROS2 节点 <code>ArmorDetectorNode</code></h3>
<p><strong>职责</strong>：把检测 → 分类 →（可选）角点修正 → PnP/BA → 发布可视化，全流程在 ROS2 中跑起来。负责：参数、订阅/发布、TF、调试。</p>
<p><strong>节点初始化（节选）</strong></p>
<pre><code>// 读取参数，初始化 Detector、NumberClassifier、LightCornerCorrector
int binary_thres = declare_parameter("binary_thres", 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&lt;Detector&gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/lenet.onnx");
auto label_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/label.txt");
double threshold = declare_parameter("classifier_threshold", 0.7);
auto ignores = declare_parameter&lt;std::vector&lt;std::string&gt;&gt;("ignore_classes", {"negative"});
detector_-&gt;classifier = std::make_unique&lt;NumberClassifier&gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter("use_pca", true);
if (use_pca) detector_-&gt;corner_corrector = std::make_unique&lt;LightCornerCorrector&gt;();
</code></pre>
<p><strong>图像回调（节选）</strong></p>
<pre><code>// 1) TF: odom → 相机的旋转矩阵（IMU→Camera）
auto odom_to_cam = tf2_buffer_-&gt;lookupTransform(odom_frame_, img_msg-&gt;header.frame_id, img_msg-&gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) 检测 + 分类 + 角点修正
auto armors = detector_-&gt;detect(cv_bridge::toCvShare(img_msg, "rgb8")-&gt;image);

// 3) PnP/BA 提取位姿
armors_msg_.armors = armor_pose_estimator_-&gt;extractArmorPoses(armors, imu_to_camera);

// 4) 可视化与发布：Marker / 调试图像 / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&gt;publish(armors_msg_);
</code></pre>
<hr />
<h2>参数如何影响效果（调参指南）</h2>
<ul>
<li><code>binary_thres</code>：阈值高→噪点少但灯条可能断；阈值低→连通域粘连。先打开调试图像话题观察再调。</li>
<li><code>light.min_ratio / max_ratio / max_angle</code>：控制灯条的“细长”和“近垂直”程度；误检多就收紧，漏检多就放宽。</li>
<li><code>light.color_diff_thresh</code>：越大越“保守”地判断颜色；太小会把杂散光当成红/蓝。</li>
<li><code>armor.*_center_distance</code>：两灯条中心距窗口；与焦距/距离有关，镜头变化后要重调。</li>
<li><code>classifier_threshold / ignore_classes</code>：分类阈值与忽略类，先松后紧，结合实测混淆再收敛。</li>
<li><code>use_pca</code>：角点修正，噪声环境或分辨率不高时常有帮助。</li>
<li><code>use_ba</code>：轻量的 yaw 优化，能减抖、稳姿态；但在极端视角下可能收益有限。</li>
</ul>
<hr />
<h2>实战：从源码到运行与可视化</h2>
<ol>
<li><strong>准备</strong>：相机话题 <code>image_raw</code>、<code>camera_info</code>，并确认 TF 链路（<code>odom → camera</code>）。</li>
<li><strong>启动节点</strong>：加载参数（上面提到的阈值与窗口）并打开 <code>debug</code>。</li>
<li><strong>RViz</strong>：添加 <code>MarkerArray</code> 订阅 <code>armor_detector/marker</code>；把调试图像话题（<code>binary_img/number_img/result_img</code>）也开出来。</li>
<li><strong>观察与调整</strong>：
<ul>
<li>先让<strong>灯条候选</strong>稳定 → 再看<strong>配对</strong>是否合理 → 最后看<strong>数字分类</strong>与<strong>位姿</strong>是否稳定。</li>
<li>逐项微调参数，记录每项调整对召回/精度的影响。</li>
</ul>
</li>
</ol>
<hr />
<h2>常见问题与定位思路</h2>
<ul>
<li><strong>灯条“夹灯”/误配对</strong>：检查 <code>containLight</code> 规则与数字/红点宽度过滤；适当提高 <code>color_diff_thresh</code>。</li>
<li><strong>分类不稳</strong>：对比 <code>number_img</code> 是否干净；检查 ROI 宽度是否与大/小装甲一致；适当调阈值或忽略类。</li>
<li><strong>位姿“翻面”</strong>：理解 <code>sortPnPResult</code> 的选择逻辑（误差、roll、灯条倾角与 yaw 正负），必要时在近景贴纸纹理上做辅助。</li>
<li><strong>姿态抖动</strong>：开启 <code>use_ba</code>；或在 <code>LightCornerCorrector</code> 中加大候选条数。</li>
</ul>
<hr />
<h2>进阶练习题（带方向提示）</h2>
<ol>
<li><strong>把阈值改成自适应</strong>：尝试 <code>cv::adaptiveThreshold</code> 或根据区域亮度动态调 <code>binary_thres</code>。</li>
<li><strong>加入时序稳定</strong>：在 <code>Detector</code> 输出上做跟踪（Kalman/匈牙利匹配），让数字与姿态在帧间更稳。</li>
<li><strong>数据增强与再训练</strong>：对 <code>number_img</code> 做随机仿射/噪声增强，微调 ONNX 模型，观察混淆类的改善。</li>
<li><strong>多目标选择策略</strong>：当同屏多块装甲时，基于 <code>distance_to_image_center</code>、置信度或历史 ID 选择目标。</li>
</ol>
<hr />
<h2>术语与坐标系小抄</h2>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>视频测试</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>视频测试。</summary>
    <content type="html"><![CDATA[<p>这是视频测试</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="测试"></category>
  </entry>
</feed>