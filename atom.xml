<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南叶の小窝</title>
  <subtitle>欢迎来玩awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-10-22T14:57:54.761Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>双指针</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>双指针常见技巧</summary>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">双指针在数组的运用</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">快慢指针</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">二分搜索</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">回文/反转</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">数之和</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">双指针在链表的运用</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E8%A7%A3">分解</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr />
<h2>双指针在数组的运用</h2>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>更新日志</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>这里是更新日志</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>更新了个人简介</li>
<li>更新了rm笔记</li>
<li>更新了双指针的框架</li>
<li>评论没挂服务器所以不能用</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term=" 日志 "></category>
  </entry>
  <entry>
    <title>装甲板自动识别与位姿估计学习</title>
    <link href="https://www.nanye404.top/posts/armor/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>一些小笔记</summary>
    <content type="html"><![CDATA[<h2>目录</h2>
<ol>
<li><a href="#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88">总览：系统做的事情是什么</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A">关键知识点速通</a></li>
<li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86">端到端流程图（一帧图像如何被处理）</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">模块逐个拆解（含核心代码片段）</a>
<ul>
<li>4.1 数字分类器 <code>NumberClassifier</code></li>
<li>4.2 视觉检测器 <code>Detector</code></li>
<li>4.3 灯条角点精修 <code>LightCornerCorrector</code></li>
<li>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</li>
<li>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></li>
<li>4.6 ROS2 节点 <code>ArmorDetectorNode</code></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97">参数如何影响效果（调参指南）</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96">实战：从源码到运行与可视化</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF">常见问题与定位思路</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA">进阶练习题（带方向提示）</a></li>
<li><a href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84">术语与坐标系小抄</a></li>
</ol>
<hr />
<h2>总览：系统做的事情是什么</h2>
<p><strong>目标</strong>：从相机来的彩色图像中，自动找出“<strong>两根灯条组成的装甲板</strong>”，<strong>识别装甲数字</strong>，并估计装甲板在<strong>相机坐标系</strong>下的三维位姿（位置 + 姿态），最后通过 <strong>ROS2</strong> 发布结果与可视化。</p>
<p><strong>关键阶段</strong>：</p>
<ol>
<li>图像预处理 → 二值化轮廓 → <strong>灯条候选</strong>。</li>
<li>灯条几何筛选 &amp; 颜色判定 → <strong>灯条配对成装甲板</strong>。</li>
<li>透视展开中部区域 → <strong>数字分类</strong>（ONNX 模型）。</li>
<li>对灯条上下角点做<strong>几何细化</strong>（提升 PnP 稳定性）。</li>
<li>用 <strong>PnP 求初解</strong> → 条件允许时用 **BA（仅优化 yaw）**做小优化。</li>
<li>封装为 ROS2 节点：<strong>订阅图像/相机内参/TF</strong>，发布调试图像与 <strong>Marker</strong>。</li>
</ol>
<hr />
<h2>关键知识点速通</h2>
<ul>
<li><strong>轮廓检测与几何筛选（OpenCV）</strong>：<code>findContours</code>、旋转矩形、长短边比、倾角、区域颜色统计。</li>
<li><strong>透视展开</strong>：<code>getPerspectiveTransform</code> + <code>warpPerspective</code> 把斜着的装甲板拉直。</li>
<li><strong>二值化与分类（OpenCV DNN）</strong>：OTSU 自动阈值、<code>blobFromImage</code>、ONNX 前向。</li>
<li><strong>PnP 位姿估计</strong>：2D-3D 对应点 + 相机内参 → <code>solvePnPGeneric</code> 求 R/t。</li>
<li><strong>两解选择与稳定化</strong>：重投影误差、roll 限制、根据灯条倾斜推断 yaw 正负。</li>
<li><strong>BA（Bundle Adjustment）</strong>：这里<strong>只优化 yaw</strong>，用 g2o 把像素投影误差最小化。</li>
<li><strong>ROS2 组件化</strong>：参数声明、话题订阅/发布、动态参数回调、TF 查询、RViz 可视化。</li>
</ul>
<hr />
<h2>端到端流程图（一帧图像如何被处理）</h2>
<pre><code>Image(rgb8)
   └─► 预处理(灰度/阈值)
          └─► 轮廓→灯条(Light)
                 └─► 同色 + 几何关系 → 装甲(Armor)
                        ├─► (可选) 灯条角点精修
                        ├─► 透视展开数字ROI → 二值化 → 分类
                        └─► PnP求位姿 → (可选) BA优化yaw
                               └─► 发布Armors + RViz Marker + 调试图像
</code></pre>
<hr />
<h2>模块逐个拆解（含核心代码片段）</h2>
<h3>4.1 数字分类器 <code>NumberClassifier</code></h3>
<p><strong>职责</strong>：从装甲板两根灯条之间裁出数字图（固定尺寸），二值化后喂给 ONNX 分类网络，得到类别与置信度。</p>
<p><strong>核心：透视展开 + 二值化 + DNN 前向</strong></p>
<pre><code>// 透视展开并裁 ROI（宽度随大小装甲而变）
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp; src, const Armor&amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // 中部 ROI → 灰度&amp;OTSU → 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
</code></pre>
<pre><code>// 前向分类 + 结果解码
void NumberClassifier::classify(const cv::Mat&amp;, Armor&amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;conf, nullptr, &amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format("{}:{:.1f}%", armor.number, armor.confidence * 100.0);
}
</code></pre>
<pre><code>// 过滤：按阈值/忽略列表 + 大小装甲与类别的互斥规则
void NumberClassifier::eraseIgnoreClasses(std::vector&lt;Armor&gt;&amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;a) {
    if (a.confidence &lt; threshold) return true;
    for (auto&amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == "outpost" || a.number == "2" || a.number == "sentry");
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == "1"      || a.number == "base");
    return mismatch;
  }), armors.end());
}
</code></pre>
<p><strong>要点</strong>：ROI 宽度与装甲尺寸匹配；OTSU 让阈值更稳；<code>blobFromImage</code> 封装归一化与 NHWC→NCHW。</p>
<hr />
<h3>4.2 视觉检测器 <code>Detector</code></h3>
<p><strong>职责</strong>：灰度/阈值 → 轮廓 → 灯条（形状 + 倾角）→ 统计颜色 → 左右同色配对 → 装甲。若有分类器与角点修正器，则并行进行数字分类与角点细化。</p>
<p><strong>总体流程</strong></p>
<pre><code>std::vector&lt;Armor&gt; Detector::detect(const cv::Mat&amp; input) noexcept {
  binary_img = preprocessImage(input);               // 灰度+固定阈值
  lights_    = findLights(input, binary_img);        // 轮廓→Light（比例/角度/颜色）
  armors_    = matchLights(lights_);                 // 左右配对 → Armor

  if (!armors_.empty() &amp;&amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;input](Armor&amp; a){
      a.number_img = classifier-&gt;extractNumber(input, a);
      classifier-&gt;classify(input, a);
      if (corner_corrector) corner_corrector-&gt;correctCorners(a, gray_img_);
    });
    classifier-&gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
</code></pre>
<p><strong>关键判定：灯条与配对</strong></p>
<pre><code>// 灯条筛选：短长边比 + 倾角
bool Detector::isLight(const Light&amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &lt; ratio &amp;&amp; ratio &lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &lt; light_params.max_angle;
  return ratio_ok &amp;&amp; angle_ok;
}

// 颜色：在轮廓像素中统计R/B强度差（红/蓝）
for (auto&amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &gt; light_params.color_diff_thresh)
  light.color = (sum_r &gt; sum_b ? RED : BLUE);

// 夹灯检测：两灯条外接矩形内是否还“夹”着别的灯条（且排除数字/红点等干扰）
bool containLight(int i, int j, const std::vector&lt;Light&gt;&amp; lights);

// 配对：同色 + X方向扫描 + 中心距窗口（区分大小装甲）+ 两灯条长度相近 + 夹角限制
std::vector&lt;Armor&gt; Detector::matchLights(const std::vector&lt;Light&gt;&amp; lights) noexcept;
</code></pre>
<hr />
<h3>4.3 灯条角点精修 <code>LightCornerCorrector</code></h3>
<p><strong>职责</strong>：更精确地找到每根灯条的<strong>上下端点</strong>与<strong>中心/轴向</strong>，提升 PnP 的 2D-3D 对应精度（在二值化或噪声环境下尤其有用）。</p>
<p><strong>算法思路</strong>：</p>
<ol>
<li>以灯条外接框为基础做<strong>适度扩展</strong>并检查边界；</li>
<li>对该小区域做<strong>重心与主方向</strong>估计（亮度加权 + PCA/一阶矩），得到<strong>对称轴</strong>；</li>
<li>沿对称轴的上下方向，以多个平行“扫描线”寻找<strong>亮度突变最大</strong>的位置作为端点候选，最后求平均。</li>
</ol>
<p><strong>要点代码</strong></p>
<pre><code>// 角点修正入口：宽度太小则跳过，避免噪声
void LightCornerCorrector::correctCorners(Armor&amp; armor, const cv::Mat&amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
  if (armor.right_light.width &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
}

// 沿对称轴寻找“亮度突变最大”的点作为角点（多条平行线，取候选平均）
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp; gray, const Light&amp; light,
                                             const SymmetryAxis&amp; axis, std::string order) {
  // ... 扫描 START~END 的小段，累计亮度差最大处 ...
  // 返回均值点；无候选则返回 (-1,-1)
}
</code></pre>
<hr />
<h3>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</h3>
<p><strong>职责</strong>：把装甲四角的 2D 像素点与已知 3D 模型点（大/小装甲的真实尺寸）对应，解出 R/t。若 roll 小且开启 BA，则进一步仅在 <strong>yaw</strong> 维进行图优化，使投影误差更小。</p>
<p><strong>核心流程</strong></p>
<pre><code>// 1) PnP 初解（solvePnPGeneric 可能返回两组解）
if (pnp_solver_-&gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) 解的选择（误差/roll/灯条倾角→yaw正负）

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;&amp; roll &lt; 15) {
    // 3) BA：仅优化 yaw，小幅修正 R 以减小投影误差
    R = ba_solver_-&gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) 填充消息（位姿 + 文本）
}
</code></pre>
<p><strong>两解选择（直觉）</strong>：</p>
<ul>
<li>先看<strong>重投影误差</strong>与 <strong>roll</strong>（太差的解直接放弃切换）；</li>
<li>再用<strong>灯条在像面上的整体倾斜</strong>来判断当前<strong>yaw 的正负是否“合理”</strong>，必要时对调解。</li>
</ul>
<hr />
<h3>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></h3>
<p><strong>思想</strong>：只把<strong>装甲 yaw</strong> 当成优化变量（一个顶点 <code>VertexYaw</code>），装甲的 3D 角点为固定顶点。观测为每个角点在图像里的像素位置，误差就是<strong>观测像素</strong>减去<strong>投影像素</strong>。这样 BA 既轻量又能稳住姿态。</p>
<p><strong>构图与优化</strong></p>
<pre><code>// 填图：一个 yaw 顶点 + 四个固定的 3D 顶点 + 四条投影误差边（带 Huber 鲁棒核）
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&gt;setVertex(0, v_yaw); e-&gt;setVertex(1, vp);
  e-&gt;setMeasurement(pixel_observation);
  e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
</code></pre>
<pre><code>// 自定义顶点增量：在 SO3 上用李代数更新 yaw，避免角度跳变
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
</code></pre>
<pre><code>// 投影边误差：像素观测 - 投影(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&lt;VertexYaw*&gt;(_vertices[0])-&gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&lt;2&gt;();
  _error = obs - proj;
}
</code></pre>
<hr />
<h3>4.6 ROS2 节点 <code>ArmorDetectorNode</code></h3>
<p><strong>职责</strong>：把检测 → 分类 →（可选）角点修正 → PnP/BA → 发布可视化，全流程在 ROS2 中跑起来。负责：参数、订阅/发布、TF、调试。</p>
<p><strong>节点初始化（节选）</strong></p>
<pre><code>// 读取参数，初始化 Detector、NumberClassifier、LightCornerCorrector
int binary_thres = declare_parameter("binary_thres", 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&lt;Detector&gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/lenet.onnx");
auto label_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/label.txt");
double threshold = declare_parameter("classifier_threshold", 0.7);
auto ignores = declare_parameter&lt;std::vector&lt;std::string&gt;&gt;("ignore_classes", {"negative"});
detector_-&gt;classifier = std::make_unique&lt;NumberClassifier&gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter("use_pca", true);
if (use_pca) detector_-&gt;corner_corrector = std::make_unique&lt;LightCornerCorrector&gt;();
</code></pre>
<p><strong>图像回调（节选）</strong></p>
<pre><code>// 1) TF: odom → 相机的旋转矩阵（IMU→Camera）
auto odom_to_cam = tf2_buffer_-&gt;lookupTransform(odom_frame_, img_msg-&gt;header.frame_id, img_msg-&gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) 检测 + 分类 + 角点修正
auto armors = detector_-&gt;detect(cv_bridge::toCvShare(img_msg, "rgb8")-&gt;image);

// 3) PnP/BA 提取位姿
armors_msg_.armors = armor_pose_estimator_-&gt;extractArmorPoses(armors, imu_to_camera);

// 4) 可视化与发布：Marker / 调试图像 / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&gt;publish(armors_msg_);
</code></pre>
<hr />
<h2>参数如何影响效果（调参指南）</h2>
<ul>
<li><code>binary_thres</code>：阈值高→噪点少但灯条可能断；阈值低→连通域粘连。先打开调试图像话题观察再调。</li>
<li><code>light.min_ratio / max_ratio / max_angle</code>：控制灯条的“细长”和“近垂直”程度；误检多就收紧，漏检多就放宽。</li>
<li><code>light.color_diff_thresh</code>：越大越“保守”地判断颜色；太小会把杂散光当成红/蓝。</li>
<li><code>armor.*_center_distance</code>：两灯条中心距窗口；与焦距/距离有关，镜头变化后要重调。</li>
<li><code>classifier_threshold / ignore_classes</code>：分类阈值与忽略类，先松后紧，结合实测混淆再收敛。</li>
<li><code>use_pca</code>：角点修正，噪声环境或分辨率不高时常有帮助。</li>
<li><code>use_ba</code>：轻量的 yaw 优化，能减抖、稳姿态；但在极端视角下可能收益有限。</li>
</ul>
<hr />
<h2>实战：从源码到运行与可视化</h2>
<ol>
<li><strong>准备</strong>：相机话题 <code>image_raw</code>、<code>camera_info</code>，并确认 TF 链路（<code>odom → camera</code>）。</li>
<li><strong>启动节点</strong>：加载参数（上面提到的阈值与窗口）并打开 <code>debug</code>。</li>
<li><strong>RViz</strong>：添加 <code>MarkerArray</code> 订阅 <code>armor_detector/marker</code>；把调试图像话题（<code>binary_img/number_img/result_img</code>）也开出来。</li>
<li><strong>观察与调整</strong>：
<ul>
<li>先让<strong>灯条候选</strong>稳定 → 再看<strong>配对</strong>是否合理 → 最后看<strong>数字分类</strong>与<strong>位姿</strong>是否稳定。</li>
<li>逐项微调参数，记录每项调整对召回/精度的影响。</li>
</ul>
</li>
</ol>
<hr />
<h2>常见问题与定位思路</h2>
<ul>
<li><strong>灯条“夹灯”/误配对</strong>：检查 <code>containLight</code> 规则与数字/红点宽度过滤；适当提高 <code>color_diff_thresh</code>。</li>
<li><strong>分类不稳</strong>：对比 <code>number_img</code> 是否干净；检查 ROI 宽度是否与大/小装甲一致；适当调阈值或忽略类。</li>
<li><strong>位姿“翻面”</strong>：理解 <code>sortPnPResult</code> 的选择逻辑（误差、roll、灯条倾角与 yaw 正负），必要时在近景贴纸纹理上做辅助。</li>
<li><strong>姿态抖动</strong>：开启 <code>use_ba</code>；或在 <code>LightCornerCorrector</code> 中加大候选条数。</li>
</ul>
<hr />
<h2>进阶练习题（带方向提示）</h2>
<ol>
<li><strong>把阈值改成自适应</strong>：尝试 <code>cv::adaptiveThreshold</code> 或根据区域亮度动态调 <code>binary_thres</code>。</li>
<li><strong>加入时序稳定</strong>：在 <code>Detector</code> 输出上做跟踪（Kalman/匈牙利匹配），让数字与姿态在帧间更稳。</li>
<li><strong>数据增强与再训练</strong>：对 <code>number_img</code> 做随机仿射/噪声增强，微调 ONNX 模型，观察混淆类的改善。</li>
<li><strong>多目标选择策略</strong>：当同屏多块装甲时，基于 <code>distance_to_image_center</code>、置信度或历史 ID 选择目标。</li>
</ol>
<hr />
<h2>术语与坐标系小抄</h2>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term=" RM "></category>
  </entry>
  <entry>
    <title>视频测试</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>视频测试。</summary>
    <content type="html"><![CDATA[<p>这是视频测试</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="测试"></category>
  </entry>
  <entry>
    <title>markdown</title>
    <link href="https://www.nanye404.top/posts/markdown-tutorial/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/markdown-tutorial/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>例子</summary>
    <content type="html"><![CDATA[<h1>Markdown Tutorial</h1>
<p>A markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF).</p>
<ul>
<li><a href="#block-elements">Block Elements</a>
<ul>
<li><a href="#paragraphs-and-line-breaks">Paragraphs and Line Breaks</a></li>
<li><a href="#headers">Headers</a></li>
<li><a href="#blockquotes">Blockquotes</a></li>
<li><a href="#lists">Lists</a></li>
<li><a href="#code-blocks">Code Blocks</a></li>
<li><a href="#horizontal-rules">Horizontal Rules</a></li>
<li><a href="#table">Table</a></li>
</ul>
</li>
<li><a href="#span-elements">Span Elements</a>
<ul>
<li><a href="#links">Links</a></li>
<li><a href="#emphasis">Emphasis</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#images">Images</a></li>
<li><a href="#strikethrough">Strikethrough</a></li>
</ul>
</li>
<li><a href="#miscellaneous">Miscellaneous</a>
<ul>
<li><a href="#automatic-links">Automatic Links</a></li>
<li><a href="#backslash-escapes">Backslash Escapes</a></li>
</ul>
</li>
<li><a href="#inline-html">Inline HTML</a></li>
</ul>
<h2>Block Elements</h2>
<h3>Paragraphs and Line Breaks</h3>
<h4>Paragraphs</h4>
<p>HTML Tag: <code>&lt;p&gt;</code></p>
<p>One or more blank lines. (A blank line is a line containing nothing but <strong>spaces</strong> or <strong>tabs</strong> is considered blank.)</p>
<p>Code:</p>
<pre><code>This will be
inline.

This is second paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be
inline.</p>
<p>This is second paragraph.</p>
<hr />
<h4>Line Breaks</h4>
<p>HTML Tag: <code>&lt;br /&gt;</code></p>
<p>End a line with <strong>two or more spaces</strong>.</p>
<p>Code:</p>
<pre><code>This will be not
inline.
</code></pre>
<p>Preview:</p>
<hr />
<p>This will be not<br />
inline.</p>
<hr />
<h3>Headers</h3>
<p>Markdown supports two styles of headers, Setext and atx.</p>
<h4>Setext</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code></p>
<p>"Underlined" using <strong>equal signs (=)</strong> as <code>&lt;h1&gt;</code> and <strong>dashes (-)</strong> as <code>&lt;h2&gt;</code> in any number.</p>
<p>Code:</p>
<pre><code>This is an H1
=============
This is an H2
-------------
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<hr />
<h4>atx</h4>
<p>HTML Tags: <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code></p>
<p>Uses 1-6 <strong>hash characters (#)</strong> at the start of the line, corresponding to <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>.</p>
<p>Code:</p>
<pre><code># This is an H1
## This is an H2
###### This is an H6
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h6>This is an H6</h6>
<hr />
<p>Optionally, you may "close" atx-style headers. The closing hashes <strong>don't need to match</strong> the number of hashes used to open the header.</p>
<p>Code:</p>
<pre><code># This is an H1 #
## This is an H2 ##
### This is an H3 ######
</code></pre>
<p>Preview:</p>
<hr />
<h1>This is an H1</h1>
<h2>This is an H2</h2>
<h3>This is an H3</h3>
<hr />
<h3>Blockquotes</h3>
<p>HTML Tag: <code>&lt;blockquote&gt;</code></p>
<p>Markdown uses email-style <strong>&gt;</strong> characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt;
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph.</p>
<p>Code:</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<hr />
<p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;.</p>
<p>Code:</p>
<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<hr />
<p>Blockquotes can contain other Markdown elements, including headers, lists, and code blocks.</p>
<p>Code:</p>
<pre><code>&gt; ## This is a header.
&gt;
&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt;
&gt; Here's some example code:
&gt;
&gt;     return shell_exec("echo $input | $markdown_script");
</code></pre>
<p>Preview:</p>
<hr />
<blockquote>
<h2>This is a header.</h2>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here's some example code:</p>
<pre><code>return shell_exec("echo $input | $markdown_script");
</code></pre>
</blockquote>
<hr />
<h3>Lists</h3>
<p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p>
<h4>Unordered</h4>
<p>HTML Tag: <code>&lt;ul&gt;</code></p>
<p>Unordered lists use <strong>asterisks (*)</strong>, <strong>pluses (+)</strong>, and <strong>hyphens (-)</strong>.</p>
<p>Code:</p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<hr />
<p>is equivalent to:</p>
<p>Code:</p>
<pre><code>+   Red
+   Green
+   Blue
</code></pre>
<p>and:</p>
<p>Code:</p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre>
<h4>Ordered</h4>
<p>HTML Tag: <code>&lt;ol&gt;</code></p>
<p>Ordered lists use numbers followed by periods:</p>
<p>Code:</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<hr />
<p>It's possible to trigger an ordered list by accident, by writing something like this:</p>
<p>Code:</p>
<pre><code>1986. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<ol>
<li>What a great season.</li>
</ol>
<hr />
<p>You can <strong>backslash-escape (\)</strong> the period:</p>
<p>Code:</p>
<pre><code>1986\. What a great season.
</code></pre>
<p>Preview:</p>
<hr />
<p>1986. What a great season.</p>
<hr />
<h4>Indented</h4>
<h5>Blockquote</h5>
<p>To put a blockquote within a list item, the blockquote's &gt; delimiters need to be indented:</p>
<p>Code:</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a blockquote:</p>
<blockquote>
<p>This is a blockquote
inside a list item.</p>
</blockquote>
</li>
</ul>
<hr />
<h5>Code Block</h5>
<p>To put a code block within a list item, the code block needs to be indented twice — <strong>8 spaces</strong> or <strong>two tabs</strong>:</p>
<p>Code:</p>
<pre><code>*   A list item with a code block:

        &lt;code goes here&gt;
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>
<p>A list item with a code block:</p>
<pre><code>&lt;code goes here&gt;
</code></pre>
</li>
</ul>
<hr />
<h5>Nested List</h5>
<p>Code:</p>
<pre><code>* A
  * A1
  * A2
* B
* C
</code></pre>
<p>Preview:</p>
<hr />
<ul>
<li>A
<ul>
<li>A1</li>
<li>A2</li>
</ul>
</li>
<li>B</li>
<li>C</li>
</ul>
<hr />
<h3>Code Blocks</h3>
<p>HTML Tag: <code>&lt;pre&gt;</code></p>
<p>Indent every line of the block by at least <strong>4 spaces</strong> or <strong>1 tab</strong>.</p>
<p>Code:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a normal paragraph:</p>
<pre><code>This is a code block.
</code></pre>
<hr />
<p>A code block continues until it reaches a line that is not indented (or the end of the article).</p>
<p>Within a code block, <strong><em>ampersands (&amp;)</em></strong> and angle <strong>brackets (&lt; and &gt;)</strong> are automatically converted into HTML entities.</p>
<p>Code:</p>
<pre><code>    &lt;div class="footer"&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>&lt;div class="footer"&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>
<hr />
<p>Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block.</p>
<h4>Fenced Code Blocks</h4>
<p>Just wrap your code in <code>```</code> (as shown below) and you won't need to indent it by four spaces.</p>
<p>Code:</p>
<pre><code>Here's an example:

```
function test() {
  console.log("notice the blank line before this function?");
}
```
</code></pre>
<p>Preview:</p>
<hr />
<p>Here's an example:</p>
<pre><code>function test() {
  console.log("notice the blank line before this function?");
}
</code></pre>
<hr />
<h4>Syntax Highlighting</h4>
<p>In your fenced block, add an optional language identifier and we'll run it through syntax highlighting (<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">Support Languages</a>).</p>
<p>Code:</p>
<pre><code>```ruby
require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
```
</code></pre>
<p>Preview:</p>
<hr />
<pre><code>require 'redcarpet'
markdown = Redcarpet.new("Hello World!")
puts markdown.to_html
</code></pre>
<hr />
<h3>Horizontal Rules</h3>
<p>HTML Tag: <code>&lt;hr /&gt;</code>
Places <strong>three or more hyphens (-), asterisks (*), or underscores (_)</strong> on a line by themselves. You may use spaces between the hyphens or asterisks.</p>
<p>Code:</p>
<pre><code>* * *
***
*****
- - -
---------------------------------------
___
</code></pre>
<p>Preview:</p>
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<hr />
<h3>Table</h3>
<p>HTML Tag: <code>&lt;table&gt;</code></p>
<p>It's an extension.</p>
<p>Separates column by <strong>pipe (|)</strong> and header by <strong>dashes (-)</strong>, and uses <strong>colon (:)</strong> for alignment.</p>
<p>The outer <strong>pipes (|)</strong> and alignment are optional. There are <strong>3 delimiters</strong> each cell at least for separating header.</p>
<p>Code:</p>
<pre><code>| Left | Center | Right |
|:-----|:------:|------:|
|aaa   |bbb     |ccc    |
|ddd   |eee     |fff    |

 A | B
---|---
123|456


A |B
--|--
12|45
</code></pre>
<p>Preview:</p>
<hr />
<table>
<thead>
<tr>
<th>Left</th>
<th>Center</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>aaa</td>
<td>bbb</td>
<td>ccc</td>
</tr>
<tr>
<td>ddd</td>
<td>eee</td>
<td>fff</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>123</td>
<td>456</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>45</td>
</tr>
</tbody>
</table>
<hr />
<h2>Span Elements</h2>
<h3>Links</h3>
<p>HTML Tag: <code>&lt;a&gt;</code></p>
<p>Markdown supports two style of links: inline and reference.</p>
<h4>Inline</h4>
<p>Inline link format like this: <code>[Link Text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>This is [an example](http://example.com/ "Title") inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> inline link.</p>
<p><a href="http://example.net/">This link</a> has no title attribute.</p>
<hr />
<p>If you're referring to a local resource on the same server, you can use relative paths:</p>
<p>Code:</p>
<pre><code>See my [About](/about/) page for details.
</code></pre>
<p>Preview:</p>
<hr />
<p>See my <a href="/about/">About</a> page for details.</p>
<hr />
<h4>Reference</h4>
<p>You could predefine link references. Format like this: <code>[id]: URL "Title"</code></p>
<p>Title is also optional. And the you refer the link, format like this: <code>[Link Text][id]</code></p>
<p>Code:</p>
<pre><code>[id]: http://example.com/  "Optional Title Here"
This is [an example][id] reference-style link.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is <a href="http://example.com/">an example</a> reference-style link.</p>
<hr />
<p>That is:</p>
<ul>
<li>Square brackets containing the link identifier (<strong>not case sensitive</strong>, optionally indented from the left margin using up to three spaces);</li>
<li>followed by a colon;</li>
<li>followed by one or more spaces (or tabs);</li>
<li>followed by the URL for the link;</li>
<li>The link URL may, optionally, be surrounded by angle brackets.</li>
<li>optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses.</li>
</ul>
<p>The following three link definitions are equivalent:</p>
<p>Code:</p>
<pre><code>[foo]: http://example.com/  "Optional Title Here"
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
[foo]: &lt;http://example.com/&gt;  "Optional Title Here"
</code></pre>
<p>Uses an empty set of square brackets, the link text itself is used as the name.</p>
<p>Code:</p>
<pre><code>[Google]: http://google.com/
[Google][]
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://google.com/">Google</a></p>
<hr />
<h3>Emphasis</h3>
<p>HTML Tags: <code>&lt;em&gt;</code>, <code>&lt;strong&gt;</code></p>
<p>Markdown treats <strong>asterisks (*)</strong> and <strong>underscores (_)</strong> as indicators of emphasis. <strong>One delimiter</strong> will be <code>&lt;em&gt;</code>; *<em>double delimiters</em> will be <code>&lt;strong&gt;</code>.</p>
<p>Code:</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>
<p>Preview:</p>
<hr />
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<hr />
<p>But if you surround an * or _ with spaces, it'll be treated as a literal asterisk or underscore.</p>
<p>You can backslash escape it:</p>
<p>Code:</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*this text is surrounded by literal asterisks*</p>
<hr />
<h3>Code</h3>
<p>HTML Tag: <code>&lt;code&gt;</code></p>
<p>Wraps it with <strong>backtick quotes (`)</strong>.</p>
<p>Code:</p>
<pre><code>Use the `printf()` function.
</code></pre>
<p>Preview:</p>
<hr />
<p>Use the <code>printf()</code> function.</p>
<hr />
<p>To include a literal backtick character within a code span, you can use <strong>multiple backticks</strong> as the opening and closing delimiters:</p>
<p>Code:</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre>
<p>Preview:</p>
<hr />
<p><code>There is a literal backtick (`) here.</code></p>
<hr />
<p>The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span:</p>
<p>Code:</p>
<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>
<p>Preview:</p>
<hr />
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<hr />
<h3>Images</h3>
<p>HTML Tag: <code>&lt;img /&gt;</code></p>
<p>Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference.</p>
<h4>Inline</h4>
<p>Inline image syntax looks like this: <code>![Alt text](URL "Title")</code></p>
<p>Title is optional.</p>
<p>Code:</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg "Optional title")
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" /></p>
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title" /></p>
<hr />
<p>That is:</p>
<ul>
<li>An exclamation mark: !;</li>
<li>followed by a set of square brackets, containing the alt attribute text for the image;</li>
<li>followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes.</li>
</ul>
<h4>Reference</h4>
<p>Reference-style image syntax looks like this: <code>![Alt text][id]</code></p>
<p>Code:</p>
<pre><code>[img id]: https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp  "Optional title attribute"
![Alt text][img id]
</code></pre>
<p>Preview:</p>
<hr />
<p><img src="https://s2.loli.net/2024/08/20/5fszgXeOxmL3Wdv.webp" alt="Alt text" title="Optional title attribute" /></p>
<hr />
<h3>Strikethrough</h3>
<p>HTML Tag: <code>&lt;del&gt;</code></p>
<p>It's an extension.</p>
<p>GFM adds syntax to strikethrough text.</p>
<p>Code:</p>
<pre><code>~~Mistaken text.~~
</code></pre>
<p>Preview:</p>
<hr />
<p><s>Mistaken text.</s></p>
<hr />
<h2>Miscellaneous</h2>
<h3>Automatic Links</h3>
<p>Markdown supports a shortcut style for creating "automatic" links for URLs and email addresses: simply surround the URL or email address with angle brackets.</p>
<p>Code:</p>
<pre><code>&lt;http://example.com/&gt;

&lt;address@example.com&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p><a href="http://example.com/">http://example.com/</a></p>
<p><a href="mailto:address@example.com">address@example.com</a></p>
<hr />
<p>GFM will autolink standard URLs.</p>
<p>Code:</p>
<pre><code>https://github.com/emn178/markdown
</code></pre>
<p>Preview:</p>
<hr />
<p>https://github.com/emn178/markdown</p>
<hr />
<h3>Backslash Escapes</h3>
<p>Markdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown's formatting syntax.</p>
<p>Code:</p>
<pre><code>\*literal asterisks\*
</code></pre>
<p>Preview:</p>
<hr />
<p>*literal asterisks*</p>
<hr />
<p>Markdown provides backslash escapes for the following characters:</p>
<p>Code:</p>
<pre><code>\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
</code></pre>
<h2>Inline HTML</h2>
<p>For any markup that is not covered by Markdown's syntax, you simply use HTML itself. There's no need to preface it or delimit it to indicate that you're switching from Markdown to HTML; you just use the tags.</p>
<p>Code:</p>
<pre><code>This is a regular paragraph.

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

This is another regular paragraph.
</code></pre>
<p>Preview:</p>
<hr />
<p>This is a regular paragraph.</p>
<p>&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;Foo&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</p>
<p>This is another regular paragraph.</p>
<hr />
<p>Note that Markdown formatting syntax is <strong>not processed within block-level HTML tags</strong>.</p>
<p>Unlike block-level HTML tags, Markdown syntax is <strong>processed within span-level tags</strong>.</p>
<p>Code:</p>
<pre><code>&lt;span&gt;**Work**&lt;/span&gt;

&lt;div&gt;
    **No Work**
&lt;/div&gt;
</code></pre>
<p>Preview:</p>
<hr />
<p>&lt;span&gt;<strong>Work</strong>&lt;/span&gt;</p>
<p>&lt;div&gt;
<strong>No Work</strong>
&lt;/div&gt;</p>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="测试"></category>
  </entry>
</feed>