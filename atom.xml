<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>å—å¶ã®å°çª</title>
  <subtitle>æ¬¢è¿æ¥ç©awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-10-24T15:52:44.637Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>RMè£…ç”²æ¿è¯†åˆ« - 03 å½¢æ€å­¦å¤„ç†</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_03/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_03/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>æ— </summary>
    <content type="html"><![CDATA[<h2>æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>ä½œç”¨</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::getStructuringElement()</code></td>
<td>åˆ›å»ºå½¢æ€å­¦æ ¸</td>
</tr>
<tr>
<td><code>cv::dilate()</code></td>
<td>è†¨èƒ€ï¼ˆå˜èƒ–ï¼‰</td>
</tr>
<tr>
<td><code>cv::erode()</code></td>
<td>è…èš€ï¼ˆå˜ç˜¦ï¼‰</td>
</tr>
<tr>
<td><code>cv::morphologyEx()</code></td>
<td>é«˜çº§å½¢æ€å­¦</td>
</tr>
</tbody>
</table>
<hr />
<h2>æ ¸å¿ƒæ€è·¯</h2>
<p>é¢œè‰²æå–åçš„äºŒå€¼å›¾æœ‰ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š</p>
<h3>é—®é¢˜1: å™ªç‚¹ï¼ˆå°ç™½ç‚¹åˆ°å¤„éƒ½æ˜¯ï¼‰</h3>
<h3>é—®é¢˜2: æ–­è£‚ï¼ˆç¯æ¡ä¸­é—´æœ‰ç¼éš™ï¼‰</h3>
<p><strong>å½¢æ€å­¦æ“ä½œå°±æ˜¯è§£å†³è¿™äº›é—®é¢˜çš„å·¥å…·ï¼</strong></p>
<hr />
<h2>å½¢æ€å­¦å››ç§å¤„ç†æ–¹å¼</h2>
<table>
<thead>
<tr>
<th>æ“ä½œ</th>
<th>æ•ˆæœ</th>
<th>æ¯”å–»</th>
<th>ç”¨é€”</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>è†¨èƒ€ dilate</strong></td>
<td>ç™½è‰²åŒºåŸŸå˜å¤§</td>
<td>æ¶‚èƒ–ç¬”</td>
<td>è¿æ¥æ–­è£‚</td>
</tr>
<tr>
<td><strong>è…èš€ erode</strong></td>
<td>ç™½è‰²åŒºåŸŸå˜å°</td>
<td>æ©¡çš®æ“¦</td>
<td>å»é™¤å™ªç‚¹</td>
</tr>
<tr>
<td><strong>å¼€è¿ç®— open</strong></td>
<td>å…ˆè…èš€åè†¨èƒ€</td>
<td>å…ˆæ“¦åæ¶‚</td>
<td>å»å™ªä¿å½¢</td>
</tr>
<tr>
<td><strong>é—­è¿ç®— close</strong></td>
<td>å…ˆè†¨èƒ€åè…èš€</td>
<td>å…ˆæ¶‚åæ“¦</td>
<td>å¡«ç¼ä¿å½¢</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::getStructuringElement() - åˆ›å»ºå½¢æ€å­¦æ ¸</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>Mat cv::getStructuringElement(int shape, Size ksize, 
                               Point anchor = Point(-1,-1));
</code></pre>
<h3>æ ¸å½¢çŠ¶ç±»å‹</h3>
<table>
<thead>
<tr>
<th>shape</th>
<th>è¯´æ˜</th>
<th>æ•ˆæœ</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_RECT</code></td>
<td>çŸ©å½¢ï¼ˆæœ€å¸¸ç”¨ï¼‰</td>
<td>å„æ–¹å‘å‡åŒ€</td>
</tr>
<tr>
<td><code>MORPH_ELLIPSE</code></td>
<td>æ¤­åœ†å½¢</td>
<td>è¾¹ç¼˜æ›´åœ†æ»‘</td>
</tr>
<tr>
<td><code>MORPH_CROSS</code></td>
<td>åå­—å½¢</td>
<td>åªä½œç”¨äºä¸Šä¸‹å·¦å³</td>
</tr>
</tbody>
</table>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>// åˆ›å»º3Ã—3çŸ©å½¢æ ¸
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// åˆ›å»º5Ã—5æ¤­åœ†æ ¸
cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));

// åˆ›å»º7Ã—7åå­—æ ¸
cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(7, 7));
</code></pre>
<h3>æ ¸å¤§å°å¦‚ä½•é€‰æ‹©ï¼Ÿ</h3>
<table>
<thead>
<tr>
<th>å°ºå¯¸</th>
<th>æ•ˆæœ</th>
<th>é€‚ç”¨åœºæ™¯</th>
</tr>
</thead>
<tbody>
<tr>
<td>3Ã—3</td>
<td>è½»å¾®å¤„ç†</td>
<td>å°å™ªç‚¹ã€ç»†å¾®ç¼éš™</td>
</tr>
<tr>
<td>5Ã—5</td>
<td>ä¸­ç­‰æ•ˆæœ</td>
<td><strong>æ¨è</strong>ï¼Œå¹³è¡¡æ•ˆæœå’Œæ€§èƒ½</td>
</tr>
<tr>
<td>7Ã—7</td>
<td>å¼ºåŠ›æ•ˆæœ</td>
<td>å¤§å™ªç‚¹ã€å¤§ç¼éš™ï¼ˆå¯èƒ½ç ´åç¯æ¡å½¢çŠ¶ï¼‰</td>
</tr>
<tr>
<td>9Ã—9+</td>
<td>æå¼ºæ•ˆæœ</td>
<td>æ…ç”¨ï¼å®¹æ˜“æŠŠç¯æ¡å˜å½¢</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. cv::dilate() - è†¨èƒ€æ“ä½œ</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::dilate(InputArray src, OutputArray dst, InputArray kernel,
                Point anchor = Point(-1,-1), int iterations = 1);
</code></pre>
<h3>ğŸ“‹ å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src</code></td>
<td>è¾“å…¥äºŒå€¼å›¾</td>
</tr>
<tr>
<td><code>dst</code></td>
<td>è¾“å‡ºç»“æœ</td>
</tr>
<tr>
<td><code>kernel</code></td>
<td>å½¢æ€å­¦æ ¸</td>
</tr>
<tr>
<td><code>anchor</code></td>
<td>é”šç‚¹ä½ç½®ï¼ˆ-1,-1è¡¨ç¤ºä¸­å¿ƒï¼‰</td>
</tr>
<tr>
<td><code>iterations</code></td>
<td>è¿­ä»£æ¬¡æ•°ï¼ˆé‡å¤è†¨èƒ€å‡ æ¬¡ï¼‰</td>
</tr>
</tbody>
</table>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è…èš€ä¸€æ¬¡
cv::Mat eroded;
cv::erode(binary, eroded, kernel);

cv::imshow("åŸå§‹äºŒå€¼å›¾", binary);
cv::imshow("è…èš€å", eroded);
cv::waitKey(0);
</code></pre>
<h3>åº”ç”¨åœºæ™¯</h3>
<ul>
<li>å»é™¤å°å™ªç‚¹</li>
<li>åˆ†ç¦»ç²˜è¿ç‰©ä½“</li>
</ul>
<h3>è…èš€çš„å‰¯ä½œç”¨</h3>
<ul>
<li>ç¯æ¡ä¹Ÿä¼šå˜ç»†</li>
<li>è§£å†³æ–¹æ¡ˆï¼šè…èš€åå†è†¨èƒ€å›æ¥ï¼ˆå¼€è¿ç®—ï¼‰</li>
</ul>
<hr />
<h2>4. cv::morphologyEx() - é«˜çº§å½¢æ€å­¦æ“ä½œ</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::morphologyEx(InputArray src, OutputArray dst, int op,
                      InputArray kernel, Point anchor = Point(-1,-1),
                      int iterations = 1);
</code></pre>
<h3>æ“ä½œç±»å‹</h3>
<table>
<thead>
<tr>
<th>op</th>
<th>æ“ä½œ</th>
<th>å…¬å¼</th>
<th>æ•ˆæœ</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_OPEN</code></td>
<td>å¼€è¿ç®—</td>
<td>erode â†’ dilate</td>
<td><strong>å»å™ªä¿å½¢</strong></td>
</tr>
<tr>
<td><code>MORPH_CLOSE</code></td>
<td>é—­è¿ç®—</td>
<td>dilate â†’ erode</td>
<td><strong>å¡«ç¼ä¿å½¢</strong></td>
</tr>
<tr>
<td><code>MORPH_GRADIENT</code></td>
<td>å½¢æ€å­¦æ¢¯åº¦</td>
<td>dilate - erode</td>
<td>æå–è¾¹ç¼˜</td>
</tr>
<tr>
<td><code>MORPH_TOPHAT</code></td>
<td>é¡¶å¸½</td>
<td>src - open</td>
<td>æå–å°äº®ç‚¹</td>
</tr>
<tr>
<td><code>MORPH_BLACKHAT</code></td>
<td>é»‘å¸½</td>
<td>close - src</td>
<td>æå–å°æš—ç‚¹</td>
</tr>
</tbody>
</table>
<hr />
<h2>5. é—­è¿ç®— (MORPH_CLOSE)</h2>
<h3>å·¥ä½œåŸç†</h3>
<ul>
<li>é—­è¿ç®— = å…ˆè†¨èƒ€ â†’ å†è…èš€</li>
</ul>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// é—­è¿ç®—
cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);

cv::imshow("åŸå§‹", binary);
cv::imshow("é—­è¿ç®—å", closed);
cv::waitKey(0);
</code></pre>
<h3>åº”ç”¨åœºæ™¯</h3>
<ul>
<li>è¿æ¥ç¯æ¡çš„ç»†å¾®æ–­è£‚</li>
<li>å¡«è¡¥ç¯æ¡å†…éƒ¨çš„å°é»‘æ´</li>
<li>ä¿æŒç¯æ¡çš„æ•´ä½“å½¢çŠ¶</li>
</ul>
<h3>æ³¨æ„äº‹é¡¹</h3>
<pre><code>// æ ¸å¤ªå¤§ä¼šè®©ä¸¤ä¸ªç¯æ¡ç²˜åœ¨ä¸€èµ·ï¼
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
//  å¯èƒ½å¯¼è‡´å·¦å³ç¯æ¡åˆå¹¶

// æ¨èä½¿ç”¨5Ã—5æˆ–7Ã—7
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
</code></pre>
<hr />
<h2>6. å¼€è¿ç®— (MORPH_OPEN) - å»å™ªåˆ©å™¨</h2>
<h3>å·¥ä½œåŸç†</h3>
<ul>
<li>å¼€è¿ç®— = å…ˆè…èš€ â†’ å†è†¨èƒ€</li>
</ul>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// å¼€è¿ç®—
cv::Mat opened;
cv::morphologyEx(binary, opened, cv::MORPH_OPEN, kernel);
</code></pre>
<h3>åº”ç”¨åœºæ™¯</h3>
<ul>
<li>å»é™¤å°å™ªç‚¹</li>
<li>åˆ†ç¦»è½»å¾®ç²˜è¿çš„ç‰©ä½“</li>
<li>å¹³æ»‘ç‰©ä½“è¾¹ç¼˜</li>
</ul>
<hr />
<h2>7. RMè£…ç”²æ¿è¯†åˆ«æ¨èæµç¨‹</h2>
<h3>æ ‡å‡†æµç¨‹ï¼ˆä¸¤æ­¥æ³•ï¼‰</h3>
<pre><code>cv::Mat processArmor(const cv::Mat&amp; img) {
    // 1. é¢œè‰²æå–
    cv::Mat binary = extractColor(img);  // ä»ç¬¬02ç« è·å¾—
    
    // 2. å½¢æ€å­¦å¤„ç†
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // ç¬¬ä¸€æ­¥ï¼šé—­è¿ç®—ï¼ˆå¡«è¡¥ç¯æ¡ç¼éš™ï¼‰
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // ç¬¬äºŒæ­¥ï¼šå¼€è¿ç®—ï¼ˆå»é™¤å™ªç‚¹ï¼‰
    cv::Mat result;
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    return result;
}
</code></pre>
<hr />
<h2>8. å½¢æ€å­¦æ¢¯åº¦ (MORPH_GRADIENT)</h2>
<h3>å·¥ä½œåŸç†</h3>
<pre><code>æ¢¯åº¦ = è†¨èƒ€ - è…èš€
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat gradient;
cv::morphologyEx(binary, gradient, cv::MORPH_GRADIENT, kernel);
</code></pre>
<h3>æ•ˆæœ</h3>
<p>æå–ç‰©ä½“çš„<strong>å¤–è½®å»“çº¿</strong>ï¼Œç±»ä¼¼è¾¹ç¼˜æ£€æµ‹</p>
<h3>åº”ç”¨åœºæ™¯</h3>
<ul>
<li>èƒ½é‡æœºå…³æ‰‡å¶è¾¹ç¼˜æ£€æµ‹</li>
<li>è£…ç”²æ¿å¤–æ¡†æå–ï¼ˆä¸å¸¸ç”¨ï¼‰</li>
</ul>
<hr />
<h2>å®Œæ•´å®æˆ˜ä»£ç </h2>
<h3>æ–¹æ¡ˆ1: å¿«é€Ÿç‰ˆï¼ˆå•æ¬¡æ“ä½œï¼‰</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // é¢œè‰²æå–ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = extractRedColor(img);
    
    // å½¢æ€å­¦æ ¸
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // é—­è¿ç®—ï¼ˆæœ€å¸¸ç”¨ï¼‰
    cv::Mat result;
    cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
    
    // æ˜¾ç¤ºå¯¹æ¯”
    cv::imshow("åŸå§‹äºŒå€¼å›¾", binary);
    cv::imshow("å½¢æ€å­¦å¤„ç†å", result);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>æ–¹æ¡ˆ2: æ ‡å‡†ç‰ˆï¼ˆä¸¤æ­¥æ³•ï¼‰</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat morphologyProcess(const cv::Mat&amp; binary) {
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // ç¬¬ä¸€æ­¥ï¼šé—­è¿ç®—å¡«ç¼
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // ç¬¬äºŒæ­¥ï¼šå¼€è¿ç®—å»å™ª
    cv::Mat opened;
    cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
    
    return opened;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat binary = extractColor(img);
    
    cv::Mat result = morphologyProcess(binary);
    
    // æ˜¾ç¤ºä¸‰æ­¥å¯¹æ¯”
    cv::imshow("1-åŸå§‹", binary);
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, 
                     cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5)));
    cv::imshow("2-é—­è¿ç®—", closed);
    cv::imshow("3-æœ€ç»ˆç»“æœ", result);
    
    cv::waitKey(0);
    return 0;
}
</code></pre>
<h3>æ–¹æ¡ˆ3: è‡ªé€‚åº”ç‰ˆï¼ˆæ ¹æ®å›¾åƒå¤§å°è°ƒæ•´æ ¸ï¼‰</h3>
<pre><code>cv::Mat adaptiveMorphology(const cv::Mat&amp; binary) {
    // æ ¹æ®å›¾åƒå¤§å°è‡ªé€‚åº”æ ¸å°ºå¯¸
    int kernelSize = std::max(3, (int)(binary.cols * 0.005));
    if (kernelSize % 2 == 0) kernelSize++;  // ç¡®ä¿æ˜¯å¥‡æ•°
    
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                               cv::Size(kernelSize, kernelSize));
    
    cv::Mat closed, result;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    std::cout &lt;&lt; "ä½¿ç”¨æ ¸å°ºå¯¸: " &lt;&lt; kernelSize &lt;&lt; "Ã—" &lt;&lt; kernelSize &lt;&lt; std::endl;
    return result;
}
</code></pre>
<hr />
<h2>å¸¸è§é—®é¢˜æ’æŸ¥</h2>
<h3>é—®é¢˜1: å¤„ç†åç¯æ¡æ¶ˆå¤±äº†</h3>
<pre><code>// åŸå› ï¼šæ ¸å¤ªå¤§ï¼ŒæŠŠç¯æ¡ä¹Ÿè…èš€æ‰äº†
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));

// è§£å†³ï¼šå‡å°æ ¸å°ºå¯¸
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
</code></pre>
<h3>é—®é¢˜2: ä¸¤ä¸ªç¯æ¡ç²˜åœ¨ä¸€èµ·äº†</h3>
<pre><code>// åŸå› ï¼šé—­è¿ç®—è†¨èƒ€å¤ªå¼º
// è§£å†³1ï¼šå‡å°æ ¸å°ºå¯¸
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è§£å†³2ï¼šå‡å°‘è¿­ä»£æ¬¡æ•°
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel, cv::Point(-1,-1), 1);

// è§£å†³3ï¼šä¸ç”¨é—­è¿ç®—ï¼Œåªç”¨è½»å¾®è†¨èƒ€
cv::dilate(binary, result, kernel, cv::Point(-1,-1), 1);
</code></pre>
<h3>é—®é¢˜3: å™ªç‚¹è¿˜æ˜¯å¾ˆå¤š</h3>
<pre><code>// åŸå› ï¼šæ ¸å¤ªå°
cv::Mat kernel_small = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è§£å†³ï¼šå¢å¤§æ ¸æˆ–å¢åŠ è¿­ä»£æ¬¡æ•°
cv::Mat kernel_big = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(7, 7));
// æˆ–è€…
cv::morphologyEx(binary, result, cv::MORPH_OPEN, kernel, cv::Point(-1,-1), 2);
</code></pre>
<h3>é—®é¢˜4: ä¸çŸ¥é“ç”¨å“ªä¸ªæ“ä½œ</h3>
<pre><code>// å†³ç­–æ ‘ï¼š
if (ç¯æ¡æœ‰æ–­è£‚/ç¼éš™) {
    ä½¿ç”¨é—­è¿ç®— MORPH_CLOSE
}
if (æœ‰å¾ˆå¤šå°å™ªç‚¹) {
    ä½¿ç”¨å¼€è¿ç®— MORPH_OPEN
}
if (æ—¢æœ‰æ–­è£‚åˆæœ‰å™ªç‚¹) {
    å…ˆé—­è¿ç®—ï¼Œå†å¼€è¿ç®—  // â† RMæ ‡å‡†æµç¨‹
}
</code></pre>
<hr />
<h2>è°ƒè¯•æŠ€å·§</h2>
<h3>æŠ€å·§1: å¯è§†åŒ–æ¯ä¸€æ­¥</h3>
<pre><code>cv::Mat binary = extractColor(img);

cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// ä¿å­˜æ¯ä¸€æ­¥
cv::imshow("1-åŸå§‹", binary);

cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
cv::imshow("2-é—­è¿ç®—", closed);

cv::Mat opened;
cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
cv::imshow("3-å¼€è¿ç®—", opened);

cv::waitKey(0);
</code></pre>
<h3>æŠ€å·§2: åˆ›å»ºæ»‘å—è°ƒå‚</h3>
<pre><code>int kernelSize = 5;

void on_trackbar(int, void*) {}

int main() {
    cv::namedWindow("è°ƒå‚");
    cv::createTrackbar("æ ¸å°ºå¯¸", "è°ƒå‚", &amp;kernelSize, 15, on_trackbar);
    
    while (true) {
        if (kernelSize % 2 == 0) kernelSize++;  // ç¡®ä¿å¥‡æ•°
        if (kernelSize &lt; 3) kernelSize = 3;
        
        cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                                   cv::Size(kernelSize, kernelSize));
        
        cv::Mat result;
        cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
        
        cv::imshow("ç»“æœ", result);
        if (cv::waitKey(30) == 27) break;
    }
    
    return 0;
}
</code></pre>
<hr />
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RMè£…ç”²æ¿è¯†åˆ« - 02 è£…ç”²æ¿é¢œè‰²æå–</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_02/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_02/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>æ— </summary>
    <content type="html"><![CDATA[<h2>æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>ä½œç”¨</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::split()</code></td>
<td>åˆ†ç¦»BGRé€šé“</td>
</tr>
<tr>
<td><code>cv::cvtColor()</code></td>
<td>é¢œè‰²ç©ºé—´è½¬æ¢</td>
</tr>
<tr>
<td><code>cv::inRange()</code></td>
<td>é¢œè‰²èŒƒå›´ç­›é€‰</td>
</tr>
<tr>
<td><code>cv::threshold()</code></td>
<td>ç®€å•é˜ˆå€¼äºŒå€¼åŒ–</td>
</tr>
<tr>
<td><code>cv::subtract()</code></td>
<td>é€šé“ç›¸å‡</td>
</tr>
<tr>
<td><code>cv::bitwise_or/and()</code></td>
<td>ä½è¿ç®—ç»„åˆmask</td>
</tr>
</tbody>
</table>
<hr />
<h2>æ ¸å¿ƒæ€è·¯</h2>
<p>è£…ç”²æ¿çš„ç¯æ¡æœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š</p>
<ol>
<li><strong>ç‰¹å®šé¢œè‰²</strong>ï¼ˆçº¢è‰²æˆ–è“è‰²ï¼‰</li>
<li><strong>é«˜äº®åº¦</strong>ï¼ˆç¯æ¡æ˜¯å‘å…‰çš„ï¼‰</li>
</ol>
<p>RMè§†è§‰ä¸­æœ‰<strong>ä¸¤æ¡ä¸»æµè·¯çº¿</strong>ï¼š</p>
<h3>è·¯çº¿1: é€šé“ç›¸å‡æ³•</h3>
<ul>
<li><strong>åŸç†</strong>: BGRå›¾åƒä¸­ï¼Œçº¢è‰²åŒºåŸŸRé€šé“å€¼é«˜ã€Bé€šé“å€¼ä½ï¼Œç›¸å‡åçº¢è‰²å‡¸æ˜¾</li>
<li><strong>ä¼˜ç‚¹</strong>: é€Ÿåº¦æå¿«ï¼ˆ1-2msï¼‰ï¼Œå®æ—¶æ€§å¥½</li>
<li><strong>ç¼ºç‚¹</strong>: æ˜“å—ç¯å¢ƒå…‰å¹²æ‰°ï¼Œéœ€è¦åç»­å¼ºç­›é€‰</li>
<li><strong>é€‚ç”¨</strong>: æ¯”èµ›å®æˆ˜ã€å…‰ç…§ç¨³å®šç¯å¢ƒ</li>
</ul>
<h3>è·¯çº¿2: HSVç­›é€‰æ³•</h3>
<ul>
<li><strong>åŸç†</strong>: HSVåˆ†ç¦»äº†é¢œè‰²å’Œäº®åº¦ï¼Œå¯ç²¾ç¡®ç­›é€‰é¢œè‰²èŒƒå›´</li>
<li><strong>ä¼˜ç‚¹</strong>: æŠ—å¹²æ‰°èƒ½åŠ›å¼ºï¼Œå‡†ç¡®åº¦é«˜</li>
<li><strong>ç¼ºç‚¹</strong>: é€Ÿåº¦è¾ƒæ…¢ï¼ˆ5-10msï¼‰ï¼Œå‚æ•°éœ€è°ƒä¼˜</li>
<li><strong>é€‚ç”¨</strong>: å¤æ‚å…‰ç…§ã€é«˜ç²¾åº¦éœ€æ±‚</li>
</ul>
<hr />
<h2>1. cv::split() - åˆ†ç¦»BGRé€šé“</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::split(const Mat&amp; src, Mat* mvbegin);
void cv::split(InputArray src, OutputArrayOfArrays mvs);
</code></pre>
<h3>æ ¸å¿ƒæ¦‚å¿µ</h3>
<p>OpenCVçš„å½©è‰²å›¾æ˜¯<strong>BGRä¸‰é€šé“</strong>ï¼ˆä¸æ˜¯RGBï¼ï¼‰ï¼š</p>
<ul>
<li><strong>Bé€šé“ (channels[0])</strong>: è“è‰²åˆ†é‡ (0-255)</li>
<li><strong>Gé€šé“ (channels[1])</strong>: ç»¿è‰²åˆ†é‡ (0-255)</li>
<li><strong>Ré€šé“ (channels[2])</strong>: çº¢è‰²åˆ†é‡ (0-255)</li>
</ul>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // åˆ†ç¦»é€šé“
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);
    
    // ç°åœ¨ï¼š
    // channels[0] = Bé€šé“ï¼ˆè“è‰²åˆ†é‡ï¼‰
    // channels[1] = Gé€šé“ï¼ˆç»¿è‰²åˆ†é‡ï¼‰
    // channels[2] = Ré€šé“ï¼ˆçº¢è‰²åˆ†é‡ï¼‰
    
    // å¯è§†åŒ–å„é€šé“
    cv::imshow("Bé€šé“", channels[0]);
    cv::imshow("Gé€šé“", channels[1]);
    cv::imshow("Ré€šé“", channels[2]);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>é€šé“å«ä¹‰ç†è§£</h3>
<p>å‡è®¾æœ‰ä¸€ä¸ªåƒç´ çš„BGRå€¼æ˜¯ <code>(50, 100, 200)</code>ï¼š</p>
<pre><code>cv::Vec3b pixel(50, 100, 200);  // (B, G, R)
// B=50:  è“è‰²åˆ†é‡å¾ˆä½
// G=100: ç»¿è‰²åˆ†é‡ä¸­ç­‰
// R=200: çº¢è‰²åˆ†é‡å¾ˆé«˜
// æ‰€ä»¥è¿™ä¸ªåƒç´ æ˜¯ï¼šçº¢è‰²åå¤šçš„æ©™çº¢è‰²
</code></pre>
<p><strong>è§‚å¯Ÿè§„å¾‹</strong>ï¼š</p>
<ul>
<li>çº¢è‰²ç¯æ¡ï¼šRé€šé“å¾ˆäº®ï¼ŒBé€šé“å¾ˆæš—</li>
<li>è“è‰²ç¯æ¡ï¼šBé€šé“å¾ˆäº®ï¼ŒRé€šé“å¾ˆæš—</li>
</ul>
<hr />
<h2>2. é€šé“ç›¸å‡æ³•ï¼ˆRMç»å…¸ï¼‰</h2>
<h3>æå–çº¢è‰²</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");

// åˆ†ç¦»é€šé“
std::vector&lt;cv::Mat&gt; channels;
cv::split(img, channels);

// çº¢è‰² = Ré€šé“ - Bé€šé“
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// äºŒå€¼åŒ–
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);

// æŸ¥çœ‹æ•ˆæœ
cv::imshow("åŸå›¾", img);
cv::imshow("Ré€šé“", channels[2]);
cv::imshow("Bé€šé“", channels[0]);
cv::imshow("ç›¸å‡ç»“æœ", red);
cv::imshow("äºŒå€¼åŒ–", binary);
cv::waitKey(0);
</code></pre>
<h3>æå–è“è‰²</h3>
<pre><code>// è“è‰² = Bé€šé“ - Ré€šé“
cv::Mat blue;
cv::subtract(channels[0], channels[2], blue);

cv::Mat binary_blue;
cv::threshold(blue, binary_blue, 100, 255, cv::THRESH_BINARY);
</code></pre>
<h3>ä¸ºä»€ä¹ˆé€šé“ç›¸å‡æœ‰æ•ˆï¼Ÿ</h3>
<p><strong>åŸç†åˆ†æ</strong>ï¼š</p>
<table>
<thead>
<tr>
<th>åŒºåŸŸç±»å‹</th>
<th>Rå€¼</th>
<th>Bå€¼</th>
<th>R-Bç»“æœ</th>
</tr>
</thead>
<tbody>
<tr>
<td>çº¢è‰²ç¯æ¡</td>
<td>250</td>
<td>50</td>
<td><strong>200</strong> (å¾ˆäº®)</td>
</tr>
<tr>
<td>è“è‰²ç¯æ¡</td>
<td>50</td>
<td>250</td>
<td>0 (é¥±å’Œåˆ°0)</td>
</tr>
<tr>
<td>ç™½è‰²åŒºåŸŸ</td>
<td>200</td>
<td>200</td>
<td>0 (ç›¸äº’æŠµæ¶ˆ)</td>
</tr>
<tr>
<td>é»‘è‰²åŒºåŸŸ</td>
<td>20</td>
<td>20</td>
<td>0 (éƒ½å¾ˆæš—)</td>
</tr>
</tbody>
</table>
<p>é€šé“ç›¸å‡åï¼Œ<strong>åªæœ‰çº¢è‰²ç¯æ¡ä¼šä¿ç•™é«˜äº®å€¼</strong>ï¼</p>
<h3>é€šé“ç›¸å‡çš„å±€é™æ€§</h3>
<pre><code>// é—®é¢˜1: ç¯å¢ƒä¸­çš„çº¢è‰²ç‰©ä½“ä¹Ÿä¼šè¢«æå–
// æ¯”å¦‚ï¼šçº¢è‰²è¡£æœã€çº¢è‰²æµ·æŠ¥ã€çº¢è‰²ç¯å…‰

// é—®é¢˜2: å…‰ç…§ä¸å‡ä¼šå¯¼è‡´æ¼æ£€
// æš—å¤„çš„çº¢è‰²ç¯æ¡å¯èƒ½ R-B &lt; é˜ˆå€¼

// è§£å†³æ–¹æ¡ˆï¼šéœ€è¦åç»­ç”¨å½¢æ€å­¦+è½®å»“ç­›é€‰æ¥è¿‡æ»¤
</code></pre>
<hr />
<h2>3. cv::cvtColor() - é¢œè‰²ç©ºé—´è½¬æ¢</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::cvtColor(InputArray src, OutputArray dst, int code);
</code></pre>
<h3>å¸¸ç”¨è½¬æ¢ä»£ç </h3>
<table>
<thead>
<tr>
<th>code</th>
<th>è¯´æ˜</th>
<th>ç”¨é€”</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLOR_BGR2GRAY</code></td>
<td>BGRè½¬ç°åº¦</td>
<td>ç®€åŒ–å›¾åƒå¤„ç†</td>
</tr>
<tr>
<td><code>COLOR_BGR2HSV</code></td>
<td>BGRè½¬HSV</td>
<td><strong>è£…ç”²æ¿è¯†åˆ«æ ¸å¿ƒ</strong></td>
</tr>
<tr>
<td><code>COLOR_BGR2RGB</code></td>
<td>BGRè½¬RGB</td>
<td>ä¸å…¶ä»–åº“å¯¹æ¥</td>
</tr>
<tr>
<td><code>COLOR_HSV2BGR</code></td>
<td>HSVè½¬å›BGR</td>
<td>è°ƒè¯•å¯è§†åŒ–</td>
</tr>
</tbody>
</table>
<h3>HSVé¢œè‰²ç©ºé—´è¯¦è§£</h3>
<p>HSVæŠŠé¢œè‰²åˆ†è§£ä¸º3ä¸ªç»´åº¦ï¼š</p>
<pre><code>H (è‰²è°ƒ Hue): 0-180
â”œâ”€ 0-10:    çº¢è‰²(ç¬¬ä¸€æ®µ)
â”œâ”€ 11-25:   æ©™è‰²
â”œâ”€ 26-34:   é»„è‰²
â”œâ”€ 35-77:   ç»¿è‰²
â”œâ”€ 78-99:   é’è‰²
â”œâ”€ 100-124: è“è‰²  è£…ç”²æ¿è“è‰²
â”œâ”€ 125-155: ç´«è‰²
â””â”€ 170-180: çº¢è‰²(ç¬¬äºŒæ®µ) è£…ç”²æ¿çº¢è‰²

S (é¥±å’Œåº¦ Saturation): 0-255
â”œâ”€ 0-50:   ç°ç™½è‰²ï¼ˆé¢œè‰²ä¸çº¯ï¼‰
â”œâ”€ 50-100: æ·¡è‰²
â””â”€ 100-255: é²œè‰³è‰² ç¯æ¡åœ¨è¿™é‡Œ

V (æ˜åº¦ Value): 0-255
â”œâ”€ 0-50:   é»‘æš—
â”œâ”€ 50-100: æš—æ·¡
â””â”€ 100-255: æ˜äº® ç¯æ¡åœ¨è¿™é‡Œ
</code></pre>
<h3>BGRè½¬HSV</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// æŸ¥çœ‹HSVå„é€šé“
std::vector&lt;cv::Mat&gt; hsv_channels;
cv::split(hsv, hsv_channels);

cv::imshow("Hé€šé“(è‰²è°ƒ)", hsv_channels[0]);
cv::imshow("Sé€šé“(é¥±å’Œåº¦)", hsv_channels[1]);
cv::imshow("Vé€šé“(æ˜åº¦)", hsv_channels[2]);
cv::waitKey(0);
</code></pre>
<h3>ä¸ºä»€ä¹ˆHSVæ›´é€‚åˆé¢œè‰²è¯†åˆ«ï¼Ÿ</h3>
<p><strong>BGRçš„é—®é¢˜</strong>ï¼š</p>
<pre><code>// äº®çº¢è‰² vs æš—çº¢è‰²ï¼ŒBGRå€¼å·®å¼‚å¤§
äº®çº¢è‰²: (0, 0, 255)
æš—çº¢è‰²: (0, 0, 100)
// ç”¨BGRå¾ˆéš¾ç”¨ä¸€ä¸ªèŒƒå›´åŒæ—¶åŒ…å«å®ƒä»¬

// ä½†åœ¨HSVä¸­ï¼š
äº®çº¢è‰²: (0, 255, 255)  // H=0, S=255, V=255
æš—çº¢è‰²: (0, 255, 100)  // H=0, S=255, V=100
// Hå’ŒSç›¸åŒï¼åªæ˜¯Vä¸åŒï¼Œå¯ä»¥ç”¨ H in [0,10] ç»Ÿä¸€è¯†åˆ«
</code></pre>
<hr />
<h2>4. cv::inRange() - é¢œè‰²èŒƒå›´ç­›é€‰</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::inRange(InputArray src, InputArray lowerb, 
                 InputArray upperb, OutputArray dst);
</code></pre>
<h3>å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src</code></td>
<td>è¾“å…¥å›¾åƒï¼ˆé€šå¸¸æ˜¯HSVï¼‰</td>
</tr>
<tr>
<td><code>lowerb</code></td>
<td>ä¸‹ç•Œï¼ˆScalar(H_min, S_min, V_min)ï¼‰</td>
</tr>
<tr>
<td><code>upperb</code></td>
<td>ä¸Šç•Œï¼ˆScalar(H_max, S_max, V_max)ï¼‰</td>
</tr>
<tr>
<td><code>dst</code></td>
<td>è¾“å‡ºäºŒå€¼å›¾ï¼ˆåœ¨èŒƒå›´å†…=255ï¼Œå¦åˆ™=0ï¼‰</td>
</tr>
</tbody>
</table>
<h3>æå–çº¢è‰²ï¼ˆå®Œæ•´ç‰ˆï¼‰</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// çº¢è‰²çš„Hå€¼è·¨è¶Šäº†0-180çš„è¾¹ç•Œï¼éœ€è¦åˆ†ä¸¤æ®µ
// ç¬¬ä¸€æ®µ: H=0-10
cv::Scalar lower_red1(0, 100, 100);    // (H, S, V)
cv::Scalar upper_red1(10, 255, 255);

// ç¬¬äºŒæ®µ: H=170-180
cv::Scalar lower_red2(170, 100, 100);
cv::Scalar upper_red2(180, 255, 255);

// åˆ†åˆ«æå–ä¸¤æ®µ
cv::Mat mask1, mask2, red_mask;
cv::inRange(hsv, lower_red1, upper_red1, mask1);
cv::inRange(hsv, lower_red2, upper_red2, mask2);

// åˆå¹¶ä¸¤æ®µï¼ˆä½è¿ç®—ï¼šæˆ–ï¼‰
cv::bitwise_or(mask1, mask2, red_mask);

// æŸ¥çœ‹æ•ˆæœ
cv::imshow("åŸå›¾", img);
cv::imshow("mask1 (H=0-10)", mask1);
cv::imshow("mask2 (H=170-180)", mask2);
cv::imshow("æœ€ç»ˆçº¢è‰²mask", red_mask);
cv::waitKey(0);
</code></pre>
<h3>æå–è“è‰²</h3>
<pre><code>// è“è‰²åªéœ€è¦ä¸€æ®µ
cv::Scalar lower_blue(100, 100, 100);  // H=100-130
cv::Scalar upper_blue(130, 255, 255);

cv::Mat blue_mask;
cv::inRange(hsv, lower_blue, upper_blue, blue_mask);
</code></pre>
<h3>å‚æ•°è°ƒä¼˜æŠ€å·§</h3>
<p><strong>åˆ›å»ºæ»‘å—å®æ—¶è°ƒå‚</strong>ï¼š</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

// å…¨å±€å˜é‡
int h_min = 0, h_max = 10;
int s_min = 100, s_max = 255;
int v_min = 100, v_max = 255;

void on_trackbar(int, void*) {
    // å›è°ƒå‡½æ•°ï¼Œæ¯æ¬¡æ»‘å—å˜åŒ–æ—¶è°ƒç”¨
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // åˆ›å»ºçª—å£
    cv::namedWindow("è°ƒå‚");
    
    // åˆ›å»ºæ»‘å—
    cv::createTrackbar("H min", "è°ƒå‚", &amp;h_min, 180, on_trackbar);
    cv::createTrackbar("H max", "è°ƒå‚", &amp;h_max, 180, on_trackbar);
    cv::createTrackbar("S min", "è°ƒå‚", &amp;s_min, 255, on_trackbar);
    cv::createTrackbar("S max", "è°ƒå‚", &amp;s_max, 255, on_trackbar);
    cv::createTrackbar("V min", "è°ƒå‚", &amp;v_min, 255, on_trackbar);
    cv::createTrackbar("V max", "è°ƒå‚", &amp;v_max, 255, on_trackbar);
    
    while (true) {
        cv::Scalar lower(h_min, s_min, v_min);
        cv::Scalar upper(h_max, s_max, v_max);
        
        cv::Mat mask;
        cv::inRange(hsv, lower, upper, mask);
        
        cv::imshow("åŸå›¾", img);
        cv::imshow("mask", mask);
        
        if (cv::waitKey(30) == 27) break;
    }
    
    // æ‰“å°æœ€ç»ˆå‚æ•°
    std::cout &lt;&lt; "æœ€ä¼˜å‚æ•°:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "lower: (" &lt;&lt; h_min &lt;&lt; ", " &lt;&lt; s_min &lt;&lt; ", " &lt;&lt; v_min &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "upper: (" &lt;&lt; h_max &lt;&lt; ", " &lt;&lt; s_max &lt;&lt; ", " &lt;&lt; v_max &lt;&lt; ")" &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<h3>æ¨èå‚æ•°èŒƒå›´</h3>
<table>
<thead>
<tr>
<th>é¢œè‰²</th>
<th>HèŒƒå›´</th>
<th>SèŒƒå›´</th>
<th>VèŒƒå›´</th>
<th>å¤‡æ³¨</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>çº¢è‰²</strong></td>
<td>0-10, 170-180</td>
<td>100-255</td>
<td>100-255</td>
<td>ä¸¤æ®µåˆå¹¶</td>
</tr>
<tr>
<td><strong>è“è‰²</strong></td>
<td>100-130</td>
<td>100-255</td>
<td>100-255</td>
<td>å•æ®µå³å¯</td>
</tr>
<tr>
<td>ç™½è‰²</td>
<td>ä»»æ„</td>
<td>0-30</td>
<td>200-255</td>
<td>ä½é¥±å’Œåº¦+é«˜äº®åº¦</td>
</tr>
<tr>
<td>é»‘è‰²</td>
<td>ä»»æ„</td>
<td>ä»»æ„</td>
<td>0-50</td>
<td>åªçœ‹äº®åº¦</td>
</tr>
</tbody>
</table>
<p><strong>è¿™äº›å‚æ•°ä¸æ˜¯å›ºå®šçš„ï¼</strong> éœ€è¦æ ¹æ®ï¼š</p>
<ul>
<li>ç›¸æœºå‹å·</li>
<li>å…‰ç…§æ¡ä»¶</li>
<li>ç¯æ¡äº®åº¦
å®é™…è°ƒæ•´ï¼</li>
</ul>
<hr />
<h2>5. cv::threshold() - ç®€å•é˜ˆå€¼äºŒå€¼åŒ–</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>double cv::threshold(InputArray src, OutputArray dst, 
                     double thresh, double maxval, int type);
</code></pre>
<h3>å¸¸ç”¨ç±»å‹</h3>
<table>
<thead>
<tr>
<th>type</th>
<th>è¯´æ˜</th>
<th>å…¬å¼</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>THRESH_BINARY</code></td>
<td>æ ‡å‡†äºŒå€¼åŒ–</td>
<td><code>pixel &gt; thresh ? maxval : 0</code></td>
</tr>
<tr>
<td><code>THRESH_BINARY_INV</code></td>
<td>åå‘äºŒå€¼åŒ–</td>
<td><code>pixel &gt; thresh ? 0 : maxval</code></td>
</tr>
<tr>
<td><code>THRESH_TRUNC</code></td>
<td>æˆªæ–­</td>
<td><code>pixel &gt; thresh ? thresh : pixel</code></td>
</tr>
<tr>
<td><code>THRESH_TOZERO</code></td>
<td>ä½äºé˜ˆå€¼å½’é›¶</td>
<td><code>pixel &gt; thresh ? pixel : 0</code></td>
</tr>
</tbody>
</table>
<h3>é…åˆé€šé“ç›¸å‡ä½¿ç”¨</h3>
<pre><code>// æå–çº¢è‰²
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// é˜ˆå€¼äºŒå€¼åŒ–
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// åƒç´  &gt; 100 â†’ 255(ç™½)
// åƒç´  &lt;= 100 â†’ 0(é»‘)
</code></pre>
<h3>ğŸ’» è‡ªé€‚åº”é˜ˆå€¼ï¼ˆåº”å¯¹å…‰ç…§ä¸å‡ï¼‰</h3>
<pre><code>cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

cv::Mat adaptive;
cv::adaptiveThreshold(gray, adaptive, 255,
                      cv::ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv::THRESH_BINARY, 11, 2);
// blockSize=11: é‚»åŸŸå¤§å°
// C=2: å¸¸æ•°è°ƒæ•´å€¼
</code></pre>
<hr />
<h2>6. cv::bitwise ä½è¿ç®—</h2>
<h3>å¸¸ç”¨å‡½æ•°</h3>
<pre><code>void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_not(InputArray src, OutputArray dst);
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst);
</code></pre>
<h3>åˆå¹¶å¤šä¸ªmask</h3>
<pre><code>// çº¢è‰²æœ‰ä¸¤æ®µï¼Œéœ€è¦åˆå¹¶
cv::Mat red_mask1, red_mask2, red_final;
cv::inRange(hsv, lower_red1, upper_red1, red_mask1);
cv::inRange(hsv, lower_red2, upper_red2, red_mask2);
cv::bitwise_or(red_mask1, red_mask2, red_final);
</code></pre>
<h3>æå–åŒæ—¶æ»¡è¶³å¤šä¸ªæ¡ä»¶çš„åŒºåŸŸ</h3>
<pre><code>// åŒæ—¶æ˜¯çº¢è‰² ä¸” äº®åº¦å¾ˆé«˜
cv::Mat color_mask, brightness_mask, final_mask;
cv::inRange(hsv, lower_red, upper_red, color_mask);
cv::threshold(hsv_channels[2], brightness_mask, 200, 255, cv::THRESH_BINARY);
cv::bitwise_and(color_mask, brightness_mask, final_mask);
</code></pre>
<h3>åè½¬mask</h3>
<pre><code>cv::Mat mask, inverted;
cv::inRange(hsv, lower, upper, mask);
cv::bitwise_not(mask, inverted);  // é»‘ç™½åè½¬
</code></pre>
<hr />
<h2>å®Œæ•´å®æˆ˜ä»£ç </h2>
<h3>æ–¹æ¡ˆ1: é€šé“ç›¸å‡æ³•ï¼ˆå¿«é€Ÿï¼‰</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedFast(const cv::Mat&amp; img) {
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);
    
    // R - B
    cv::Mat red;
    cv::subtract(channels[2], channels[0], red);
    
    // äºŒå€¼åŒ–
    cv::Mat binary;
    cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
    
    return binary;
}

int main() {
    cv::Mat img = cv::imread("red_armor.jpg");
    cv::Mat binary = extractRedFast(img);
    
    cv::imshow("åŸå›¾", img);
    cv::imshow("çº¢è‰²æå–", binary);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>æ–¹æ¡ˆ2: HSVç­›é€‰æ³•ï¼ˆç²¾ç¡®ï¼‰</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedAccurate(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // çº¢è‰²ä¸¤æ®µ
    cv::Scalar lower1(0, 100, 100);
    cv::Scalar upper1(10, 255, 255);
    cv::Scalar lower2(170, 100, 100);
    cv::Scalar upper2(180, 255, 255);
    
    cv::Mat mask1, mask2, mask;
    cv::inRange(hsv, lower1, upper1, mask1);
    cv::inRange(hsv, lower2, upper2, mask2);
    cv::bitwise_or(mask1, mask2, mask);
    
    return mask;
}

cv::Mat extractBlue(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    cv::Scalar lower(100, 100, 100);
    cv::Scalar upper(130, 255, 255);
    
    cv::Mat mask;
    cv::inRange(hsv, lower, upper, mask);
    
    return mask;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    cv::Mat red_mask = extractRedAccurate(img);
    cv::Mat blue_mask = extractBlue(img);
    
    cv::imshow("åŸå›¾", img);
    cv::imshow("çº¢è‰²mask", red_mask);
    cv::imshow("è“è‰²mask", blue_mask);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>å¸¸è§é—®é¢˜æ’æŸ¥</h2>
<h3>é—®é¢˜1: æå–ä¸å‡ºé¢œè‰²</h3>
<pre><code>// æ£€æŸ¥æ¸…å•ï¼š
// 1. ç¡®è®¤å›¾åƒä¸æ˜¯ç©ºçš„
if (img.empty()) return;

// 2. æ‰“å°HSVå€¼çœ‹çœ‹èŒƒå›´å¯¹ä¸å¯¹
cv::Vec3b pixel = hsv.at&lt;cv::Vec3b&gt;(y, x);  // ç‚¹å‡»ç¯æ¡ä½ç½®
std::cout &lt;&lt; "H=" &lt;&lt; (int)pixel[0] 
          &lt;&lt; " S=" &lt;&lt; (int)pixel[1] 
          &lt;&lt; " V=" &lt;&lt; (int)pixel[2] &lt;&lt; std::endl;

// 3. ç”¨æ»‘å—è°ƒå‚
</code></pre>
<h3>é—®é¢˜2: æå–å‡ºå¤ªå¤šæ‚è‰²</h3>
<pre><code>// è§£å†³æ–¹æ¡ˆï¼š
// 1. æé«˜Så’ŒVçš„ä¸‹é™ï¼ˆåªè¦é²œè‰³+æ˜äº®çš„ï¼‰
cv::Scalar lower(0, 150, 150);  // æé«˜S_minå’ŒV_min

// 2. åç»­ç”¨å½¢æ€å­¦é™å™ª
// 3. è½®å»“ç­›é€‰æ—¶è¿‡æ»¤å°é¢ç§¯
</code></pre>
<h3>é—®é¢˜3: çº¢è‰²åªæ£€æµ‹åˆ°ä¸€åŠ</h3>
<pre><code>// åŸå› ï¼šå¿˜è®°åˆå¹¶çº¢è‰²çš„ä¸¤æ®µ
// è§£å†³ï¼š
cv::bitwise_or(mask1, mask2, final_mask);
</code></pre>
<hr />
<h2>æ£€æŸ¥æ¸…å•</h2>
<p>å®Œæˆæœ¬é˜¶æ®µåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š</p>
<ul>
<li>[ ] ç†è§£BGRå’ŒHSVçš„åŒºåˆ«</li>
<li>[ ] ç”¨ <code>cv::split()</code> åˆ†ç¦»é€šé“å¹¶è®¡ç®— R-B</li>
<li>[ ] ç”¨ <code>cv::inRange()</code> æå–çº¢è‰²/è“è‰²</li>
<li>[ ] çŸ¥é“çº¢è‰²éœ€è¦ä¸¤æ®µèŒƒå›´åˆå¹¶</li>
<li>[ ] èƒ½ç”¨æ»‘å—è°ƒè¯•HSVå‚æ•°</li>
<li>[ ] ç†è§£é€šé“ç›¸å‡æ³•å’ŒHSVæ³•çš„ä¼˜åŠ£</li>
</ul>
<hr />
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RMè£…ç”²æ¿è¯†åˆ« - 04 è½®å»“æ£€æµ‹</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_04/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_04/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>æ— </summary>
    <content type="html"><![CDATA[<h2>ğŸ“š æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>ä½œç”¨</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::findContours()</code></td>
<td>æŸ¥æ‰¾è½®å»“</td>
</tr>
<tr>
<td><code>cv::contourArea()</code></td>
<td>è®¡ç®—è½®å»“é¢ç§¯</td>
</tr>
<tr>
<td><code>cv::minAreaRect()</code></td>
<td>æœ€å°æ—‹è½¬çŸ©å½¢</td>
</tr>
<tr>
<td><code>cv::RotatedRect</code></td>
<td>æ—‹è½¬çŸ©å½¢ç±»</td>
</tr>
<tr>
<td><code>cv::drawContours()</code></td>
<td>ç»˜åˆ¶è½®å»“</td>
</tr>
<tr>
<td><code>cv::boundingRect()</code></td>
<td>æ­£çŸ©å½¢åŒ…å›´æ¡†</td>
</tr>
<tr>
<td><code>cv::fitEllipse()</code></td>
<td>æ¤­åœ†æ‹Ÿåˆ</td>
</tr>
</tbody>
</table>
<hr />
<h2>æ ¸å¿ƒæ€è·¯</h2>
<ul>
<li>
<p>ç»è¿‡å½¢æ€å­¦å¤„ç†åï¼ŒäºŒå€¼å›¾å·²ç»å¾ˆå¹²å‡€ï¼š</p>
</li>
<li>
<p>ç°åœ¨è¦åšçš„æ˜¯ï¼š</p>
</li>
</ul>
<ol>
<li><strong>æ‰¾è½®å»“</strong> - æŠŠæ¯ä¸ªç™½è‰²åŒºåŸŸçš„è¾¹ç•Œæ‰¾å‡ºæ¥</li>
<li><strong>æ‹ŸåˆçŸ©å½¢</strong> - ç”¨æ—‹è½¬çŸ©å½¢æè¿°æ¯ä¸ªè½®å»“</li>
<li><strong>ç­›é€‰ç¯æ¡</strong> - æ ¹æ®é•¿å®½æ¯”ã€é¢ç§¯ã€è§’åº¦ç­‰ç‰¹å¾è¿‡æ»¤</li>
</ol>
<hr />
<h2>1. cv::findContours() - æŸ¥æ‰¾è½®å»“</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::findContours(InputOutputArray image, 
                      OutputArrayOfArrays contours,
                      int mode, int method, 
                      Point offset = Point());
</code></pre>
<h3>å‚æ•°è¯¦è§£</h3>
<h4>mode - è½®å»“æ£€ç´¢æ¨¡å¼</h4>
<table>
<thead>
<tr>
<th>mode</th>
<th>è¯´æ˜</th>
<th>ç”¨é€”</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RETR_EXTERNAL</code></td>
<td>åªæ£€æµ‹æœ€å¤–å±‚è½®å»“</td>
<td><strong>RMæ¨è</strong>ï¼Œå¿½ç•¥å†…éƒ¨å­”æ´</td>
</tr>
<tr>
<td><code>RETR_LIST</code></td>
<td>æ£€æµ‹æ‰€æœ‰è½®å»“ï¼Œä¸å»ºç«‹å±‚çº§</td>
<td>å½“éœ€è¦æ‰€æœ‰è½®å»“æ—¶</td>
</tr>
<tr>
<td><code>RETR_TREE</code></td>
<td>æ£€æµ‹æ‰€æœ‰å¹¶å»ºç«‹å®Œæ•´å±‚çº§æ ‘</td>
<td>å¤æ‚åµŒå¥—ç»“æ„</td>
</tr>
<tr>
<td><code>RETR_CCOMP</code></td>
<td>ä¸¤å±‚å±‚çº§ï¼ˆå¤–è½®å»“å’Œå­”ï¼‰</td>
<td>è¾ƒå°‘ä½¿ç”¨</td>
</tr>
</tbody>
</table>
<h4>method - è½®å»“è¿‘ä¼¼æ–¹æ³•</h4>
<table>
<thead>
<tr>
<th>method</th>
<th>è¯´æ˜</th>
<th>ä¼˜ç¼ºç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CHAIN_APPROX_NONE</code></td>
<td>ä¿å­˜æ‰€æœ‰è½®å»“ç‚¹</td>
<td>ç²¾ç¡®ä½†å å†…å­˜</td>
</tr>
<tr>
<td><code>CHAIN_APPROX_SIMPLE</code></td>
<td>å‹ç¼©è½®å»“ï¼Œåªä¿ç•™å…³é”®ç‚¹</td>
<td><strong>RMæ¨è</strong>ï¼ŒèŠ‚çœå†…å­˜</td>
</tr>
</tbody>
</table>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // è·å–äºŒå€¼å›¾ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = processImage(img);
    
    // æŸ¥æ‰¾è½®å»“
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, 
                     cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "æ‰¾åˆ° " &lt;&lt; contours.size() &lt;&lt; " ä¸ªè½®å»“" &lt;&lt; std::endl;
    
    // éå†æ‰€æœ‰è½®å»“
    for (size_t i = 0; i &lt; contours.size(); i++) {
        std::cout &lt;&lt; "è½®å»“ " &lt;&lt; i &lt;&lt; " æœ‰ " &lt;&lt; contours[i].size() 
                  &lt;&lt; " ä¸ªç‚¹" &lt;&lt; std::endl;
    }
    
    return 0;
}
</code></pre>
<h3>é‡è¦æ³¨æ„äº‹é¡¹</h3>
<h4>æ³¨æ„1: findContoursä¼šä¿®æ”¹è¾“å…¥å›¾åƒï¼</h4>
<pre><code>//  é”™è¯¯ï¼šåŸå§‹binaryè¢«ä¿®æ”¹äº†
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

//  æ­£ç¡®ï¼šä¼ å…¥å‰¯æœ¬
cv::Mat binary_copy = binary.clone();
cv::findContours(binary_copy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// æˆ–è€…ç›´æ¥åœ¨ä¸´æ—¶å¯¹è±¡ä¸Šè°ƒç”¨
cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
</code></pre>
<h4>æ³¨æ„2: è¾“å…¥å¿…é¡»æ˜¯äºŒå€¼å›¾</h4>
<pre><code>//  é”™è¯¯ï¼šå½©è‰²å›¾ä¸è¡Œ
cv::Mat img = cv::imread("armor.jpg");
cv::findContours(img, contours, ...);  //  ç»“æœä¸å¯¹

//  æ­£ç¡®ï¼šå¿…é¡»æ˜¯äºŒå€¼å›¾ï¼ˆ0æˆ–255ï¼‰
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
cv::findContours(binary, contours, ...);
</code></pre>
<hr />
<h2>2. è½®å»“æ•°æ®ç»“æ„ç†è§£</h2>
<h3>è½®å»“çš„æœ¬è´¨</h3>
<pre><code>// è½®å»“ = ç‚¹çš„é›†åˆ
std::vector&lt;cv::Point&gt; contour = contours[0];

// æ¯ä¸ªç‚¹æ˜¯(x, y)åæ ‡
cv::Point p = contour[0];
std::cout &lt;&lt; "ç¬¬ä¸€ä¸ªç‚¹: (" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; std::endl;
</code></pre>
<h3>è½®å»“æ“ä½œç¤ºä¾‹</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// è½®å»“æ•°é‡
int num = contours.size();

// ç¬¬iä¸ªè½®å»“çš„ç‚¹æ•°
int pointCount = contours[i].size();

// è®¿é—®ç¬¬iä¸ªè½®å»“çš„ç¬¬jä¸ªç‚¹
cv::Point p = contours[i][j];
</code></pre>
<hr />
<h2>3. cv::contourArea() - è®¡ç®—è½®å»“é¢ç§¯</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>double cv::contourArea(InputArray contour, bool oriented = false);
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    std::cout &lt;&lt; "è½®å»“é¢ç§¯: " &lt;&lt; area &lt;&lt; " åƒç´ " &lt;&lt; std::endl;
}
</code></pre>
<h3>ç”¨äºè¿‡æ»¤å™ªç‚¹</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; validContours;

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    
    // è¿‡æ»¤å¤ªå°çš„è½®å»“ï¼ˆå™ªç‚¹ï¼‰
    if (area &lt; 100) continue;
    
    // è¿‡æ»¤å¤ªå¤§çš„è½®å»“ï¼ˆå¯èƒ½æ˜¯æ•´ä¸ªè£…ç”²æ¿æˆ–èƒŒæ™¯ï¼‰
    if (area &gt; 10000) continue;
    
    // ä¿ç•™åˆç†å¤§å°çš„è½®å»“
    validContours.push_back(contour);
}

std::cout &lt;&lt; "è¿‡æ»¤åå‰©ä½™ " &lt;&lt; validContours.size() &lt;&lt; " ä¸ªè½®å»“" &lt;&lt; std::endl;
</code></pre>
<h3>é¢ç§¯é˜ˆå€¼å¦‚ä½•é€‰æ‹©ï¼Ÿ</h3>
<p>è¿™å–å†³äºï¼š</p>
<ol>
<li><strong>å›¾åƒåˆ†è¾¨ç‡</strong> - 1920Ã—1080 vs 640Ã—480</li>
<li><strong>è£…ç”²æ¿è·ç¦»</strong> - è¿‘è·ç¦»ç¯æ¡å¤§ï¼Œè¿œè·ç¦»ç¯æ¡å°</li>
<li><strong>ç›¸æœºFOV</strong> - è§†åœºè§’å¤§å°</li>
</ol>
<p><strong>æ¨èæ–¹æ³•</strong>ï¼š</p>
<pre><code>// æ ¹æ®å›¾åƒå¤§å°è‡ªé€‚åº”
int imageArea = binary.rows * binary.cols;
double minArea = imageArea * 0.0001;  // 0.01%
double maxArea = imageArea * 0.05;    // 5%

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    if (area &gt; minArea &amp;&amp; area &lt; maxArea) {
        // åˆç†èŒƒå›´
    }
}
</code></pre>
<hr />
<h2>4. cv::minAreaRect() - æœ€å°æ—‹è½¬çŸ©å½¢</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>RotatedRect cv::minAreaRect(InputArray points);
</code></pre>
<h3>ä¸ºä»€ä¹ˆç”¨æ—‹è½¬çŸ©å½¢ï¼Ÿ</h3>
<p>ç¯æ¡é€šå¸¸æ˜¯<strong>å€¾æ–œ</strong>çš„ï¼Œæ™®é€šçŸ©å½¢æ— æ³•å‡†ç¡®æè¿°ï¼š</p>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // æ‹Ÿåˆæœ€å°æ—‹è½¬çŸ©å½¢
    cv::RotatedRect rect = cv::minAreaRect(contour);
    
    // è·å–çŸ©å½¢ä¿¡æ¯
    cv::Point2f center = rect.center;      // ä¸­å¿ƒç‚¹
    cv::Size2f size = rect.size;           // å°ºå¯¸(width, height)
    float angle = rect.angle;              // æ—‹è½¬è§’åº¦(-90åˆ°0)
    
    std::cout &lt;&lt; "ä¸­å¿ƒ: (" &lt;&lt; center.x &lt;&lt; ", " &lt;&lt; center.y &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "å°ºå¯¸: " &lt;&lt; size.width &lt;&lt; " Ã— " &lt;&lt; size.height &lt;&lt; std::endl;
    std::cout &lt;&lt; "è§’åº¦: " &lt;&lt; angle &lt;&lt; "Â°" &lt;&lt; std::endl;
}
</code></pre>
<hr />
<h2>5. cv::RotatedRect ç±»è¯¦è§£</h2>
<h3>æ ¸å¿ƒå±æ€§</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// ä¸­å¿ƒç‚¹
cv::Point2f center = rect.center;  // çŸ©å½¢ä¸­å¿ƒçš„(x,y)åæ ‡

// å°ºå¯¸
cv::Size2f size = rect.size;       // width Ã— height
float width = size.width;
float height = size.height;

// æ—‹è½¬è§’åº¦
float angle = rect.angle;          // èŒƒå›´: -90Â° ~ 0Â°
</code></pre>
<h3>angleçš„é™·é˜±</h3>
<p><strong>OpenCVçš„angleå®šä¹‰å¾ˆåç›´è§‰ï¼</strong></p>
<pre><code>// angleçš„å«ä¹‰ï¼š
// ä»æ°´å¹³æ–¹å‘é€†æ—¶é’ˆæ—‹è½¬åˆ°çŸ©å½¢é•¿è¾¹çš„è§’åº¦
// èŒƒå›´ï¼š-90Â° åˆ° 0Â°

// ä¾‹å­ï¼š
angle = -90Â°  â†’ çŸ©å½¢å‚ç›´ï¼ˆç«–ç€ï¼‰
angle = -45Â°  â†’ çŸ©å½¢å€¾æ–œ45åº¦
angle = 0Â°    â†’ çŸ©å½¢æ°´å¹³ï¼ˆæ¨ªç€ï¼‰
</code></pre>
<h3>ç¡®ä¿heightæ˜¯é•¿è¾¹</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

float width = rect.size.width;
float height = rect.size.height;

//  OpenCVä¸ä¿è¯height &gt; widthï¼
// éœ€è¦æ‰‹åŠ¨è°ƒæ•´
if (width &gt; height) {
    std::swap(width, height);
    // å¦‚æœéœ€è¦ï¼Œä¹Ÿå¯ä»¥è°ƒæ•´angle
}

// ç°åœ¨ height ä¸€å®šæ˜¯é•¿è¾¹
float aspectRatio = height / width;  // é•¿å®½æ¯”
</code></pre>
<h3>è·å–å››ä¸ªé¡¶ç‚¹åæ ‡</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// è·å–å››ä¸ªé¡¶ç‚¹
cv::Point2f vertices[4];
rect.points(vertices);

// vertices[0], vertices[1], vertices[2], vertices[3]
// æŒ‰é€†æ—¶é’ˆé¡ºåºæ’åˆ—

// ç»˜åˆ¶æ—‹è½¬çŸ©å½¢
for (int i = 0; i &lt; 4; i++) {
    cv::line(img, vertices[i], vertices[(i+1)%4], 
             cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<hr />
<h2>6. ç¯æ¡ç‰¹å¾ç­›é€‰ï¼ˆæ ¸å¿ƒï¼‰</h2>
<h3>ç¯æ¡çš„å…¸å‹ç‰¹å¾</h3>
<table>
<thead>
<tr>
<th>ç‰¹å¾</th>
<th>åˆç†èŒƒå›´</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>é•¿å®½æ¯”</strong></td>
<td>2.0 ~ 10.0</td>
<td>ç¯æ¡æ˜¯ç»†é•¿çš„</td>
</tr>
<tr>
<td><strong>é¢ç§¯</strong></td>
<td>100 ~ 5000åƒç´ </td>
<td>æ ¹æ®åˆ†è¾¨ç‡è°ƒæ•´</td>
</tr>
<tr>
<td><strong>è§’åº¦</strong></td>
<td>æ¥è¿‘å‚ç›´</td>
<td>é€šå¸¸åœ¨Â±30Â°å†…</td>
</tr>
<tr>
<td><strong>å¡«å……åº¦</strong></td>
<td>&gt; 0.5</td>
<td>è½®å»“é¢ç§¯/å¤–æ¥çŸ©å½¢é¢ç§¯</td>
</tr>
</tbody>
</table>
<h3>å®Œæ•´ç­›é€‰ä»£ç </h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    float angle;
};

std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary) {
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::vector&lt;LightBar&gt; lightBars;
    
    for (const auto&amp; contour : contours) {
        // 1. é¢ç§¯ç­›é€‰
        double area = cv::contourArea(contour);
        if (area &lt; 100 || area &gt; 5000) continue;
        
        // 2. æ‹Ÿåˆæ—‹è½¬çŸ©å½¢
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 3. ç¡®ä¿heightæ˜¯é•¿è¾¹
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // 4. é•¿å®½æ¯”ç­›é€‰
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0 || aspectRatio &gt; 10.0) continue;
        
        // 5. è§’åº¦ç­›é€‰ï¼ˆå¯é€‰ï¼Œæ ¹æ®å®é™…æƒ…å†µï¼‰
        // ç¯æ¡åº”è¯¥æ¥è¿‘å‚ç›´
        float angle = std::abs(rect.angle);
        if (angle &gt; 30 &amp;&amp; angle &lt; 60) continue;  // å¤ªæ–œçš„æ’é™¤
        
        // 6. å¡«å……åº¦ç­›é€‰ï¼ˆå¯é€‰ï¼‰
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) continue;  // å¤ªç©ºçš„ä¸æ˜¯ç¯æ¡
        
        // é€šè¿‡æ‰€æœ‰ç­›é€‰ï¼Œä¿å­˜
        LightBar bar;
        bar.rect = rect;
        bar.area = area;
        bar.aspectRatio = aspectRatio;
        bar.angle = angle;
        lightBars.push_back(bar);
    }
    
    std::cout &lt;&lt; "æ‰¾åˆ° " &lt;&lt; lightBars.size() &lt;&lt; " ä¸ªç¯æ¡" &lt;&lt; std::endl;
    return lightBars;
}
</code></pre>
<h3>ç­›é€‰æ•ˆæœå±•ç¤º</h3>
<pre><code>// å‡è®¾æ‰¾åˆ°20ä¸ªè½®å»“ï¼š

è½®å»“1: é¢ç§¯=50      å¤ªå°ï¼Œè¿‡æ»¤
è½®å»“2: é¢ç§¯=800    é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=5.2    é€šè¿‡é•¿å®½æ¯”
       å¡«å……åº¦=0.8  é€šè¿‡å¡«å……åº¦
       ç»“æœ: ç¯æ¡å€™é€‰1 

è½®å»“3: é¢ç§¯=1200     é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=1.1   å¤ªçŸ®ï¼Œè¿‡æ»¤

è½®å»“4: é¢ç§¯=900      é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=4.8    é€šè¿‡é•¿å®½æ¯”
       å¡«å……åº¦=0.3   å¤ªç©ºï¼Œè¿‡æ»¤

...

æœ€ç»ˆ: æ‰¾åˆ°4ä¸ªç¯æ¡ï¼ˆ2å¯¹è£…ç”²æ¿ï¼‰
</code></pre>
<hr />
<h2>7. cv::drawContours() - ç»˜åˆ¶è½®å»“ï¼ˆè°ƒè¯•ï¼‰</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::drawContours(InputOutputArray image,
                      InputArrayOfArrays contours,
                      int contourIdx, 
                      const Scalar&amp; color,
                      int thickness = 1);
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat display = img.clone();

// ç»˜åˆ¶æ‰€æœ‰è½®å»“
cv::drawContours(display, contours, -1, cv::Scalar(0, 255, 0), 2);
// -1 è¡¨ç¤ºç»˜åˆ¶æ‰€æœ‰è½®å»“

// ç»˜åˆ¶ç¬¬iä¸ªè½®å»“
cv::drawContours(display, contours, i, cv::Scalar(255, 0, 0), 2);

// å¡«å……è½®å»“
cv::drawContours(display, contours, i, cv::Scalar(0, 0, 255), -1);
// thickness=-1 è¡¨ç¤ºå¡«å……
</code></pre>
<h3>å½©è‰²è°ƒè¯•å¯è§†åŒ–</h3>
<pre><code>void visualizeContours(const cv::Mat&amp; img, 
                       const std::vector&lt;std::vector&lt;cv::Point&gt;&gt;&amp; contours) {
    cv::Mat display = img.clone();
    
    // ä¸ºæ¯ä¸ªè½®å»“éšæœºé¢œè‰²
    cv::RNG rng(12345);
    
    for (size_t i = 0; i &lt; contours.size(); i++) {
        cv::Scalar color(rng.uniform(0, 256), 
                        rng.uniform(0, 256), 
                        rng.uniform(0, 256));
        
        // ç»˜åˆ¶è½®å»“
        cv::drawContours(display, contours, i, color, 2);
        
        // æ ‡æ³¨åºå·
        cv::Moments m = cv::moments(contours[i]);
        cv::Point2f center(m.m10/m.m00, m.m01/m.m00);
        cv::putText(display, std::to_string(i), center,
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
    }
    
    cv::imshow("è½®å»“å¯è§†åŒ–", display);
}
</code></pre>
<hr />
<h2>8. ç»˜åˆ¶æ—‹è½¬çŸ©å½¢</h2>
<h3>æ ‡å‡†æ–¹æ³•</h3>
<pre><code>void drawRotatedRect(cv::Mat&amp; img, const cv::RotatedRect&amp; rect, 
                     const cv::Scalar&amp; color, int thickness = 2) {
    cv::Point2f vertices[4];
    rect.points(vertices);
    
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], color, thickness);
    }
}

// ä½¿ç”¨
for (const auto&amp; bar : lightBars) {
    drawRotatedRect(display, bar.rect, cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<h3>ğŸ¨ å¢å¼ºç‰ˆï¼ˆå¸¦ä¸­å¿ƒç‚¹å’Œæ–‡å­—ï¼‰</h3>
<pre><code>void drawLightBar(cv::Mat&amp; img, const LightBar&amp; bar, int id) {
    // ç»˜åˆ¶æ—‹è½¬çŸ©å½¢
    cv::Point2f vertices[4];
    bar.rect.points(vertices);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // ç»˜åˆ¶ä¸­å¿ƒç‚¹
    cv::circle(img, bar.rect.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // æ ‡æ³¨ä¿¡æ¯
    std::string text = "ID:" + std::to_string(id) + 
                       " R:" + std::to_string((int)bar.aspectRatio);
    cv::putText(img, text, 
                cv::Point(bar.rect.center.x + 10, bar.rect.center.y),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 255), 2);
}
</code></pre>
<hr />
<h2>9. cv::boundingRect() - æ­£çŸ©å½¢åŒ…å›´æ¡†</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>Rect cv::boundingRect(InputArray points);
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // è·å–æ­£çŸ©å½¢ï¼ˆæ°´å¹³/å‚ç›´è¾¹ï¼‰
    cv::Rect bbox = cv::boundingRect(contour);
    
    // ç»˜åˆ¶
    cv::rectangle(img, bbox, cv::Scalar(255, 0, 0), 2);
    
    // è£å‰ªROI
    cv::Mat roi = img(bbox);
}
</code></pre>
<h3>æ­£çŸ©å½¢ vs æ—‹è½¬çŸ©å½¢</h3>
<pre><code>cv::Rect bbox = cv::boundingRect(contour);         // æ­£çŸ©å½¢
cv::RotatedRect rect = cv::minAreaRect(contour);   // æ—‹è½¬çŸ©å½¢

// æ­£çŸ©å½¢ï¼šè¾¹å¹³è¡Œäºåæ ‡è½´ï¼Œé¢ç§¯å¯èƒ½è¾ƒå¤§
// æ—‹è½¬çŸ©å½¢ï¼šæœ€å°é¢ç§¯ï¼Œä½†è¾¹å¯èƒ½å€¾æ–œ

// ç”¨é€”ï¼š
// - æ­£çŸ©å½¢ï¼šè£å‰ªROIã€å¿«é€Ÿç¢°æ’æ£€æµ‹
// - æ—‹è½¬çŸ©å½¢ï¼šç²¾ç¡®æè¿°ç¯æ¡å½¢çŠ¶å’Œè§’åº¦
</code></pre>
<hr />
<h2>10. cv::fitEllipse() - æ¤­åœ†æ‹Ÿåˆï¼ˆèƒ½é‡æœºå…³ç”¨ï¼‰</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>RotatedRect cv::fitEllipse(InputArray points);
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // è‡³å°‘éœ€è¦5ä¸ªç‚¹
    if (contour.size() &lt; 5) continue;
    
    // æ‹Ÿåˆæ¤­åœ†
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // ç»˜åˆ¶æ¤­åœ†
    cv::ellipse(img, ellipse, cv::Scalar(0, 255, 255), 2);
}
</code></pre>
<h3>èƒ½é‡æœºå…³æ‰‡å¶è¯†åˆ«</h3>
<pre><code>// èƒ½é‡æœºå…³çš„Ræ ‡æ˜¯æ¤­åœ†å½¢
bool isEnergyRune(const std::vector&lt;cv::Point&gt;&amp; contour) {
    if (contour.size() &lt; 5) return false;
    
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // æ¤­åœ†çš„é•¿çŸ­è½´æ¯”åº”è¯¥æ¥è¿‘1ï¼ˆè¿‘ä¼¼åœ†å½¢ï¼‰
    float ratio = ellipse.size.width / ellipse.size.height;
    if (ratio &lt; 0.8 || ratio &gt; 1.2) return false;
    
    // é¢ç§¯åˆç†
    double area = CV_PI * ellipse.size.width/2 * ellipse.size.height/2;
    if (area &lt; 500 || area &gt; 3000) return false;
    
    return true;
}
</code></pre>
<hr />
<h2>å®Œæ•´å®æˆ˜ä»£ç </h2>
<h3>å®Œæ•´çš„ç¯æ¡æ£€æµ‹ç³»ç»Ÿ</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

// ç¯æ¡ç»“æ„ä½“
struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    
    LightBar(const cv::RotatedRect&amp; r, double a, float ar)
        : rect(r), area(a), aspectRatio(ar) {}
};

// ç¯æ¡æ£€æµ‹å‡½æ•°
std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary, 
                                      const cv::Mat&amp; display) {
    // 1. æŸ¥æ‰¾è½®å»“
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "æ€»è½®å»“æ•°: " &lt;&lt; contours.size() &lt;&lt; std::endl;
    
    std::vector&lt;LightBar&gt; lightBars;
    
    // 2. éå†ç­›é€‰
    for (size_t i = 0; i &lt; contours.size(); i++) {
        const auto&amp; contour = contours[i];
        
        // é¢ç§¯ç­›é€‰
        double area = cv::contourArea(contour);
        if (area &lt; 100) {
            std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ": é¢ç§¯=" &lt;&lt; area 
                      &lt;&lt; "  å¤ªå°" &lt;&lt; std::endl;
            continue;
        }
        if (area &gt; 5000) {
            std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ": é¢ç§¯=" &lt;&lt; area 
                      &lt;&lt; " å¤ªå¤§" &lt;&lt; std::endl;
            continue;
        }
        
        // æ‹Ÿåˆæ—‹è½¬çŸ©å½¢
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // ç¡®ä¿heightæ˜¯é•¿è¾¹
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // é•¿å®½æ¯”ç­›é€‰
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0) {
            std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ": é•¿å®½æ¯”=" &lt;&lt; aspectRatio 
                      &lt;&lt; " å¤ªçŸ®" &lt;&lt; std::endl;
            continue;
        }
        if (aspectRatio &gt; 10.0) {
            std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ": é•¿å®½æ¯”=" &lt;&lt; aspectRatio 
                      &lt;&lt; "å¤ªç»†" &lt;&lt; std::endl;
            continue;
        }
        
        // å¡«å……åº¦ç­›é€‰
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) {
            std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ": å¡«å……åº¦=" &lt;&lt; fillRatio 
                      &lt;&lt; "  å¤ªç©º" &lt;&lt; std::endl;
            continue;
        }
        
        // é€šè¿‡ç­›é€‰ï¼
        std::cout &lt;&lt; "è½®å»“" &lt;&lt; i &lt;&lt; ":  ç¯æ¡å€™é€‰" &lt;&lt; std::endl;
        std::cout &lt;&lt; "    é¢ç§¯=" &lt;&lt; area &lt;&lt; ", é•¿å®½æ¯”=" &lt;&lt; aspectRatio 
                  &lt;&lt; ", å¡«å……åº¦=" &lt;&lt; fillRatio &lt;&lt; std::endl;
        
        lightBars.emplace_back(rect, area, aspectRatio);
        
        // ç»˜åˆ¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
        if (!display.empty()) {
            cv::Point2f vertices[4];
            rect.points(vertices);
            for (int j = 0; j &lt; 4; j++) {
                cv::line(display, vertices[j], vertices[(j+1)%4],
                         cv::Scalar(0, 255, 0), 2);
            }
            cv::circle(display, rect.center, 5, cv::Scalar(0, 0, 255), -1);
        }
    }
    
    std::cout &lt;&lt; "\næœ€ç»ˆæ‰¾åˆ° " &lt;&lt; lightBars.size() &lt;&lt; " ä¸ªç¯æ¡" &lt;&lt; std::endl;
    return lightBars;
}

int main() {
    // è¯»å–å›¾åƒ
    cv::Mat img = cv::imread("armor.jpg");
    if (img.empty()) {
        std::cerr &lt;&lt; "æ— æ³•è¯»å–å›¾åƒ" &lt;&lt; std::endl;
        return -1;
    }
    
    // é¢œè‰²æå–ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = extractRedColor(img);
    
    // å½¢æ€å­¦å¤„ç†ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    binary = morphologyProcess(binary);
    
    // ç¯æ¡æ£€æµ‹
    cv::Mat display = img.clone();
    std::vector&lt;LightBar&gt; lightBars = detectLightBars(binary, display);
    
    // æ˜¾ç¤ºç»“æœ
    cv::imshow("åŸå›¾", img);
    cv::imshow("äºŒå€¼å›¾", binary);
    cv::imshow("æ£€æµ‹ç»“æœ", display);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>å¸¸è§é—®é¢˜æ’æŸ¥</h2>
<h3>é—®é¢˜1: æ‰¾ä¸åˆ°è½®å»“</h3>
<pre><code>// æ£€æŸ¥æ¸…å•ï¼š
// 1. äºŒå€¼å›¾æ˜¯å¦æ­£ç¡®ï¼Ÿ
cv::imshow("binary", binary);  // åº”è¯¥æ˜¯é»‘ç™½çš„

// 2. å‰æ™¯æ˜¯ç™½è‰²å—ï¼Ÿ
// findContoursæ‰¾çš„æ˜¯ç™½è‰²åŒºåŸŸï¼å¦‚æœåäº†éœ€è¦åè½¬
cv::bitwise_not(binary, binary);

// 3. å›¾åƒæ˜¯å•é€šé“å—ï¼Ÿ
std::cout &lt;&lt; "é€šé“æ•°: " &lt;&lt; binary.channels() &lt;&lt; std::endl;  // åº”è¯¥æ˜¯1
</code></pre>
<h3>é—®é¢˜2: æ‰¾åˆ°å¤ªå¤šè½®å»“ï¼ˆéƒ½æ˜¯å™ªç‚¹ï¼‰</h3>
<pre><code>// è§£å†³æ–¹æ¡ˆï¼š
// 1. åŠ å¼ºå½¢æ€å­¦å¤„ç†
cv::morphologyEx(binary, binary, cv::MORPH_OPEN, kernel);

// 2. æé«˜é¢ç§¯é˜ˆå€¼
if (area &lt; 200) continue;  // å¢å¤§

// 3. æ·»åŠ å¡«å……åº¦ç­›é€‰
double fillRatio = area / (width * height);
if (fillRatio &lt; 0.6) continue;
</code></pre>
<h3>é—®é¢˜3: ç¯æ¡è¢«ç­›æ‰äº†</h3>
<pre><code>// è°ƒè¯•æ­¥éª¤ï¼š
// 1. æ‰“å°æ¯ä¸ªè½®å»“çš„å‚æ•°
for (size_t i = 0; i &lt; contours.size(); i++) {
    double area = cv::contourArea(contours[i]);
    cv::RotatedRect rect = cv::minAreaRect(contours[i]);
    float ratio = rect.size.height / rect.size.width;
    std::cout &lt;&lt; i &lt;&lt; ": area=" &lt;&lt; area &lt;&lt; ", ratio=" &lt;&lt; ratio &lt;&lt; std::endl;
}

// 2. æ”¾å®½ç­›é€‰æ¡ä»¶
if (aspectRatio &lt; 1.5 || aspectRatio &gt; 15.0) continue;  // æ”¾å®½èŒƒå›´

// 3. å¯è§†åŒ–è¢«ç­›æ‰çš„è½®å»“
cv::drawContours(rejected_img, contours, i, cv::Scalar(0,0,255), 2);
</code></pre>
<h3>é—®é¢˜4: æ—‹è½¬çŸ©å½¢è§’åº¦ä¸å¯¹</h3>
<pre><code>// OpenCVçš„angleæœ‰æ—¶ä¸ç¬¦åˆé¢„æœŸ
// è§£å†³æ–¹æ¡ˆï¼šè‡ªå·±è®¡ç®—è§’åº¦
cv::Point2f vertices[4];
rect.points(vertices);

// è®¡ç®—é•¿è¾¹çš„è§’åº¦
cv::Point2f edge = vertices[1] - vertices[0];
float angle = std::atan2(edge.y, edge.x) * 180 / CV_PI;
</code></pre>
<hr />
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RMè£…ç”²æ¿è¯†åˆ« - 01 å›¾åƒè¯»å–ä¸æ˜¾ç¤º</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_01/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_01/</id>
    <published>2025-10-23T00:00:00.000Z</published>
    <updated>2025-10-23T00:00:00.000Z</updated>
    <summary>æ— </summary>
    <content type="html"><![CDATA[<h2>æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>ä½œç”¨</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::imread()</code></td>
<td>è¯»å–å›¾ç‰‡åˆ°å†…å­˜</td>
</tr>
<tr>
<td><code>cv::imshow()</code></td>
<td>æ˜¾ç¤ºå›¾ç‰‡çª—å£</td>
</tr>
<tr>
<td><code>cv::waitKey()</code></td>
<td>ç­‰å¾…æŒ‰é”®</td>
</tr>
<tr>
<td><code>cv::imwrite()</code></td>
<td>ä¿å­˜å›¾ç‰‡</td>
</tr>
<tr>
<td><code>cv::Mat</code></td>
<td>å›¾åƒæ•°æ®ç±»å‹</td>
</tr>
<tr>
<td><code>cv::VideoCapture</code></td>
<td>æ‰“å¼€ç›¸æœº/è§†é¢‘</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::imread() - è¯»å–å›¾ç‰‡</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>cv::Mat cv::imread(const String&amp; filename, int flags = IMREAD_COLOR);
</code></pre>
<h3>å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>ç±»å‹</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td>string</td>
<td>å›¾ç‰‡è·¯å¾„ï¼ˆç›¸å¯¹æˆ–ç»å¯¹è·¯å¾„ï¼‰</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>int</td>
<td>è¯»å–æ¨¡å¼ï¼ˆè§ä¸‹è¡¨ï¼‰</td>
</tr>
</tbody>
</table>
<p><strong>flagså¸¸ç”¨å€¼:</strong></p>
<ul>
<li><code>cv::IMREAD_COLOR</code> (é»˜è®¤) - è¯»å–å½©è‰²å›¾ï¼Œå¿½ç•¥é€æ˜åº¦</li>
<li><code>cv::IMREAD_GRAYSCALE</code> - è½¬ä¸ºç°åº¦å›¾</li>
<li><code>cv::IMREAD_UNCHANGED</code> - åŒ…å«Alphaé€šé“</li>
</ul>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>
    // è¯»å–å½©è‰²å›¾ï¼ˆè£…ç”²æ¿è¯†åˆ«ç”¨è¿™ä¸ªï¼‰
    cv::Mat img = cv::imread("armor.jpg", cv::IMREAD_COLOR);
    
    //  å¿…é¡»æ£€æŸ¥æ˜¯å¦è¯»å–æˆåŠŸï¼
    if (img.empty()) {
        std::cout &lt;&lt; " å›¾ç‰‡è¯»å–å¤±è´¥ï¼" &lt;&lt; std::endl;
        return -1;
    }
    
    // æ‰“å°å›¾ç‰‡ä¿¡æ¯
    std::cout &lt;&lt; " å›¾ç‰‡è¯»å–æˆåŠŸ" &lt;&lt; std::endl;
    std::cout &lt;&lt; "   å°ºå¯¸: " &lt;&lt; img.cols &lt;&lt; " x " &lt;&lt; img.rows &lt;&lt; std::endl;
    std::cout &lt;&lt; "   é€šé“æ•°: " &lt;&lt; img.channels() &lt;&lt; std::endl;

</code></pre>
<h3>è¾“å‡ºç¤ºä¾‹</h3>
<pre><code> å›¾ç‰‡è¯»å–æˆåŠŸ
   å°ºå¯¸: 1280 x 720
   é€šé“æ•°: 3
</code></pre>
<h3>å¸¸è§é”™è¯¯</h3>
<h4>é”™è¯¯1: è·¯å¾„å†™é”™</h4>
<pre><code>
// æ­£ç¡®å†™æ³•
cv::Mat img = cv::imread("/home/user/img.jpg");     // ç»å¯¹è·¯å¾„
cv::Mat img = cv::imread("img.jpg");       //ç›¸å¯¹è·¯å¾„

</code></pre>
<h4>é”™è¯¯2: å¿˜è®°æ£€æŸ¥empty()</h4>
<pre><code>// å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåç»­æ“ä½œä¼šå´©æºƒ
cv::Mat img = cv::imread("not_exist.jpg");
cv::imshow("Window", img);  // å´©æºƒ

//  æ­£ç¡®å†™æ³•
cv::Mat img = cv::imread("not_exist.jpg");
if (img.empty()) {
    std::cerr &lt;&lt; "æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ ¼å¼ä¸æ”¯æŒ" &lt;&lt; std::endl;
    return -1;
}
</code></pre>
<blockquote>
<p><strong>OpenCVè¯»å–çš„å›¾ç‰‡æ˜¯BGRæ ¼å¼ï¼Œä¸æ˜¯RGBï¼</strong><br />
è¿™åœ¨åç»­é¢œè‰²è¯†åˆ«æ—¶éå¸¸é‡è¦ã€‚å¦‚æœä½ è¦è½¬RGBéœ€è¦ç”¨ <code>cv::cvtColor()</code></p>
</blockquote>
<hr />
<h2>2. cv::imshow() - æ˜¾ç¤ºå›¾ç‰‡</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>void cv::imshow(const String&amp; winname, InputArray mat);
</code></pre>
<h3>å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>ç±»å‹</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>winname</code></td>
<td>string</td>
<td>çª—å£åç§°ï¼ˆè‡ªå·±èµ·åï¼‰</td>
</tr>
<tr>
<td><code>mat</code></td>
<td>Mat</td>
<td>è¦æ˜¾ç¤ºçš„å›¾åƒ</td>
</tr>
</tbody>
</table>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");

// æ˜¾ç¤ºå›¾ç‰‡
cv::imshow("åŸå›¾", img);

//  å¿…é¡»é…åˆwaitKey()ï¼Œå¦åˆ™çª—å£é—ªç°å³æ¶ˆå¤±ï¼
cv::waitKey(0);  // 0è¡¨ç¤ºæ— é™ç­‰å¾…ï¼Œç›´åˆ°æŒ‰ä»»æ„é”®

// å…³é—­æ‰€æœ‰çª—å£
cv::destroyAllWindows();
</code></pre>
<h3>æ˜¾ç¤ºå¤šä¸ªçª—å£</h3>
<pre><code>cv::Mat img1 = cv::imread("red_armor.jpg");
cv::Mat img2 = cv::imread("blue_armor.jpg");

cv::imshow("çº¢æ–¹è£…ç”²æ¿", img1);
cv::imshow("è“æ–¹è£…ç”²æ¿", img2);

cv::waitKey(0);
cv::destroyAllWindows();
</code></pre>
<h3>å¸¸è§é”™è¯¯</h3>
<pre><code>//é”™è¯¯ï¼šçª—å£é—ªä¸€ä¸‹å°±æ¶ˆå¤±
cv::imshow("Window", img);
// ç¼ºå°‘ waitKey()

// æ­£ç¡®å†™æ³•
cv::imshow("Window", img);
cv::waitKey(0);
</code></pre>
<hr />
<h2>3. cv::waitKey() - ç­‰å¾…æŒ‰é”®</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>int cv::waitKey(int delay = 0);
</code></pre>
<h3>å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delay</code></td>
<td>ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œ0è¡¨ç¤ºæ— é™ç­‰å¾…</td>
</tr>
<tr>
<td><strong>è¿”å›å€¼</strong></td>
<td>æŒ‰ä¸‹çš„é”®çš„ASCIIç ï¼Œè¶…æ—¶è¿”å›-1</td>
</tr>
</tbody>
</table>
<h3>å®ç”¨æŠ€å·§</h3>
<h4>æŠ€å·§1: ç­‰å¾…ä»»æ„é”®</h4>
<pre><code>cv::imshow("Image", img);
cv::waitKey(0);  // æŒ‰ä»»æ„é”®ç»§ç»­
</code></pre>
<h4>æŠ€å·§2: æ£€æµ‹ç‰¹å®šæŒ‰é”®</h4>
<pre><code>cv::imshow("Image", img);
int key = cv::waitKey(0);

if (key == 27) {  // ESCé”®
    std::cout &lt;&lt; "ç”¨æˆ·å–æ¶ˆ" &lt;&lt; std::endl;
} else if (key == 's' || key == 'S') {  // Sé”®
    cv::imwrite("saved.jpg", img);
    std::cout &lt;&lt; "å›¾ç‰‡å·²ä¿å­˜" &lt;&lt; std::endl;
}
</code></pre>
<h4>æŠ€å·§3: å®æ—¶è§†é¢‘æ˜¾ç¤ºï¼ˆ30fpsï¼‰</h4>
<pre><code>while (true) {
    cv::Mat frame = getFrame();  // è·å–ä¸€å¸§
    cv::imshow("Video", frame);
    
    // ç­‰å¾…33msï¼ˆçº¦30fpsï¼‰ï¼ŒæŒ‰ESCé€€å‡º
    if (cv::waitKey(33) == 27) break;
}
</code></pre>
<hr />
<h2>4. cv::Mat - å›¾åƒæ•°æ®ç±»å‹</h2>
<h3>æ ¸å¿ƒæ¦‚å¿µ</h3>
<p><code>cv::Mat</code> æ˜¯OpenCVçš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ª<strong>å¤šç»´æ•°ç»„</strong>ï¼š</p>
<ul>
<li>2Då›¾åƒ = äºŒç»´çŸ©é˜µ</li>
<li>å½©è‰²å›¾åƒ = ä¸‰ç»´çŸ©é˜µï¼ˆå®½Ã—é«˜Ã—é€šé“ï¼‰</li>
</ul>
<h3>åˆ›å»ºMatå¯¹è±¡</h3>
<h4>æ–¹æ³•1: é€šè¿‡imreadåˆ›å»º</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");
</code></pre>
<h4>æ–¹æ³•2: åˆ›å»ºç©ºç™½å›¾åƒ</h4>
<pre><code>// åˆ›å»º640Ã—480çš„é»‘è‰²å›¾åƒ
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

// åˆ›å»ºç™½è‰²å›¾åƒ
cv::Mat white(480, 640, CV_8UC3, cv::Scalar(255, 255, 255));

// åˆ›å»ºçº¢è‰²å›¾åƒ
cv::Mat red(480, 640, CV_8UC3, cv::Scalar(0, 0, 255));  // BGRæ ¼å¼ï¼
</code></pre>
<h3>å¸¸ç”¨å±æ€§</h3>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// åŸºæœ¬ä¿¡æ¯
int width = img.cols;      // å®½åº¦ï¼ˆåˆ—æ•°ï¼‰
int height = img.rows;     // é«˜åº¦ï¼ˆè¡Œæ•°ï¼‰
int channels = img.channels();  // é€šé“æ•°ï¼ˆ1=ç°åº¦ï¼Œ3=å½©è‰²ï¼‰
bool isEmpty = img.empty();     // æ˜¯å¦ä¸ºç©º

// æ•°æ®ç±»å‹
int type = img.type();     // CV_8UC3 ç­‰
int depth = img.depth();   // CV_8U ç­‰

// å†…å­˜ä¿¡æ¯
size_t total = img.total();    // æ€»åƒç´ æ•° = rows Ã— cols
size_t bytes = img.total() * img.elemSize();  // å ç”¨å­—èŠ‚æ•°
</code></pre>
<h3>è®¿é—®åƒç´ å€¼</h3>
<h4>æ–¹æ³•1: atè®¿é—®ï¼ˆå®‰å…¨ä½†æ…¢ï¼‰</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// è®¿é—®(100, 200)ä½ç½®çš„åƒç´ 
cv::Vec3b pixel = img.at&lt;cv::Vec3b&gt;(100, 200);
uchar blue = pixel[0];
uchar green = pixel[1];
uchar red = pixel[2];

// ä¿®æ”¹åƒç´ 
img.at&lt;cv::Vec3b&gt;(100, 200) = cv::Vec3b(255, 0, 0);  // è®¾ä¸ºè“è‰²
</code></pre>
<h4>æ–¹æ³•2: æŒ‡é’ˆè®¿é—®ï¼ˆå¿«ä½†éœ€å°å¿ƒï¼‰</h4>
<pre><code>for (int y = 0; y &lt; img.rows; y++) {
    uchar* row = img.ptr&lt;uchar&gt;(y);  // è·å–ç¬¬yè¡Œçš„æŒ‡é’ˆ
    for (int x = 0; x &lt; img.cols; x++) {
        uchar b = row[x * 3 + 0];
        uchar g = row[x * 3 + 1];
        uchar r = row[x * 3 + 2];
    }
}
</code></pre>
<h3>Matç±»å‹ä»£ç è¯´æ˜</h3>
<pre><code>// CV_&lt;bit-depth&gt;{U|S|F}C&lt;channels&gt;
CV_8UC1   // 8ä½æ— ç¬¦å·ï¼Œ1é€šé“ï¼ˆç°åº¦å›¾ï¼‰
CV_8UC3   // 8ä½æ— ç¬¦å·ï¼Œ3é€šé“ï¼ˆBGRå½©è‰²å›¾ï¼‰
CV_32FC1  // 32ä½æµ®ç‚¹ï¼Œ1é€šé“
CV_16SC3  // 16ä½æœ‰ç¬¦å·ï¼Œ3é€šé“
</code></pre>
<hr />
<h2>5. cv::imwrite() - ä¿å­˜å›¾ç‰‡</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>bool cv::imwrite(const String&amp; filename, InputArray img);
</code></pre>
<h3>åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat img = cv::imread("input.jpg");

// å¤„ç†å›¾åƒ...

// ä¿å­˜ä¸ºJPGï¼ˆæœ‰æŸå‹ç¼©ï¼‰
cv::imwrite("output.jpg", img);

// ä¿å­˜ä¸ºPNGï¼ˆæ— æŸå‹ç¼©ï¼Œæ¨èä¿å­˜äºŒå€¼å›¾ï¼‰
cv::imwrite("binary.png", binaryImg);
</code></pre>
<h3>è®¾ç½®å‹ç¼©è´¨é‡</h3>
<pre><code>// JPGè´¨é‡æ§åˆ¶ï¼ˆ0-100ï¼Œé»˜è®¤95ï¼‰
std::vector&lt;int&gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // è´¨é‡90%
cv::imwrite("output.jpg", img, jpg_params);

// PNGå‹ç¼©çº§åˆ«ï¼ˆ0-9ï¼Œé»˜è®¤3ï¼‰
std::vector&lt;int&gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // æœ€å¤§å‹ç¼©
cv::imwrite("output.png", img, png_params);
</code></pre>
<hr />
<h2>6. cv::VideoCapture - æ‰“å¼€ç›¸æœº/è§†é¢‘</h2>
<h3>å‡½æ•°åŸå‹</h3>
<pre><code>cv::VideoCapture cap(int device);         // æ‰“å¼€ç›¸æœº
cv::VideoCapture cap(const String&amp; filename);  // æ‰“å¼€è§†é¢‘æ–‡ä»¶
</code></pre>
<h3>æ‰“å¼€ç›¸æœº</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    // æ‰“å¼€é»˜è®¤ç›¸æœºï¼ˆè®¾å¤‡ID=0ï¼‰
    cv::VideoCapture cap(0);
    
    // æ£€æŸ¥æ˜¯å¦æˆåŠŸæ‰“å¼€
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "âŒ ç›¸æœºæ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
        return -1;
    }
    
    // è®¾ç½®ç›¸æœºå‚æ•°ï¼ˆå¯é€‰ï¼‰
    cap.set(cv::CAP_PROP_FRAME_WIDTH, 1280);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 720);
    cap.set(cv::CAP_PROP_FPS, 60);
    
    cv::Mat frame;
    while (true) {
        // è¯»å–ä¸€å¸§
        cap.read(frame);
        // æˆ–è€…: cap &gt;&gt; frame;
        
        if (frame.empty()) {
            std::cerr &lt;&lt; "âŒ æ— æ³•è¯»å–å¸§" &lt;&lt; std::endl;
            break;
        }
        
        // æ˜¾ç¤º
        cv::imshow("Camera", frame);
        
        // æŒ‰ESCé€€å‡º
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<h3>è¯»å–è§†é¢‘æ–‡ä»¶</h3>
<pre><code>cv::VideoCapture cap("video.mp4");

if (!cap.isOpened()) {
    std::cerr &lt;&lt; "è§†é¢‘æ–‡ä»¶æ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
    return -1;
}

// è·å–è§†é¢‘ä¿¡æ¯
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &lt;&lt; "è§†é¢‘ä¿¡æ¯: " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height 
          &lt;&lt; " @ " &lt;&lt; fps &lt;&lt; "fps, å…±" &lt;&lt; frame_count &lt;&lt; "å¸§" &lt;&lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow("Video", frame);
    if (cv::waitKey(1000/fps) == 27) break;  // æŒ‰åŸé€Ÿæ’­æ”¾
}
</code></pre>
<hr />
<h2>æœ¬é˜¶æ®µå®æˆ˜ç»ƒä¹ </h2>
<p>&lt;/details&gt;</p>
<h3>ç»ƒä¹ : ç›¸æœºå®æ—¶é¢„è§ˆ</h3>
<p>å®ç°ä¸€ä¸ªç›¸æœºé¢„è§ˆç¨‹åºï¼Œæ˜¾ç¤ºå½“å‰FPS</p>
<p>&lt;details&gt;
&lt;summary&gt; å‚è€ƒç­”æ¡ˆ&lt;/summary&gt;</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "ç›¸æœºæ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &gt;&gt; frame;
        if (frame.empty()) break;
        
        // è®¡ç®—FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&lt;double&gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // åœ¨å›¾åƒä¸Šç»˜åˆ¶FPS
        std::string fps_text = "FPS: " + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow("Camera Preview", frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<p>&lt;/details&gt;</p>
<hr />
<h2>æ£€æŸ¥æ¸…å•</h2>
<p>å®Œæˆæœ¬é˜¶æ®µåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š</p>
<ul>
<li>[ ] ç”¨ <code>cv::imread()</code> è¯»å–å›¾ç‰‡å¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸ</li>
<li>[ ] ç”¨ <code>cv::imshow()</code> å’Œ <code>cv::waitKey()</code> æ˜¾ç¤ºå›¾ç‰‡</li>
<li>[ ] ç†è§£Matå¯¹è±¡çš„åŸºæœ¬å±æ€§ï¼ˆrows, cols, channelsï¼‰</li>
<li>[ ] ç”¨ <code>cv::imwrite()</code> ä¿å­˜å¤„ç†ç»“æœ</li>
<li>[ ] ç”¨ <code>cv::VideoCapture</code> æ‰“å¼€ç›¸æœºå¹¶å®æ—¶æ˜¾ç¤º</li>
</ul>
<hr />
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>æ›´æ–°æ—¥å¿—</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>è¿™é‡Œæ˜¯æ›´æ–°æ—¥å¿—</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>æ›´æ–°äº†ä¸ªäººç®€ä»‹</li>
<li>æ›´æ–°äº†rmç¬”è®°</li>
<li>æ›´æ–°äº†åŒæŒ‡é’ˆçš„æ¡†æ¶</li>
<li>è¯„è®ºæ²¡æŒ‚æœåŠ¡å™¨æ‰€ä»¥ä¸èƒ½ç”¨</li>
</ul>
<h2>2025-10-23</h2>
<ul>
<li>æ›´æ–°äº†å¿«æ…¢æŒ‡é’ˆ</li>
</ul>
<h2>2025-10-24</h2>
<ul>
<li>æ›´æ–°äº†ä¸¤ç¯‡opencvå…¥é—¨ï¼Œaiå†™çš„ï¼Œä»¥åçœ‹ç€èƒ½ä¸èƒ½ç²¾ç®€ä¸€ä¸‹</li>
</ul>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="æ—¥å¿—"></category>
  </entry>
  <entry>
    <title>åŒæŒ‡é’ˆ</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>åŒæŒ‡é’ˆå¸¸è§æŠ€å·§</summary>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">å¿«æ…¢æŒ‡é’ˆ</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">äºŒåˆ†æœç´¢</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">æ»‘åŠ¨çª—å£</a></li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">å›æ–‡/åè½¬</a></li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">æ•°ä¹‹å’Œ</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">åŒæŒ‡é’ˆåœ¨é“¾è¡¨çš„è¿ç”¨</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6">åˆå¹¶</a></li>
<li><a href="#%E5%88%86%E8%A7%A3">åˆ†è§£</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">å…¶ä»–</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
</ul>
<hr />
<h2>åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨</h2>
<hr />
<h2>å¿«æ…¢æŒ‡é’ˆ</h2>
<h3>æ•°ç»„çš„åŸåœ°ä¿®æ”¹</h3>
<ul>
<li>åŠ›æ‰£ç¬¬ 26 é¢˜ã€Œåˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ã€ï¼Œè®©ä½ åœ¨æœ‰åºæ•°ç»„å»é‡ï¼š
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</li>
</ul>
<hr />
<ul>
<li>ç»™ä½ ä¸€ä¸ª<strong>éä¸¥æ ¼é€’å¢æ’åˆ—</strong>çš„æ•°ç»„<code>nums</code> ï¼Œè¯·ä½ <strong>åŸåœ°</strong>åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ <strong>åªå‡ºç°ä¸€æ¬¡</strong>ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„<strong>ç›¸å¯¹é¡ºåº</strong>åº”è¯¥ä¿æŒ<strong>ä¸€è‡´</strong>ã€‚ç„¶åè¿”å› <code>nums</code> ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚</li>
<li>è€ƒè™‘ <code>nums </code>çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º <code>k</code>ã€‚å»é‡åï¼Œè¿”å›å”¯ä¸€å…ƒç´ çš„æ•°é‡ kã€‚</li>
<li><code>nums</code> çš„å‰ k ä¸ªå…ƒç´ åº”åŒ…å« æ’åºå çš„å”¯ä¸€æ•°å­—ã€‚ä¸‹æ ‡ <code>k - 1 </code>ä¹‹åçš„å‰©ä½™å…ƒç´ å¯ä»¥å¿½ç•¥ã€‚</li>
</ul>
<p>åˆ¤é¢˜æ ‡å‡†:</p>
<p>ç³»ç»Ÿä¼šç”¨ä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•ä½ çš„é¢˜è§£:</p>
<pre><code>int[] nums = [...]; // è¾“å…¥æ•°ç»„
int[] expectedNums = [...]; // é•¿åº¦æ­£ç¡®çš„æœŸæœ›ç­”æ¡ˆ
int k = removeDuplicates(nums); // è°ƒç”¨
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>å¦‚æœæ‰€æœ‰æ–­è¨€éƒ½é€šè¿‡ï¼Œé‚£ä¹ˆæ‚¨çš„é¢˜è§£å°†è¢«<strong>é€šè¿‡</strong>ã€‚</p>
<p>ç¤ºä¾‹ 1ï¼š</p>
<pre><code>è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š2, nums = [1,2,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2 ï¼Œå¹¶ä¸”åŸæ•°ç»„ nums çš„å‰ä¸¤ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 1, 2 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
</code></pre>
<p>ç¤ºä¾‹ 2ï¼š</p>
<pre><code>è¾“å…¥ï¼šnums = [0,0,1,1,1,2,2,3,3,4]
è¾“å‡ºï¼š5, nums = [0,1,2,3,4,_,_,_,_,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5 ï¼Œ å¹¶ä¸”åŸæ•°ç»„ nums çš„å‰äº”ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 0, 1, 2, 3, 4 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„
</code></pre>
<ul>
<li><strong>åŸåœ°</strong>æ„å‘³ç€åªèƒ½å¯¹å½“å‰æ•°ç»„è¿›è¡Œä¿®æ”¹ï¼Œä¸èƒ½æ–°å»ºä¸€ä¸ªæ•°ç»„</li>
<li>è¿™é‡Œæ‰€éœ€è¦ç”¨åˆ°çš„å°±æ˜¯<strong>å¿«æ…¢æŒ‡é’ˆ</strong></li>
<li>ç®€å•æ¥è¯´å°±æ˜¯ä¸€ä¸ªå¿«æŒ‡é’ˆå»è¯†åˆ«ï¼Œå¦ä¸€ä¸ªæ…¢æŒ‡é’ˆå»æ“ä½œ</li>
<li><strong>æ³¨æ„</strong>  è¿™é‡ŒæŒ‡é’ˆæ˜¯å¹¿ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œæ•°ç»„çš„ç´¢å¼•ä¹Ÿå¯ä»¥æ˜¯<strong>æŒ‡é’ˆ</strong></li>
<li>å¦‚æœ <code>fast</code> é‡åˆ°å€¼ä¸º <code>val </code>çš„å…ƒç´ ï¼Œåˆ™ç›´æ¥è·³è¿‡ï¼Œå¦åˆ™å°±èµ‹å€¼ç»™ <code>slow</code> æŒ‡é’ˆï¼Œå¹¶è®© <code>slow </code>å‰è¿›ä¸€æ­¥ã€‚</li>
</ul>
<p>å…·ä½“ä»£ç å¦‚ä¸‹</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
</code></pre>
<ul>
<li>æ³¨æ„è¿™é‡Œéœ€è¦<strong>å…ˆ<code>slow++</code>å†èµ‹å€¼</strong>ï¼Œè¦ä¸ç„¶ç¬¬ä¸€ä¸ªä¼šè¢«åæ‰</li>
</ul>
<hr />
<ul>
<li>ä¸‹é¢ä¸€é“é¢˜ä¹Ÿæ˜¯å¿«æ…¢æŒ‡é’ˆçš„æ€æƒ³ï¼Œå¦‚æœæŒæ¡äº†å‰ä¸€é“é¢˜ï¼Œè¿™é¢˜ä¼šå¾ˆç®€å•</li>
<li><strong>åŠ›æ‰£283ç§»åŠ¨0</strong>https://leetcode.cn/problems/move-zeroes/</li>
<li>ç»™å®šä¸€ä¸ªæ•°ç»„ <strong>nums</strong>ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚</li>
<li>è¯·æ³¨æ„ ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚</li>
</ul>
<p>ç¤ºä¾‹ 1:</p>
<pre><code>è¾“å…¥: nums = [0,1,0,3,12]
è¾“å‡º: [1,3,12,0,0]
ç¤ºä¾‹ 2:
</code></pre>
<pre><code>è¾“å…¥: nums = [0]
è¾“å‡º: [0]
</code></pre>
<p>è¿™é‡Œæˆ‘å°±ç›´æ¥ä¸Šä»£ç äº†</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int slow = 0;  // æŒ‡å‘ä¸‹ä¸€ä¸ªéé›¶åº”æ”¾ç½®çš„ä½ç½®
        for (int fast = 0; fast &lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow ä¹‹åçš„å…¨éƒ¨ç½®ä¸º 0
        for (int i = slow; i &lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

</code></pre>
<hr />
<h2>äºŒåˆ†æœç´¢</h2>
<ul>
<li>
<p>åœ¨æˆ‘ä»¬éƒ½ç©è¿‡çš„çŒœæ•°å­—æ¸¸æˆä¸­ï¼Œç”¨çš„å°±æ˜¯äºŒåˆ†æœç´ çš„æŠ€å·§</p>
</li>
<li>
<p>æˆ‘ä»¬å…ˆçœ‹æœ€ç¬¨çš„é¡ºåºæŸ¥æ‰¾ï¼Œæˆ‘ä»¬ä»1-100éå†å…¨éƒ¨æ•°å­—ï¼Œè™½ç„¶è¯´è¿æ°”å¥½å¯èƒ½ä¸€ä¸‹ä¼šçŒœä¸­ï¼Œä½†æ˜¯æœŸæœ›çš„æ¬¡æ•°è¿˜æ˜¯å¾ˆå¤šï¼Œå¤æ‚åº¦ä¸ºO(n)</p>
</li>
<li>
<p>å¦‚æœæ˜¯å‡­æ„Ÿè§‰æ‰¾ï¼Œä¸€æ ·è¿˜æ˜¯è¦çœ‹è¿æ°”</p>
</li>
<li>
<p>å¦‚æœç¬¬ä¸€æ¬¡çŒœ50ï¼Œç„¶åç»§ç»­ä¸€åŠä¸€åŠç¼©å°åŒºé—´ï¼Œæœ€åä¹Ÿèƒ½åœ¨7æ¬¡å†…è§£å†³</p>
<ul>
<li>å¦‚ä½•æ•°å­—æ¥åˆ°1-1000000ï¼ŒäºŒåˆ†æœç´¢æœ€å20æ¬¡å°±èƒ½æ‰¾åˆ°ç­”æ¡ˆ</li>
</ul>
</li>
<li>
<p>äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(log  N)</p>
</li>
<li>
<p>ä¸‹é¢æ˜¯æœ€åŸºæœ¬ä»£ç </p>
</li>
</ul>
<pre><code>int binarySearch(vector&lt;int&gt;&amp; nums, int target) {
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    int left = 0, right = nums.size() - 1;
    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; 
        else if (nums[mid] &gt; target)
            right = mid - 1;
    }
    return -1;
}
</code></pre>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="ç®—æ³•"></category>
  </entry>
  <entry>
    <title>è£…ç”²æ¿è‡ªåŠ¨è¯†åˆ«ä¸ä½å§¿ä¼°è®¡å­¦ä¹ </title>
    <link href="https://www.nanye404.top/posts/armor/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>ä¸€äº›å°ç¬”è®°</summary>
    <content type="html"><![CDATA[<h2>ç›®å½•</h2>
<ol>
<li><a href="#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88">æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A">å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š</a></li>
<li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86">ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰</a>
<ul>
<li>4.1 æ•°å­—åˆ†ç±»å™¨ <code>NumberClassifier</code></li>
<li>4.2 è§†è§‰æ£€æµ‹å™¨ <code>Detector</code></li>
<li>4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® <code>LightCornerCorrector</code></li>
<li>4.4 ä½å§¿ä¼°è®¡ <code>ArmorPoseEstimator</code>ï¼ˆPnP + BAï¼‰</li>
<li>4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ <code>BaSolver</code> / <code>GraphOptimizer</code></li>
<li>4.6 ROS2 èŠ‚ç‚¹ <code>ArmorDetectorNode</code></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97">å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96">å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF">å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA">è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰</a></li>
<li><a href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84">æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„</a></li>
</ol>
<hr />
<h2>æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ</h2>
<p><strong>ç›®æ ‡</strong>ï¼šä»ç›¸æœºæ¥çš„å½©è‰²å›¾åƒä¸­ï¼Œè‡ªåŠ¨æ‰¾å‡ºâ€œ<strong>ä¸¤æ ¹ç¯æ¡ç»„æˆçš„è£…ç”²æ¿</strong>â€ï¼Œ<strong>è¯†åˆ«è£…ç”²æ•°å­—</strong>ï¼Œå¹¶ä¼°è®¡è£…ç”²æ¿åœ¨<strong>ç›¸æœºåæ ‡ç³»</strong>ä¸‹çš„ä¸‰ç»´ä½å§¿ï¼ˆä½ç½® + å§¿æ€ï¼‰ï¼Œæœ€åé€šè¿‡ <strong>ROS2</strong> å‘å¸ƒç»“æœä¸å¯è§†åŒ–ã€‚</p>
<p><strong>å…³é”®é˜¶æ®µ</strong>ï¼š</p>
<ol>
<li>å›¾åƒé¢„å¤„ç† â†’ äºŒå€¼åŒ–è½®å»“ â†’ <strong>ç¯æ¡å€™é€‰</strong>ã€‚</li>
<li>ç¯æ¡å‡ ä½•ç­›é€‰ &amp; é¢œè‰²åˆ¤å®š â†’ <strong>ç¯æ¡é…å¯¹æˆè£…ç”²æ¿</strong>ã€‚</li>
<li>é€è§†å±•å¼€ä¸­éƒ¨åŒºåŸŸ â†’ <strong>æ•°å­—åˆ†ç±»</strong>ï¼ˆONNX æ¨¡å‹ï¼‰ã€‚</li>
<li>å¯¹ç¯æ¡ä¸Šä¸‹è§’ç‚¹åš<strong>å‡ ä½•ç»†åŒ–</strong>ï¼ˆæå‡ PnP ç¨³å®šæ€§ï¼‰ã€‚</li>
<li>ç”¨ <strong>PnP æ±‚åˆè§£</strong> â†’ æ¡ä»¶å…è®¸æ—¶ç”¨ **BAï¼ˆä»…ä¼˜åŒ– yawï¼‰**åšå°ä¼˜åŒ–ã€‚</li>
<li>å°è£…ä¸º ROS2 èŠ‚ç‚¹ï¼š<strong>è®¢é˜…å›¾åƒ/ç›¸æœºå†…å‚/TF</strong>ï¼Œå‘å¸ƒè°ƒè¯•å›¾åƒä¸ <strong>Marker</strong>ã€‚</li>
</ol>
<hr />
<h2>å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š</h2>
<ul>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;å›¾åƒè¯»å–ä¸æ˜¾ç¤º&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_02/"&gt;è£…ç”²æ¿é¢œè‰²æå–&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_03/"&gt;å½¢æ€å­¦å¤„ç†&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_04/"&gt;è½®å»“æ£€æµ‹&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
</ul>
<h2>ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰</h2>
<pre><code>Image(rgb8)
   â””â”€â–º é¢„å¤„ç†(ç°åº¦/é˜ˆå€¼)
          â””â”€â–º è½®å»“â†’ç¯æ¡(Light)
                 â””â”€â–º åŒè‰² + å‡ ä½•å…³ç³» â†’ è£…ç”²(Armor)
                        â”œâ”€â–º (å¯é€‰) ç¯æ¡è§’ç‚¹ç²¾ä¿®
                        â”œâ”€â–º é€è§†å±•å¼€æ•°å­—ROI â†’ äºŒå€¼åŒ– â†’ åˆ†ç±»
                        â””â”€â–º PnPæ±‚ä½å§¿ â†’ (å¯é€‰) BAä¼˜åŒ–yaw
                               â””â”€â–º å‘å¸ƒArmors + RViz Marker + è°ƒè¯•å›¾åƒ
</code></pre>
<hr />
<h2>æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰</h2>
<h3>4.1 æ•°å­—åˆ†ç±»å™¨ <code>NumberClassifier</code></h3>
<p><strong>èŒè´£</strong>ï¼šä»è£…ç”²æ¿ä¸¤æ ¹ç¯æ¡ä¹‹é—´è£å‡ºæ•°å­—å›¾ï¼ˆå›ºå®šå°ºå¯¸ï¼‰ï¼ŒäºŒå€¼åŒ–åå–‚ç»™ ONNX åˆ†ç±»ç½‘ç»œï¼Œå¾—åˆ°ç±»åˆ«ä¸ç½®ä¿¡åº¦ã€‚</p>
<p><strong>æ ¸å¿ƒï¼šé€è§†å±•å¼€ + äºŒå€¼åŒ– + DNN å‰å‘</strong></p>
<pre><code>// é€è§†å±•å¼€å¹¶è£ ROIï¼ˆå®½åº¦éšå¤§å°è£…ç”²è€Œå˜ï¼‰
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp; src, const Armor&amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // ä¸­éƒ¨ ROI â†’ ç°åº¦&amp;OTSU â†’ 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
</code></pre>
<pre><code>// å‰å‘åˆ†ç±» + ç»“æœè§£ç 
void NumberClassifier::classify(const cv::Mat&amp;, Armor&amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;conf, nullptr, &amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format("{}:{:.1f}%", armor.number, armor.confidence * 100.0);
}
</code></pre>
<pre><code>// è¿‡æ»¤ï¼šæŒ‰é˜ˆå€¼/å¿½ç•¥åˆ—è¡¨ + å¤§å°è£…ç”²ä¸ç±»åˆ«çš„äº’æ–¥è§„åˆ™
void NumberClassifier::eraseIgnoreClasses(std::vector&lt;Armor&gt;&amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;a) {
    if (a.confidence &lt; threshold) return true;
    for (auto&amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == "outpost" || a.number == "2" || a.number == "sentry");
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == "1"      || a.number == "base");
    return mismatch;
  }), armors.end());
}
</code></pre>
<p><strong>è¦ç‚¹</strong>ï¼šROI å®½åº¦ä¸è£…ç”²å°ºå¯¸åŒ¹é…ï¼›OTSU è®©é˜ˆå€¼æ›´ç¨³ï¼›<code>blobFromImage</code> å°è£…å½’ä¸€åŒ–ä¸ NHWCâ†’NCHWã€‚</p>
<hr />
<h3>4.2 è§†è§‰æ£€æµ‹å™¨ <code>Detector</code></h3>
<p><strong>èŒè´£</strong>ï¼šç°åº¦/é˜ˆå€¼ â†’ è½®å»“ â†’ ç¯æ¡ï¼ˆå½¢çŠ¶ + å€¾è§’ï¼‰â†’ ç»Ÿè®¡é¢œè‰² â†’ å·¦å³åŒè‰²é…å¯¹ â†’ è£…ç”²ã€‚è‹¥æœ‰åˆ†ç±»å™¨ä¸è§’ç‚¹ä¿®æ­£å™¨ï¼Œåˆ™å¹¶è¡Œè¿›è¡Œæ•°å­—åˆ†ç±»ä¸è§’ç‚¹ç»†åŒ–ã€‚</p>
<p><strong>æ€»ä½“æµç¨‹</strong></p>
<pre><code>std::vector&lt;Armor&gt; Detector::detect(const cv::Mat&amp; input) noexcept {
  binary_img = preprocessImage(input);               // ç°åº¦+å›ºå®šé˜ˆå€¼
  lights_    = findLights(input, binary_img);        // è½®å»“â†’Lightï¼ˆæ¯”ä¾‹/è§’åº¦/é¢œè‰²ï¼‰
  armors_    = matchLights(lights_);                 // å·¦å³é…å¯¹ â†’ Armor

  if (!armors_.empty() &amp;&amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;input](Armor&amp; a){
      a.number_img = classifier-&gt;extractNumber(input, a);
      classifier-&gt;classify(input, a);
      if (corner_corrector) corner_corrector-&gt;correctCorners(a, gray_img_);
    });
    classifier-&gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
</code></pre>
<p><strong>å…³é”®åˆ¤å®šï¼šç¯æ¡ä¸é…å¯¹</strong></p>
<pre><code>// ç¯æ¡ç­›é€‰ï¼šçŸ­é•¿è¾¹æ¯” + å€¾è§’
bool Detector::isLight(const Light&amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &lt; ratio &amp;&amp; ratio &lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &lt; light_params.max_angle;
  return ratio_ok &amp;&amp; angle_ok;
}

// é¢œè‰²ï¼šåœ¨è½®å»“åƒç´ ä¸­ç»Ÿè®¡R/Bå¼ºåº¦å·®ï¼ˆçº¢/è“ï¼‰
for (auto&amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &gt; light_params.color_diff_thresh)
  light.color = (sum_r &gt; sum_b ? RED : BLUE);

// å¤¹ç¯æ£€æµ‹ï¼šä¸¤ç¯æ¡å¤–æ¥çŸ©å½¢å†…æ˜¯å¦è¿˜â€œå¤¹â€ç€åˆ«çš„ç¯æ¡ï¼ˆä¸”æ’é™¤æ•°å­—/çº¢ç‚¹ç­‰å¹²æ‰°ï¼‰
bool containLight(int i, int j, const std::vector&lt;Light&gt;&amp; lights);

// é…å¯¹ï¼šåŒè‰² + Xæ–¹å‘æ‰«æ + ä¸­å¿ƒè·çª—å£ï¼ˆåŒºåˆ†å¤§å°è£…ç”²ï¼‰+ ä¸¤ç¯æ¡é•¿åº¦ç›¸è¿‘ + å¤¹è§’é™åˆ¶
std::vector&lt;Armor&gt; Detector::matchLights(const std::vector&lt;Light&gt;&amp; lights) noexcept;
</code></pre>
<hr />
<h3>4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® <code>LightCornerCorrector</code></h3>
<p><strong>èŒè´£</strong>ï¼šæ›´ç²¾ç¡®åœ°æ‰¾åˆ°æ¯æ ¹ç¯æ¡çš„<strong>ä¸Šä¸‹ç«¯ç‚¹</strong>ä¸<strong>ä¸­å¿ƒ/è½´å‘</strong>ï¼Œæå‡ PnP çš„ 2D-3D å¯¹åº”ç²¾åº¦ï¼ˆåœ¨äºŒå€¼åŒ–æˆ–å™ªå£°ç¯å¢ƒä¸‹å°¤å…¶æœ‰ç”¨ï¼‰ã€‚</p>
<p><strong>ç®—æ³•æ€è·¯</strong>ï¼š</p>
<ol>
<li>ä»¥ç¯æ¡å¤–æ¥æ¡†ä¸ºåŸºç¡€åš<strong>é€‚åº¦æ‰©å±•</strong>å¹¶æ£€æŸ¥è¾¹ç•Œï¼›</li>
<li>å¯¹è¯¥å°åŒºåŸŸåš<strong>é‡å¿ƒä¸ä¸»æ–¹å‘</strong>ä¼°è®¡ï¼ˆäº®åº¦åŠ æƒ + PCA/ä¸€é˜¶çŸ©ï¼‰ï¼Œå¾—åˆ°<strong>å¯¹ç§°è½´</strong>ï¼›</li>
<li>æ²¿å¯¹ç§°è½´çš„ä¸Šä¸‹æ–¹å‘ï¼Œä»¥å¤šä¸ªå¹³è¡Œâ€œæ‰«æçº¿â€å¯»æ‰¾<strong>äº®åº¦çªå˜æœ€å¤§</strong>çš„ä½ç½®ä½œä¸ºç«¯ç‚¹å€™é€‰ï¼Œæœ€åæ±‚å¹³å‡ã€‚</li>
</ol>
<p><strong>è¦ç‚¹ä»£ç </strong></p>
<pre><code>// è§’ç‚¹ä¿®æ­£å…¥å£ï¼šå®½åº¦å¤ªå°åˆ™è·³è¿‡ï¼Œé¿å…å™ªå£°
void LightCornerCorrector::correctCorners(Armor&amp; armor, const cv::Mat&amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp; è§’ç‚¹ */ }
  if (armor.right_light.width &gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp; è§’ç‚¹ */ }
}

// æ²¿å¯¹ç§°è½´å¯»æ‰¾â€œäº®åº¦çªå˜æœ€å¤§â€çš„ç‚¹ä½œä¸ºè§’ç‚¹ï¼ˆå¤šæ¡å¹³è¡Œçº¿ï¼Œå–å€™é€‰å¹³å‡ï¼‰
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp; gray, const Light&amp; light,
                                             const SymmetryAxis&amp; axis, std::string order) {
  // ... æ‰«æ START~END çš„å°æ®µï¼Œç´¯è®¡äº®åº¦å·®æœ€å¤§å¤„ ...
  // è¿”å›å‡å€¼ç‚¹ï¼›æ— å€™é€‰åˆ™è¿”å› (-1,-1)
}
</code></pre>
<hr />
<h3>4.4 ä½å§¿ä¼°è®¡ <code>ArmorPoseEstimator</code>ï¼ˆPnP + BAï¼‰</h3>
<p><strong>èŒè´£</strong>ï¼šæŠŠè£…ç”²å››è§’çš„ 2D åƒç´ ç‚¹ä¸å·²çŸ¥ 3D æ¨¡å‹ç‚¹ï¼ˆå¤§/å°è£…ç”²çš„çœŸå®å°ºå¯¸ï¼‰å¯¹åº”ï¼Œè§£å‡º R/tã€‚è‹¥ roll å°ä¸”å¼€å¯ BAï¼Œåˆ™è¿›ä¸€æ­¥ä»…åœ¨ <strong>yaw</strong> ç»´è¿›è¡Œå›¾ä¼˜åŒ–ï¼Œä½¿æŠ•å½±è¯¯å·®æ›´å°ã€‚</p>
<p><strong>æ ¸å¿ƒæµç¨‹</strong></p>
<pre><code>// 1) PnP åˆè§£ï¼ˆsolvePnPGeneric å¯èƒ½è¿”å›ä¸¤ç»„è§£ï¼‰
if (pnp_solver_-&gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) è§£çš„é€‰æ‹©ï¼ˆè¯¯å·®/roll/ç¯æ¡å€¾è§’â†’yawæ­£è´Ÿï¼‰

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;&amp; roll &lt; 15) {
    // 3) BAï¼šä»…ä¼˜åŒ– yawï¼Œå°å¹…ä¿®æ­£ R ä»¥å‡å°æŠ•å½±è¯¯å·®
    R = ba_solver_-&gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) å¡«å……æ¶ˆæ¯ï¼ˆä½å§¿ + æ–‡æœ¬ï¼‰
}
</code></pre>
<p><strong>ä¸¤è§£é€‰æ‹©ï¼ˆç›´è§‰ï¼‰</strong>ï¼š</p>
<ul>
<li>å…ˆçœ‹<strong>é‡æŠ•å½±è¯¯å·®</strong>ä¸ <strong>roll</strong>ï¼ˆå¤ªå·®çš„è§£ç›´æ¥æ”¾å¼ƒåˆ‡æ¢ï¼‰ï¼›</li>
<li>å†ç”¨<strong>ç¯æ¡åœ¨åƒé¢ä¸Šçš„æ•´ä½“å€¾æ–œ</strong>æ¥åˆ¤æ–­å½“å‰<strong>yaw çš„æ­£è´Ÿæ˜¯å¦â€œåˆç†â€</strong>ï¼Œå¿…è¦æ—¶å¯¹è°ƒè§£ã€‚</li>
</ul>
<hr />
<h3>4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ <code>BaSolver</code> / <code>GraphOptimizer</code></h3>
<p><strong>æ€æƒ³</strong>ï¼šåªæŠŠ<strong>è£…ç”² yaw</strong> å½“æˆä¼˜åŒ–å˜é‡ï¼ˆä¸€ä¸ªé¡¶ç‚¹ <code>VertexYaw</code>ï¼‰ï¼Œè£…ç”²çš„ 3D è§’ç‚¹ä¸ºå›ºå®šé¡¶ç‚¹ã€‚è§‚æµ‹ä¸ºæ¯ä¸ªè§’ç‚¹åœ¨å›¾åƒé‡Œçš„åƒç´ ä½ç½®ï¼Œè¯¯å·®å°±æ˜¯<strong>è§‚æµ‹åƒç´ </strong>å‡å»<strong>æŠ•å½±åƒç´ </strong>ã€‚è¿™æ · BA æ—¢è½»é‡åˆèƒ½ç¨³ä½å§¿æ€ã€‚</p>
<p><strong>æ„å›¾ä¸ä¼˜åŒ–</strong></p>
<pre><code>// å¡«å›¾ï¼šä¸€ä¸ª yaw é¡¶ç‚¹ + å››ä¸ªå›ºå®šçš„ 3D é¡¶ç‚¹ + å››æ¡æŠ•å½±è¯¯å·®è¾¹ï¼ˆå¸¦ Huber é²æ£’æ ¸ï¼‰
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&gt;setVertex(0, v_yaw); e-&gt;setVertex(1, vp);
  e-&gt;setMeasurement(pixel_observation);
  e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
</code></pre>
<pre><code>// è‡ªå®šä¹‰é¡¶ç‚¹å¢é‡ï¼šåœ¨ SO3 ä¸Šç”¨æä»£æ•°æ›´æ–° yawï¼Œé¿å…è§’åº¦è·³å˜
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
</code></pre>
<pre><code>// æŠ•å½±è¾¹è¯¯å·®ï¼šåƒç´ è§‚æµ‹ - æŠ•å½±(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&lt;VertexYaw*&gt;(_vertices[0])-&gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&lt;2&gt;();
  _error = obs - proj;
}
</code></pre>
<hr />
<h3>4.6 ROS2 èŠ‚ç‚¹ <code>ArmorDetectorNode</code></h3>
<p><strong>èŒè´£</strong>ï¼šæŠŠæ£€æµ‹ â†’ åˆ†ç±» â†’ï¼ˆå¯é€‰ï¼‰è§’ç‚¹ä¿®æ­£ â†’ PnP/BA â†’ å‘å¸ƒå¯è§†åŒ–ï¼Œå…¨æµç¨‹åœ¨ ROS2 ä¸­è·‘èµ·æ¥ã€‚è´Ÿè´£ï¼šå‚æ•°ã€è®¢é˜…/å‘å¸ƒã€TFã€è°ƒè¯•ã€‚</p>
<p><strong>èŠ‚ç‚¹åˆå§‹åŒ–ï¼ˆèŠ‚é€‰ï¼‰</strong></p>
<pre><code>// è¯»å–å‚æ•°ï¼Œåˆå§‹åŒ– Detectorã€NumberClassifierã€LightCornerCorrector
int binary_thres = declare_parameter("binary_thres", 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&lt;Detector&gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/lenet.onnx");
auto label_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/label.txt");
double threshold = declare_parameter("classifier_threshold", 0.7);
auto ignores = declare_parameter&lt;std::vector&lt;std::string&gt;&gt;("ignore_classes", {"negative"});
detector_-&gt;classifier = std::make_unique&lt;NumberClassifier&gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter("use_pca", true);
if (use_pca) detector_-&gt;corner_corrector = std::make_unique&lt;LightCornerCorrector&gt;();
</code></pre>
<p><strong>å›¾åƒå›è°ƒï¼ˆèŠ‚é€‰ï¼‰</strong></p>
<pre><code>// 1) TF: odom â†’ ç›¸æœºçš„æ—‹è½¬çŸ©é˜µï¼ˆIMUâ†’Cameraï¼‰
auto odom_to_cam = tf2_buffer_-&gt;lookupTransform(odom_frame_, img_msg-&gt;header.frame_id, img_msg-&gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) æ£€æµ‹ + åˆ†ç±» + è§’ç‚¹ä¿®æ­£
auto armors = detector_-&gt;detect(cv_bridge::toCvShare(img_msg, "rgb8")-&gt;image);

// 3) PnP/BA æå–ä½å§¿
armors_msg_.armors = armor_pose_estimator_-&gt;extractArmorPoses(armors, imu_to_camera);

// 4) å¯è§†åŒ–ä¸å‘å¸ƒï¼šMarker / è°ƒè¯•å›¾åƒ / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&gt;publish(armors_msg_);
</code></pre>
<hr />
<h2>å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰</h2>
<ul>
<li><code>binary_thres</code>ï¼šé˜ˆå€¼é«˜â†’å™ªç‚¹å°‘ä½†ç¯æ¡å¯èƒ½æ–­ï¼›é˜ˆå€¼ä½â†’è¿é€šåŸŸç²˜è¿ã€‚å…ˆæ‰“å¼€è°ƒè¯•å›¾åƒè¯é¢˜è§‚å¯Ÿå†è°ƒã€‚</li>
<li><code>light.min_ratio / max_ratio / max_angle</code>ï¼šæ§åˆ¶ç¯æ¡çš„â€œç»†é•¿â€å’Œâ€œè¿‘å‚ç›´â€ç¨‹åº¦ï¼›è¯¯æ£€å¤šå°±æ”¶ç´§ï¼Œæ¼æ£€å¤šå°±æ”¾å®½ã€‚</li>
<li><code>light.color_diff_thresh</code>ï¼šè¶Šå¤§è¶Šâ€œä¿å®ˆâ€åœ°åˆ¤æ–­é¢œè‰²ï¼›å¤ªå°ä¼šæŠŠæ‚æ•£å…‰å½“æˆçº¢/è“ã€‚</li>
<li><code>armor.*_center_distance</code>ï¼šä¸¤ç¯æ¡ä¸­å¿ƒè·çª—å£ï¼›ä¸ç„¦è·/è·ç¦»æœ‰å…³ï¼Œé•œå¤´å˜åŒ–åè¦é‡è°ƒã€‚</li>
<li><code>classifier_threshold / ignore_classes</code>ï¼šåˆ†ç±»é˜ˆå€¼ä¸å¿½ç•¥ç±»ï¼Œå…ˆæ¾åç´§ï¼Œç»“åˆå®æµ‹æ··æ·†å†æ”¶æ•›ã€‚</li>
<li><code>use_pca</code>ï¼šè§’ç‚¹ä¿®æ­£ï¼Œå™ªå£°ç¯å¢ƒæˆ–åˆ†è¾¨ç‡ä¸é«˜æ—¶å¸¸æœ‰å¸®åŠ©ã€‚</li>
<li><code>use_ba</code>ï¼šè½»é‡çš„ yaw ä¼˜åŒ–ï¼Œèƒ½å‡æŠ–ã€ç¨³å§¿æ€ï¼›ä½†åœ¨æç«¯è§†è§’ä¸‹å¯èƒ½æ”¶ç›Šæœ‰é™ã€‚</li>
</ul>
<hr />
<h2>å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–</h2>
<ol>
<li><strong>å‡†å¤‡</strong>ï¼šç›¸æœºè¯é¢˜ <code>image_raw</code>ã€<code>camera_info</code>ï¼Œå¹¶ç¡®è®¤ TF é“¾è·¯ï¼ˆ<code>odom â†’ camera</code>ï¼‰ã€‚</li>
<li><strong>å¯åŠ¨èŠ‚ç‚¹</strong>ï¼šåŠ è½½å‚æ•°ï¼ˆä¸Šé¢æåˆ°çš„é˜ˆå€¼ä¸çª—å£ï¼‰å¹¶æ‰“å¼€ <code>debug</code>ã€‚</li>
<li><strong>RViz</strong>ï¼šæ·»åŠ  <code>MarkerArray</code> è®¢é˜… <code>armor_detector/marker</code>ï¼›æŠŠè°ƒè¯•å›¾åƒè¯é¢˜ï¼ˆ<code>binary_img/number_img/result_img</code>ï¼‰ä¹Ÿå¼€å‡ºæ¥ã€‚</li>
<li><strong>è§‚å¯Ÿä¸è°ƒæ•´</strong>ï¼š
<ul>
<li>å…ˆè®©<strong>ç¯æ¡å€™é€‰</strong>ç¨³å®š â†’ å†çœ‹<strong>é…å¯¹</strong>æ˜¯å¦åˆç† â†’ æœ€åçœ‹<strong>æ•°å­—åˆ†ç±»</strong>ä¸<strong>ä½å§¿</strong>æ˜¯å¦ç¨³å®šã€‚</li>
<li>é€é¡¹å¾®è°ƒå‚æ•°ï¼Œè®°å½•æ¯é¡¹è°ƒæ•´å¯¹å¬å›/ç²¾åº¦çš„å½±å“ã€‚</li>
</ul>
</li>
</ol>
<hr />
<h2>å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯</h2>
<ul>
<li><strong>ç¯æ¡â€œå¤¹ç¯â€/è¯¯é…å¯¹</strong>ï¼šæ£€æŸ¥ <code>containLight</code> è§„åˆ™ä¸æ•°å­—/çº¢ç‚¹å®½åº¦è¿‡æ»¤ï¼›é€‚å½“æé«˜ <code>color_diff_thresh</code>ã€‚</li>
<li><strong>åˆ†ç±»ä¸ç¨³</strong>ï¼šå¯¹æ¯” <code>number_img</code> æ˜¯å¦å¹²å‡€ï¼›æ£€æŸ¥ ROI å®½åº¦æ˜¯å¦ä¸å¤§/å°è£…ç”²ä¸€è‡´ï¼›é€‚å½“è°ƒé˜ˆå€¼æˆ–å¿½ç•¥ç±»ã€‚</li>
<li><strong>ä½å§¿â€œç¿»é¢â€</strong>ï¼šç†è§£ <code>sortPnPResult</code> çš„é€‰æ‹©é€»è¾‘ï¼ˆè¯¯å·®ã€rollã€ç¯æ¡å€¾è§’ä¸ yaw æ­£è´Ÿï¼‰ï¼Œå¿…è¦æ—¶åœ¨è¿‘æ™¯è´´çº¸çº¹ç†ä¸Šåšè¾…åŠ©ã€‚</li>
<li><strong>å§¿æ€æŠ–åŠ¨</strong>ï¼šå¼€å¯ <code>use_ba</code>ï¼›æˆ–åœ¨ <code>LightCornerCorrector</code> ä¸­åŠ å¤§å€™é€‰æ¡æ•°ã€‚</li>
</ul>
<hr />
<h2>è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰</h2>
<ol>
<li><strong>æŠŠé˜ˆå€¼æ”¹æˆè‡ªé€‚åº”</strong>ï¼šå°è¯• <code>cv::adaptiveThreshold</code> æˆ–æ ¹æ®åŒºåŸŸäº®åº¦åŠ¨æ€è°ƒ <code>binary_thres</code>ã€‚</li>
<li><strong>åŠ å…¥æ—¶åºç¨³å®š</strong>ï¼šåœ¨ <code>Detector</code> è¾“å‡ºä¸Šåšè·Ÿè¸ªï¼ˆKalman/åŒˆç‰™åˆ©åŒ¹é…ï¼‰ï¼Œè®©æ•°å­—ä¸å§¿æ€åœ¨å¸§é—´æ›´ç¨³ã€‚</li>
<li><strong>æ•°æ®å¢å¼ºä¸å†è®­ç»ƒ</strong>ï¼šå¯¹ <code>number_img</code> åšéšæœºä»¿å°„/å™ªå£°å¢å¼ºï¼Œå¾®è°ƒ ONNX æ¨¡å‹ï¼Œè§‚å¯Ÿæ··æ·†ç±»çš„æ”¹å–„ã€‚</li>
<li><strong>å¤šç›®æ ‡é€‰æ‹©ç­–ç•¥</strong>ï¼šå½“åŒå±å¤šå—è£…ç”²æ—¶ï¼ŒåŸºäº <code>distance_to_image_center</code>ã€ç½®ä¿¡åº¦æˆ–å†å² ID é€‰æ‹©ç›®æ ‡ã€‚</li>
</ol>
<hr />
<h2>æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„</h2>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>è§†é¢‘æµ‹è¯•</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>è§†é¢‘æµ‹è¯•ã€‚</summary>
    <content type="html"><![CDATA[<p>è¿™æ˜¯è§†é¢‘æµ‹è¯•</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="æµ‹è¯•"></category>
  </entry>
</feed>