<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南叶の小窝</title>
  <subtitle>欢迎来玩awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-11-05T07:59:21.303Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>递归，分治</title>
    <link href="https://www.nanye404.top/posts/digui/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/digui/</id>
    <published>2025-11-05T00:00:00.000Z</published>
    <updated>2025-11-05T00:00:00.000Z</updated>
    <summary>递归，分治</summary>
    <content type="html"><![CDATA[<h2>递归</h2>
<ul>
<li>递归其实很好理解，类比于数学数列的递推，或者说数学归纳法</li>
<li>用cpp的语言来说就是函数不断地调用自身</li>
<li>递归的核心思想就是把原问题分解成重复的子问题，也就是分治</li>
<li>比如怎么排序，一种方法是先排左后排右，至于怎么排，就再执行前面一句话（这也是一种重要的排序方式，即快速排序）</li>
</ul>
<h2>为什么用递归？</h2>
<ul>
<li>代码简简洁，可读性强</li>
<li>更利于维护和调试</li>
</ul>
<h2>分治</h2>
<ul>
<li>上面也说了，分治思想就是把原问题分解成重复的子问题</li>
<li>分治的流程就是 分解-&gt;解决-&gt;合并</li>
</ul>
<hr />
<ul>
<li>注意，分治是思维方式，递归是实现方法，分治很大程度都是基于递归的</li>
</ul>
<h2>快速排序</h2>
<ul>
<li>下面我将用最基本的快速排序讲解递归和分治</li>
<li>快排的基本原理就是上面的例子，不断的二分分解，排序，然后合并</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>前缀和</title>
    <link href="https://www.nanye404.top/posts/pre/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/pre/</id>
    <published>2025-11-04T00:00:00.000Z</published>
    <updated>2025-11-04T00:00:00.000Z</updated>
    <summary>前缀和</summary>
    <content type="html"><![CDATA[<ul>
<li>基本的代码</li>
</ul>
<pre><code>  vector&lt;int&gt; pre(n + 1, 0);
    for (int i = 0; i &lt; n; i++) {
        pre[i + 1] = pre[i] + o[i];
    }
</code></pre>
<ul>
<li>主要是在O（1）用来算一段区间的和</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>哈希表</title>
    <link href="https://www.nanye404.top/posts/map/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/map/</id>
    <published>2025-11-03T00:00:00.000Z</published>
    <updated>2025-11-03T00:00:00.000Z</updated>
    <summary>哈希表的基础知识</summary>
    <content type="html"><![CDATA[<h2>哈希表的基本原理</h2>
<ul>
<li>哈希表就是一个加强版的数组</li>
<li>可以用过<code>key</code>在O(1)的时间复杂度查找到对应的<code>value</code></li>
<li><code>key</code>可以是数字或字符串</li>
<li>相比于数组，哈希表在日常的使用更加广泛，比如通讯录就可以理解成一个哈希表</li>
<li>下面用代码实现一个哈希表</li>
</ul>
<pre><code>class MyHashMap {

private:
    vector&lt;void*&gt; table;//表示任意类型的指针

public:
    // 增/改，复杂度 O(1)
    void put(auto key, auto value) {
        int index = hash(key);
        table[index] = value;
    }

    // 查，复杂度 O(1)
    auto get(auto key) {
        int index = hash(key);
        return table[index];
    }

    // 删，复杂度 O(1)
    void remove(auto key) {
        int index = hash(key);
        table[index] = nullptr;
    }

private:
    // 哈希函数，把 key 转化成 table 中的合法索引
    // 时间复杂度必须是 O(1)，才能保证上述方法的复杂度都是 O(1)
    int hash(auto key) {
        // ...
    }
};
</code></pre>
<hr />
<h3>注意</h3>
<ul>
<li><code>key</code> 是唯一的，<code>value</code> 可以重复</li>
</ul>
<h2>哈希冲突</h2>
<ul>
<li>
<p>如果两个不同的 <code>key</code> 通过哈希函数得到了相同的索引,这种情况就叫做「哈希冲突」。</p>
</li>
<li>
<p>哈希冲突不可能避免，只能在算法层面妥善处理出现哈希冲突的情况。</p>
</li>
<li>
<p>哈希冲突是一定会出现的，因为这个 hash 函数相当于是把一个无穷大的空间映射到了一个有限的索引空间，所以必然会有不同的 key 映射到同一个索引上。</p>
</li>
<li>
<p>有两种常见的解决方法，一种是拉链法，另一种是线性探查法（也经常被叫做开放寻址法）。</p>
<ul>
<li>拉链法简单来说就是让哈希表储存的是一个链表，每有一个新的就加上去</li>
<li>而线性探查法的思路是，一个 <code>key</code> 发现算出来的 <code>index</code> 值已经被别的 <code>key</code> 占了，那么它就去 <code>index + 1</code> 的位置看看，如果还是被占了，就继续往后找，直到找到一个空的位置为止。</li>
</ul>
</li>
<li>
<p>拉链法和线性探查法虽然能解决哈希冲突的问题，但是它们会导致性能下降。</p>
<ul>
<li>
<p>比如拉链法，你算出来 <code>index = hash(key)</code> 这个索引了，结果过去查出来的是个链表，你还得遍历一下这个链表，才能在里面找到你要的 value。这个过程的时间复杂度是 O(n)</p>
</li>
<li>
<p>线性探查法也是类似的，你算出来 <code>index = hash(key)</code> 这个索引了，你去这个索引位置查看，发现存储的不是要找的 <code>key</code>，但由于线性探查法解决哈希冲突的方式，你并不能确定这个 <code>key</code> 真的不存在，你必须顺着这个索引往后找，直到找到一个空的位置或者找到这个 <code>key</code> 为止，这个过程的时间复杂度也是 O(n)</p>
</li>
</ul>
</li>
<li>
<p>为了避免哈希冲突（也就是哈希表被塞太满），就有了<strong>负载因子</strong></p>
</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 05灯条配对</title>
    <link href="https://www.nanye404.top/posts/armor_detection_part1/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor_detection_part1/</id>
    <published>2025-10-26T00:00:00.000Z</published>
    <updated>2025-10-26T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::norm()</code></td>
<td>计算两点距离</td>
</tr>
<tr>
<td><code>std::abs()</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>cv::line()</code></td>
<td>绘制直线</td>
</tr>
<tr>
<td><code>cv::rectangle()</code></td>
<td>绘制矩形</td>
</tr>
<tr>
<td><code>cv::putText()</code></td>
<td>绘制文字</td>
</tr>
</tbody>
</table>
<hr />
<h2>装甲板的四大判据</h2>
<table>
<thead>
<tr>
<th>判据</th>
<th>物理意义</th>
<th>合理范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>距离</td>
<td>两灯条中心间距</td>
<td>1.5~4倍灯条长度</td>
</tr>
<tr>
<td>角度差</td>
<td>两灯条是否平行</td>
<td>&lt; 10°</td>
</tr>
<tr>
<td>长度比</td>
<td>两灯条长度比</td>
<td>1.0~2.0</td>
</tr>
<tr>
<td>高度差</td>
<td>两灯条y坐标差</td>
<td>&lt; 0.5倍灯条长度</td>
</tr>
</tbody>
</table>
<hr />
<h2>1️ 距离判断：cv::norm()</h2>
<h3>计算两点欧氏距离</h3>
<pre><code>cv::Point2f p1(100, 200);
cv::Point2f p2(400, 500);

double distance = cv::norm(p1 - p2);

</code></pre>
<h3>应用：计算灯条间距</h3>
<pre><code>// 两个灯条的中心点
cv::Point2f center1 = bar1.rect.center;
cv::Point2f center2 = bar2.rect.center;

// 计算距离-
float distance = cv::norm(center1 - center2);

// 判断距离是否合理（参数随便给的）
float avgLength = (bar1.rect.size.height + bar2.rect.size.height) / 2;
if (distance &lt; avgLength * 1.5 || distance &gt; avgLength * 4.0) {
    // 距离不合理，不是装甲板
    return false;
}
</code></pre>
<hr />
<h2>2️ 角度差判断</h2>
<h3>基础用法</h3>
<pre><code>float angle1 = bar1.rect.angle;
float angle2 = bar2.rect.angle;

// 计算角度差的绝对值
float angleDiff = std::abs(angle1 - angle2);

// 判断是否平行
if (angleDiff &gt; 10.0) {
    // 角度差太大，不平行
    return false;
}
</code></pre>
<h3>角度差的陷阱</h3>
<pre><code>// 问题：OpenCV的angle范围是-90°到0°
// 如果一个灯条angle=-5°，另一个是-85°
// 直接相减：|-5 - (-85)| = 80°  实际上它们可能是平行的！

// 解决方案：归一化角度
float normalizeAngle(float angle) {
    // 将angle转换到0-90范围
    angle = std::abs(angle);
    if (angle &gt; 90) angle = 180 - angle;
    return angle;
}

float angle1 = normalizeAngle(bar1.rect.angle);
float angle2 = normalizeAngle(bar2.rect.angle);
float angleDiff = std::abs(angle1 - angle2);
</code></pre>
<hr />
<h2>3️ 长度比判断</h2>
<h3>基础用法</h3>
<pre><code>float length1 = bar1.rect.size.height;  // 假设已确保height是长边
float length2 = bar2.rect.size.height;

// 计算长度比（大/小）
float lengthRatio = std::max(length1, length2) / std::min(length1, length2);

// 判断
if (lengthRatio &gt; 2.0) {
    // 长度相差超过2倍，不是装甲板
    return false;
}
</code></pre>
<hr />
<h2>4️ 高度差判断</h2>
<h3>基础用法</h3>
<pre><code>float centerY1 = bar1.rect.center.y;
float centerY2 = bar2.rect.center.y;

// 计算y坐标差的绝对值
float heightDiff = std::abs(centerY1 - centerY2);

// 用平均长度作为参考
float avgLength = (bar1.rect.size.height + bar2.rect.size.height) / 2;

// 判断高度差是否合理
if (heightDiff &gt; avgLength * 0.5) {
    // 高度差太大，不在同一水平线
    return false;
}
</code></pre>
<hr />
<h2>数据结构设计</h2>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// 灯条结构体
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar(const cv::RotatedRect&amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        
        // 确保长边是height
        if (r.size.width &gt; r.size.height) {
            angle += 90;
        }
    }
};

// 装甲板结构体
struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp; left, const LightBar&amp; right) 
        : leftBar(left), rightBar(right) {
        // 计算装甲板中心
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        
        // 计算宽高
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};
</code></pre>
<hr />
<h2>核心判断函数</h2>
<h3>归一化角度函数</h3>
<pre><code>// 归一化角度到0-90度范围
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &gt; 90) {
        angle = 180 - angle;
    }
    return angle;
}
</code></pre>
<h3>判断两个灯条能否组成装甲板</h3>
<pre><code>bool isValidArmorPair(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    // ============ 判据1：距离检查 ============
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 距离应该在1.5~4倍平均长度之间
    if (distance &lt; avgLength * 1.5) {
        std::cout &lt;&lt; " 距离太近: " &lt;&lt; distance 
                  &lt;&lt; " &lt; " &lt;&lt; avgLength * 1.5 &lt;&lt; std::endl;
        return false;
    }
    if (distance &gt; avgLength * 4.0) {
        std::cout &lt;&lt; " 距离太远: " &lt;&lt; distance 
                  &lt;&lt; " &gt; " &lt;&lt; avgLength * 4.0 &lt;&lt; std::endl;
        return false;
    }
    
    // ============ 判据2：角度检查 ============
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    
    // 角度差应小于10度
    if (angleDiff &gt; 10.0) {
        std::cout &lt;&lt; " 角度差太大: " &lt;&lt; angleDiff &lt;&lt; "°" &lt;&lt; std::endl;
        return false;
    }
    
    // ============ 判据3：长度比检查 ============
    float maxLength = std::max(bar1.length, bar2.length);
    float minLength = std::min(bar1.length, bar2.length);
    float lengthRatio = maxLength / minLength;
    
    // 长度比应小于2.0
    if (lengthRatio &gt; 2.0) {
        std::cout &lt;&lt; " 长度比过大: " &lt;&lt; lengthRatio &lt;&lt; std::endl;
        return false;
    }
    
    // ============ 判据4：高度差检查 ============
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    
    // 高度差应小于平均长度的50%
    if (heightDiff &gt; avgLength * 0.5) {
        std::cout &lt;&lt; " 高度差太大: " &lt;&lt; heightDiff 
                  &lt;&lt; " &gt; " &lt;&lt; avgLength * 0.5 &lt;&lt; std::endl;
        return false;
    }
    
    // ============ 通过所有判据 ============
    std::cout &lt;&lt; "[通过] 距离:" &lt;&lt; distance 
              &lt;&lt; " 角度差:" &lt;&lt; angleDiff 
              &lt;&lt; " 长度比:" &lt;&lt; lengthRatio 
              &lt;&lt; " 高度差:" &lt;&lt; heightDiff &lt;&lt; std::endl;
    return true;
}
</code></pre>
<hr />
<h2>配对主函数</h2>
<pre><code>// 从灯条列表中配对出所有装甲板
std::vector&lt;ArmorPlate&gt; findArmorPlates(const std::vector&lt;LightBar&gt;&amp; lightBars) {
    std::vector&lt;ArmorPlate&gt; armorPlates;
    
    std::cout &lt;&lt; "\n========== 开始配对 ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "灯条数量: " &lt;&lt; lightBars.size() &lt;&lt; std::endl;
    
    // 双重循环遍历所有灯条对
    for (size_t i = 0; i &lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &lt; lightBars.size(); j++) {
            const LightBar&amp; bar1 = lightBars[i];
            const LightBar&amp; bar2 = lightBars[j];
            
            std::cout &lt;&lt; "\n测试灯条对 (" &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; "):" &lt;&lt; std::endl;
            
            // 判断能否组成装甲板
            if (isValidArmorPair(bar1, bar2)) {
                // 确保左边的灯条在左侧
                if (bar1.center.x &lt; bar2.center.x) {
                    armorPlates.emplace_back(bar1, bar2);
                } else {
                    armorPlates.emplace_back(bar2, bar1);
                }
                std::cout &lt;&lt; " 找到装甲板！" &lt;&lt; std::endl;
            }
        }
    }
    
    std::cout &lt;&lt; "\n========== 配对完成 ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; "找到装甲板数量: " &lt;&lt; armorPlates.size() &lt;&lt; std::endl;
    
    return armorPlates;
}
</code></pre>
<hr />
<h2>可视化绘制函数</h2>
<h3>绘制单个装甲板</h3>
<pre><code>void drawArmorPlate(cv::Mat&amp; image, const ArmorPlate&amp; armor, int index) {
    // 1. 绘制左侧灯条（绿色）
    cv::Point2f vertices1[4];
    armor.leftBar.rect.points(vertices1);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(image, vertices1[i], vertices1[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 2. 绘制右侧灯条（绿色）
    cv::Point2f vertices2[4];
    armor.rightBar.rect.points(vertices2);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(image, vertices2[i], vertices2[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 3. 绘制连接线（黄色）
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    
    // 4. 绘制装甲板外框（蓝色）
    cv::Point2f topLeft = vertices1[0];
    cv::Point2f topRight = vertices2[1];
    cv::Point2f bottomRight = vertices2[2];
    cv::Point2f bottomLeft = vertices1[3];
    
    cv::line(image, topLeft, topRight, cv::Scalar(255, 0, 0), 2);
    cv::line(image, topRight, bottomRight, cv::Scalar(255, 0, 0), 2);
    cv::line(image, bottomRight, bottomLeft, cv::Scalar(255, 0, 0), 2);
    cv::line(image, bottomLeft, topLeft, cv::Scalar(255, 0, 0), 2);
    
    // 5. 绘制中心点（红色）
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 6. 显示装甲板信息
    std::string info = "Armor#" + std::to_string(index);
    cv::putText(image, info, 
                cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, 
                cv::Scalar(255, 255, 255), 2);
    
    // 7. 显示宽度信息
    std::string sizeInfo = "W:" + std::to_string((int)armor.width);
    cv::putText(image, sizeInfo, 
                cv::Point(armor.center.x - 25, armor.center.y + 5),
                cv::FONT_HERSHEY_SIMPLEX, 0.4, 
                cv::Scalar(255, 255, 255), 1);
}
</code></pre>
<h3>绘制所有装甲板</h3>
<pre><code>void drawAllArmorPlates(cv::Mat&amp; image, const std::vector&lt;ArmorPlate&gt;&amp; armorPlates) {
    for (size_t i = 0; i &lt; armorPlates.size(); i++) {
        drawArmorPlate(image, armorPlates[i], i);
    }
    
    // 在左上角显示统计信息
    std::string stats = "Armors: " + std::to_string(armorPlates.size());
    cv::putText(image, stats, cv::Point(10, 30),
                cv::FONT_HERSHEY_SIMPLEX, 1.0, 
                cv::Scalar(0, 255, 255), 2);
}
</code></pre>
<hr />
<h2>完整主函数</h2>
<pre><code>int main() {
    // 1. 读取图片
    cv::Mat src = cv::imread("armor_test.jpg");
    if (src.empty()) {
        std::cerr &lt;&lt; " 无法读取图片！" &lt;&lt; std::endl;
        return -1;
    }
    
    std::cout &lt;&lt; " 图片读取成功: " &lt;&lt; src.cols &lt;&lt; "x" &lt;&lt; src.rows &lt;&lt; std::endl;
    
    // 2. 预处理（这里假设你已经有灯条检测函数）
    std::vector&lt;LightBar&gt; lightBars = detectLightBars(src);
    
    std::cout &lt;&lt; " 检测到 " &lt;&lt; lightBars.size() &lt;&lt; " 个灯条" &lt;&lt; std::endl;
    
    // 3. 装甲板配对
    std::vector&lt;ArmorPlate&gt; armorPlates = findArmorPlates(lightBars);
    
    // 4. 绘制结果
    cv::Mat result = src.clone();
    drawAllArmorPlates(result, armorPlates);
    
    // 5. 显示和保存
    cv::imshow("原图", src);
    cv::imshow("装甲板检测结果", result);
    cv::imwrite("armor_result.jpg", result);
    
    std::cout &lt;&lt; "\n========== 最终结果 ==========" &lt;&lt; std::endl;
    std::cout &lt;&lt; " 成功检测到 " &lt;&lt; armorPlates.size() &lt;&lt; " 个装甲板" &lt;&lt; std::endl;
    std::cout &lt;&lt; "结果已保存到 armor_result.jpg" &lt;&lt; std::endl;
    
    cv::waitKey(0);
    return 0;
}
</code></pre>
<hr />
<h2>完整可运行示例</h2>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

// ========== 数据结构 ==========
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar() : length(0), angle(0) {}
    
    LightBar(const cv::RotatedRect&amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        if (r.size.width &gt; r.size.height) {
            angle += 90;
        }
    }
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp; left, const LightBar&amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};

// ========== 核心函数 ==========
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &gt; 90) angle = 180 - angle;
    return angle;
}

bool isValidArmorPair(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    if (distance &lt; avgLength * 1.5 || distance &gt; avgLength * 4.0) return false;
    
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    if (angleDiff &gt; 10.0) return false;
    
    float lengthRatio = std::max(bar1.length, bar2.length) / 
                        std::min(bar1.length, bar2.length);
    if (lengthRatio &gt; 2.0) return false;
    
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    if (heightDiff &gt; avgLength * 0.5) return false;
    
    return true;
}

std::vector&lt;ArmorPlate&gt; findArmorPlates(const std::vector&lt;LightBar&gt;&amp; lightBars) {
    std::vector&lt;ArmorPlate&gt; armorPlates;
    
    for (size_t i = 0; i &lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &lt; lightBars.size(); j++) {
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}

void drawArmorPlate(cv::Mat&amp; image, const ArmorPlate&amp; armor, int index) {
    cv::Point2f v1[4], v2[4];
    armor.leftBar.rect.points(v1);
    armor.rightBar.rect.points(v2);
    
    for (int i = 0; i &lt; 4; i++) {
        cv::line(image, v1[i], v1[(i+1)%4], cv::Scalar(0, 255, 0), 2);
        cv::line(image, v2[i], v2[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    std::string info = "Armor#" + std::to_string(index);
    cv::putText(image, info, cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 2);
}

// ========== 主函数 ==========
int main() {
    cv::Mat src = cv::imread("armor_test.jpg");
    if (src.empty()) {
        std::cerr &lt;&lt; "无法读取图片！" &lt;&lt; std::endl;
        return -1;
    }
    
    // 假设已有灯条检测函数
    // std::vector&lt;LightBar&gt; lightBars = detectLightBars(src);
    std::vector&lt;LightBar&gt; lightBars;  // 示例数据
    
    std::vector&lt;ArmorPlate&gt; armorPlates = findArmorPlates(lightBars);
    
    cv::Mat result = src.clone();
    for (size_t i = 0; i &lt; armorPlates.size(); i++) {
        drawArmorPlate(result, armorPlates[i], i);
    }
    
    std::cout &lt;&lt; "检测到 " &lt;&lt; armorPlates.size() &lt;&lt; " 个装甲板" &lt;&lt; std::endl;
    cv::imshow("结果", result);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h2>性能优化</h2>
<h3>优化1：提前剔除明显不合理的灯条对</h3>
<pre><code>// 快速预判（避免不必要的计算）
bool quickReject(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    // 如果x坐标差太小，肯定不是装甲板（两灯条重叠）
    float xDiff = std::abs(bar1.center.x - bar2.center.x);
    if (xDiff &lt; 10) return true;
    
    // 如果x坐标差太大，距离肯定超标
    float maxLength = std::max(bar1.length, bar2.length);
    if (xDiff &gt; maxLength * 5) return true;
    
    return false;
}

std::vector&lt;ArmorPlate&gt; findArmorPlatesOptimized(const std::vector&lt;LightBar&gt;&amp; lightBars) {
    std::vector&lt;ArmorPlate&gt; armorPlates;
    
    for (size_t i = 0; i &lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &lt; lightBars.size(); j++) {
            // 快速预判
            if (quickReject(lightBars[i], lightBars[j])) {
                continue;
            }
            
            // 详细判断
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}
</code></pre>
<h3>优化2：按x坐标排序（减少比较次数）</h3>
<pre><code>std::vector&lt;ArmorPlate&gt; findArmorPlatesSorted(std::vector&lt;LightBar&gt; lightBars) {
    // 按x坐标排序
    std::sort(lightBars.begin(), lightBars.end(), 
              [](const LightBar&amp; a, const LightBar&amp; b) {
                  return a.center.x &lt; b.center.x;
              });
    
    std::vector&lt;ArmorPlate&gt; armorPlates;
    
    for (size_t i = 0; i &lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &lt; lightBars.size(); j++) {
            // 如果j灯条的x坐标已经太远，后面的更远，直接break
            float xDiff = lightBars[j].center.x - lightBars[i].center.x;
            if (xDiff &gt; lightBars[i].length * 5) {
                break;
            }
            
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                armorPlates.emplace_back(lightBars[i], lightBars[j]);
            }
        }
    }
    
    return armorPlates;
}
</code></pre>
<hr />
<h2>进阶功能</h2>
<h3>处理倾斜装甲板</h3>
<p>当装甲板整体倾斜时，需要调整高度差判据：</p>
<pre><code>// 计算两灯条连线与水平线的夹角
float calculateTiltAngle(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    float dx = bar2.center.x - bar1.center.x;
    float dy = bar2.center.y - bar1.center.y;
    return std::atan2(dy, dx) * 180.0 / CV_PI;
}

// 改进的高度差判据
bool isValidArmorPair_Advanced(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    // ... 前面的判据 ...
    
    // 计算倾斜角度
    float tiltAngle = std::abs(calculateTiltAngle(bar1, bar2));
    
    // 如果倾斜角度大，放宽高度差要求
    float heightThreshold = avgLength * 0.5;
    if (tiltAngle &gt; 15.0) {
        heightThreshold = avgLength * 0.8;  // 放宽到0.8倍
    }
    
    if (heightDiff &gt; heightThreshold) {
        return false;
    }
    
    return true;
}
</code></pre>
<h3>区分大小装甲板</h3>
<p>根据宽高比区分大小装甲板：</p>
<pre><code>enum ArmorType {
    SMALL_ARMOR,  // 小装甲板
    LARGE_ARMOR   // 大装甲板
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    ArmorType type;  // 新增：装甲板类型
    
    ArmorPlate(const LightBar&amp; left, const LightBar&amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
        
        // 根据宽高比判断类型
        float aspectRatio = width / height;
        if (aspectRatio &gt; 3.0) {
            type = LARGE_ARMOR;  // 宽高比大，大装甲板
        } else {
            type = SMALL_ARMOR;  // 宽高比小，小装甲板
        }
    }
    
    std::string getTypeName() const {
        return (type == SMALL_ARMOR) ? "Small" : "Large";
    }
};

// 绘制时显示类型
void drawArmorPlate(cv::Mat&amp; image, const ArmorPlate&amp; armor, int index) {
    // ... 原来的绘制代码 ...
    
    // 显示类型
    std::string typeInfo = armor.getTypeName();
    cv::Scalar color = (armor.type == SMALL_ARMOR) ? 
                       cv::Scalar(0, 255, 0) : cv::Scalar(255, 0, 255);
    cv::putText(image, typeInfo, 
                cv::Point(armor.center.x - 30, armor.center.y + 20),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
}
</code></pre>
<h3>置信度评分系统</h3>
<p>给每个装甲板打分，选出最佳目标：</p>
<pre><code>struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    float confidence;  // 置信度 0-100
    
    ArmorPlate(const LightBar&amp; left, const LightBar&amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
        
        // 计算置信度
        confidence = calculateConfidence(left, right);
    }
    
private:
    float calculateConfidence(const LightBar&amp; bar1, const LightBar&amp; bar2) {
        float score = 100.0;
        
        // 1. 角度差越小越好（满分20）
        float angle1 = normalizeAngle(bar1.angle);
        float angle2 = normalizeAngle(bar2.angle);
        float angleDiff = std::abs(angle1 - angle2);
        float angleScore = std::max(0.0f, 20.0f - angleDiff * 2.0f);
        
        // 2. 长度比越接近1越好（满分20）
        float lengthRatio = std::max(bar1.length, bar2.length) / 
                           std::min(bar1.length, bar2.length);
        float lengthScore = std::max(0.0f, 20.0f - (lengthRatio - 1.0f) * 10.0f);
        
        // 3. 高度差越小越好（满分20）
        float avgLength = (bar1.length + bar2.length) / 2;
        float heightDiff = std::abs(bar1.center.y - bar2.center.y);
        float heightScore = std::max(0.0f, 20.0f - heightDiff / avgLength * 40.0f);
        
        // 4. 距离合理性（满分20）
        float distance = cv::norm(bar1.center - bar2.center);
        float idealDist = avgLength * 2.5;  // 理想距离
        float distDiff = std::abs(distance - idealDist);
        float distScore = std::max(0.0f, 20.0f - distDiff / avgLength * 10.0f);
        
        // 5. 面积大小（满分20）- 面积越大越好
        float area = width * height;
        float areaScore = std::min(20.0f, area / 10000.0f * 20.0f);
        
        score = angleScore + lengthScore + heightScore + distScore + areaScore;
        return std::min(100.0f, score);
    }
};

// 选择最佳装甲板
ArmorPlate selectBestArmor(const std::vector&lt;ArmorPlate&gt;&amp; armorPlates) {
    if (armorPlates.empty()) {
        throw std::runtime_error("没有装甲板可选择！");
    }
    
    // 找出置信度最高的装甲板
    auto bestArmor = std::max_element(armorPlates.begin(), armorPlates.end(),
        [](const ArmorPlate&amp; a, const ArmorPlate&amp; b) {
            return a.confidence &lt; b.confidence;
        });
    
    std::cout &lt;&lt; "最佳装甲板置信度: " &lt;&lt; bestArmor-&gt;confidence &lt;&lt; std::endl;
    return *bestArmor;
}

// 绘制时显示置信度
void drawArmorPlateWithConfidence(cv::Mat&amp; image, const ArmorPlate&amp; armor, int index) {
    // ... 原来的绘制代码 ...
    
    // 显示置信度
    std::string confInfo = "Conf:" + std::to_string((int)armor.confidence);
    cv::putText(image, confInfo, 
                cv::Point(armor.center.x - 30, armor.center.y + 20),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 0), 1);
}
</code></pre>
<hr />
<h2>实战技巧</h2>
<h3>动态参数调整</h3>
<p>根据距离动态调整判据：</p>
<pre><code>bool isValidArmorPair_Dynamic(const LightBar&amp; bar1, const LightBar&amp; bar2, 
                               float cameraDistance) {
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 根据相机距离调整参数
    float distanceMin, distanceMax, angleDiffMax;
    
    if (cameraDistance &lt; 3.0) {  // 近距离（3米内）
        distanceMin = avgLength * 2.0;
        distanceMax = avgLength * 3.5;
        angleDiffMax = 5.0;
    } else {  // 远距离（3米外）
        distanceMin = avgLength * 1.5;
        distanceMax = avgLength * 4.5;
        angleDiffMax = 12.0;
    }
    
    float distance = cv::norm(bar1.center - bar2.center);
    if (distance &lt; distanceMin || distance &gt; distanceMax) {
        return false;
    }
    
    // ... 其他判据 ...
    
    return true;
}
</code></pre>
<h3>处理边界情况</h3>
<pre><code>bool isValidArmorPair_Robust(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    // 检查输入有效性
    if (bar1.length &lt;= 0 || bar2.length &lt;= 0) {
        std::cerr &lt;&lt; "警告：灯条长度无效！" &lt;&lt; std::endl;
        return false;
    }
    
    if (bar1.center == bar2.center) {
        std::cerr &lt;&lt; "警告：两灯条中心重合！" &lt;&lt; std::endl;
        return false;
    }
    
    // 避免除零错误
    float minLength = std::min(bar1.length, bar2.length);
    if (minLength &lt; 1e-6) {
        return false;
    }
    
    // 正常判断流程...
    
    return true;
}
</code></pre>
<h3>帧稳定性检测</h3>
<pre><code>class ArmorTracker {
private:
    std::vector&lt;ArmorPlate&gt; historyArmors;  // 历史帧的装甲板
    const int HISTORY_SIZE = 5;  // 保持最近5帧
    
public:
    // 添加新帧的装甲板
    void addFrame(const std::vector&lt;ArmorPlate&gt;&amp; armors) {
        if (historyArmors.size() &gt;= HISTORY_SIZE) {
            historyArmors.erase(historyArmors.begin());
        }
        historyArmors.insert(historyArmors.end(), armors.begin(), armors.end());
    }
    
    // 获取稳定的装甲板（连续出现多帧）
    std::vector&lt;ArmorPlate&gt; getStableArmors() {
        // 统计每个位置出现的次数
        std::vector&lt;ArmorPlate&gt; stableArmors;
        
        // 实际应该实现位置聚类和计数
        // 这里简化处理
        
        return stableArmors;
    }
};
</code></pre>
<h3>参数调优助手</h3>
<p>创建滑动条实时调整参数：</p>
<pre><code>// 全局参数
int g_distanceMin = 15;  // 1.5 * 10
int g_distanceMax = 40;  // 4.0 * 10
int g_angleDiffMax = 10;
int g_lengthRatioMax = 20;  // 2.0 * 10
int g_heightDiffMax = 5;  // 0.5 * 10

void createParamWindow() {
    cv::namedWindow("参数调整");
    
    cv::createTrackbar("距离最小(x0.1)", "参数调整", &amp;g_distanceMin, 50);
    cv::createTrackbar("距离最大(x0.1)", "参数调整", &amp;g_distanceMax, 100);
    cv::createTrackbar("角度差最大", "参数调整", &amp;g_angleDiffMax, 30);
    cv::createTrackbar("长度比最大(x0.1)", "参数调整", &amp;g_lengthRatioMax, 50);
    cv::createTrackbar("高度差最大(x0.1)", "参数调整", &amp;g_heightDiffMax, 20);
}

bool isValidArmorPair_Tunable(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 使用全局参数
    float distanceMin = g_distanceMin / 10.0f * avgLength;
    float distanceMax = g_distanceMax / 10.0f * avgLength;
    
    if (distance &lt; distanceMin || distance &gt; distanceMax) {
        return false;
    }
    
    // ... 其他判据使用全局参数 ...
    
    return true;
}
</code></pre>
<hr />
<h2>完整代码示例（可直接运行）</h2>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// ========== 数据结构 ==========
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar() : length(0), angle(0) {}
    
    LightBar(const cv::RotatedRect&amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        if (r.size.width &gt; r.size.height) {
            angle += 90;
        }
    }
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp; left, const LightBar&amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};

// ========== 工具函数 ==========
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &gt; 90) {
        angle = 180 - angle;
    }
    return angle;
}

// ========== 核心判断 ==========
bool isValidArmorPair(const LightBar&amp; bar1, const LightBar&amp; bar2) {
    // 判据1：距离
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    if (distance &lt; avgLength * 1.5 || distance &gt; avgLength * 4.0) {
        return false;
    }
    
    // 判据2：角度
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    if (angleDiff &gt; 10.0) {
        return false;
    }
    
    // 判据3：长度比
    float lengthRatio = std::max(bar1.length, bar2.length) / 
                        std::min(bar1.length, bar2.length);
    if (lengthRatio &gt; 2.0) {
        return false;
    }
    
    // 判据4：高度差
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    if (heightDiff &gt; avgLength * 0.5) {
        return false;
    }
    
    return true;
}

// ========== 配对函数 ==========
std::vector&lt;ArmorPlate&gt; findArmorPlates(const std::vector&lt;LightBar&gt;&amp; lightBars) {
    std::vector&lt;ArmorPlate&gt; armorPlates;
    
    for (size_t i = 0; i &lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &lt; lightBars.size(); j++) {
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}

// ========== 可视化 ==========
void drawArmorPlate(cv::Mat&amp; image, const ArmorPlate&amp; armor, int index) {
    // 绘制左侧灯条
    cv::Point2f v1[4];
    armor.leftBar.rect.points(v1);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(image, v1[i], v1[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制右侧灯条
    cv::Point2f v2[4];
    armor.rightBar.rect.points(v2);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(image, v2[i], v2[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制连接线
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    
    // 绘制中心点
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 显示信息
    std::string info = "Armor#" + std::to_string(index);
    cv::putText(image, info, 
                cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, 
                cv::Scalar(255, 255, 255), 2);
}

// ========== 主函数 ==========
int main() {
    // 读取图片
    cv::Mat src = cv::imread("armor_test.jpg");
    if (src.empty()) {
        std::cerr &lt;&lt; "无法读取图片！" &lt;&lt; std::endl;
        return -1;
    }
    
    // 这里需要调用之前的灯条检测函数
    // std::vector&lt;LightBar&gt; lightBars = detectLightBars(src);
    
    // 示例：手动创建测试数据
    std::vector&lt;LightBar&gt; lightBars;
    // TODO: 添加测试灯条
    
    // 装甲板配对
    std::vector&lt;ArmorPlate&gt; armorPlates = findArmorPlates(lightBars);
    
    // 绘制结果
    cv::Mat result = src.clone();
    for (size_t i = 0; i &lt; armorPlates.size(); i++) {
        drawArmorPlate(result, armorPlates[i], i);
    }
    
    // 显示
    std::cout &lt;&lt; "检测到 " &lt;&lt; armorPlates.size() &lt;&lt; " 个装甲板" &lt;&lt; std::endl;
    cv::imshow("结果", result);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 03 形态学处理</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_03/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_03/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::getStructuringElement()</code></td>
<td>创建形态学核</td>
</tr>
<tr>
<td><code>cv::dilate()</code></td>
<td>膨胀（变胖）</td>
</tr>
<tr>
<td><code>cv::erode()</code></td>
<td>腐蚀（变瘦）</td>
</tr>
<tr>
<td><code>cv::morphologyEx()</code></td>
<td>高级形态学</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<p>颜色提取后的二值图有两个主要问题：</p>
<h3>问题1: 噪点（小白点到处都是）</h3>
<h3>问题2: 断裂（灯条中间有缝隙）</h3>
<p><strong>形态学操作就是解决这些问题的工具！</strong></p>
<hr />
<h2>形态学四种处理方式</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>效果</th>
<th>比喻</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>膨胀 dilate</strong></td>
<td>白色区域变大</td>
<td>涂胖笔</td>
<td>连接断裂</td>
</tr>
<tr>
<td><strong>腐蚀 erode</strong></td>
<td>白色区域变小</td>
<td>橡皮擦</td>
<td>去除噪点</td>
</tr>
<tr>
<td><strong>开运算 open</strong></td>
<td>先腐蚀后膨胀</td>
<td>先擦后涂</td>
<td>去噪保形</td>
</tr>
<tr>
<td><strong>闭运算 close</strong></td>
<td>先膨胀后腐蚀</td>
<td>先涂后擦</td>
<td>填缝保形</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::getStructuringElement() - 创建形态学核</h2>
<h3>核形状类型</h3>
<table>
<thead>
<tr>
<th>shape</th>
<th>说明</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_RECT</code></td>
<td>矩形（最常用）</td>
<td>各方向均匀</td>
</tr>
<tr>
<td><code>MORPH_ELLIPSE</code></td>
<td>椭圆形</td>
<td>边缘更圆滑</td>
</tr>
<tr>
<td><code>MORPH_CROSS</code></td>
<td>十字形</td>
<td>只作用于上下左右</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>// 创建3×3矩形核
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
// 创建5×5椭圆核
cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
// 创建7×7十字核
cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(7, 7));
</code></pre>
<h3>核大小如何选择？</h3>
<table>
<thead>
<tr>
<th>尺寸</th>
<th>效果</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>3×3</td>
<td>轻微处理</td>
<td>小噪点、细微缝隙</td>
</tr>
<tr>
<td>5×5</td>
<td>中等效果</td>
<td><strong>推荐</strong>，平衡效果和性能</td>
</tr>
<tr>
<td>7×7</td>
<td>强力效果</td>
<td>大噪点、大缝隙（可能破坏灯条形状）</td>
</tr>
<tr>
<td>9×9+</td>
<td>极强效果</td>
<td>慎用！容易把灯条变形</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. cv::dilate() - 膨胀操作</h2>
<h3>函数原型</h3>
<pre><code>void cv::dilate(InputArray src, OutputArray dst, InputArray kernel,
                Point anchor = Point(-1,-1), int iterations = 1);
</code></pre>
<h3>参数说明</h3>
<ul>
<li><code>src</code>  输入二值图</li>
<li><code>dst</code>  输出结果</li>
<li><code>kernel</code>  形态学核</li>
<li><code>anchor</code>  锚点位置（-1,-1表示中心）</li>
<li><code>iterations</code>  迭代次数（重复膨胀几次）</li>
</ul>
<h3>基础用法</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 腐蚀一次
cv::Mat eroded;
cv::erode(binary, eroded, kernel);

</code></pre>
<h3>应用场景</h3>
<ul>
<li>去除小噪点</li>
<li>分离粘连物体</li>
</ul>
<h3>腐蚀的副作用</h3>
<ul>
<li>灯条也会变细</li>
<li>解决方案：腐蚀后再膨胀回来（开运算）</li>
</ul>
<hr />
<h2>4. cv::morphologyEx() - 高级形态学操作</h2>
<h3>操作类型</h3>
<table>
<thead>
<tr>
<th>op</th>
<th>操作</th>
<th>公式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_OPEN</code></td>
<td>开运算</td>
<td>erode → dilate</td>
<td><strong>去噪保形</strong></td>
</tr>
<tr>
<td><code>MORPH_CLOSE</code></td>
<td>闭运算</td>
<td>dilate → erode</td>
<td><strong>填缝保形</strong></td>
</tr>
<tr>
<td><code>MORPH_GRADIENT</code></td>
<td>形态学梯度</td>
<td>dilate - erode</td>
<td>提取边缘</td>
</tr>
<tr>
<td><code>MORPH_TOPHAT</code></td>
<td>顶帽</td>
<td>src - open</td>
<td>提取小亮点</td>
</tr>
<tr>
<td><code>MORPH_BLACKHAT</code></td>
<td>黑帽</td>
<td>close - src</td>
<td>提取小暗点</td>
</tr>
</tbody>
</table>
<hr />
<h2>5. 闭运算 (MORPH_CLOSE)</h2>
<h3>基础用法</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
// 闭运算
cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);

</code></pre>
<h3>应用场景</h3>
<ul>
<li>连接灯条的细微断裂</li>
<li>填补灯条内部的小黑洞</li>
<li>保持灯条的整体形状</li>
</ul>
<h3>注意事项</h3>
<pre><code>// 核太大会让两个灯条粘在一起！
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
//  可能导致左右灯条合并

// 推荐使用5×5或7×7
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
</code></pre>
<hr />
<h2>6. 开运算 (MORPH_OPEN) - 去噪利器</h2>
<h3>基础用法</h3>
<pre><code>cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 开运算
cv::Mat opened;
cv::morphologyEx(binary, opened, cv::MORPH_OPEN, kernel);
</code></pre>
<h3>应用场景</h3>
<ul>
<li>去除小噪点</li>
<li>分离轻微粘连的物体</li>
<li>平滑物体边缘</li>
</ul>
<hr />
<h2>7. RM装甲板识别推荐流程</h2>
<h3>标准流程（两步法）</h3>
<pre><code>cv::Mat processArmor(const cv::Mat&amp; img) {
    // 1. 颜色提取
    cv::Mat binary = extractColor(img); 
    // 2. 形态学处理
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    // 第一步：闭运算（填补灯条缝隙）
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    // 第二步：开运算（去除噪点）
    cv::Mat result;
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    return result;
}
</code></pre>
<hr />
<h2>8. 形态学梯度 (MORPH_GRADIENT)</h2>
<h3>基础用法</h3>
<pre><code>cv::Mat gradient;
cv::morphologyEx(binary, gradient, cv::MORPH_GRADIENT, kernel);
</code></pre>
<h3>效果</h3>
<p>提取物体的<strong>外轮廓线</strong>，类似边缘检测</p>
<h3>应用场景</h3>
<ul>
<li>能量机关扇叶边缘检测</li>
<li>装甲板外框提取（不常用）</li>
</ul>
<hr />
<h2>完整实战代码</h2>
<h3>方案1: 快速版（单次操作）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学核
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 闭运算（最常用）
    cv::Mat result;
    cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
    
    // 显示对比
    cv::imshow("原始二值图", binary);
    cv::imshow("形态学处理后", result);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>方案2: 标准版（两步法）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat morphologyProcess(const cv::Mat&amp; binary) {
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 第一步：闭运算填缝
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // 第二步：开运算去噪
    cv::Mat opened;
    cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
    
    return opened;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat binary = extractColor(img);
    
    cv::Mat result = morphologyProcess(binary);
    
    // 显示三步对比
    cv::imshow("1-原始", binary);
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, 
                     cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5)));
    cv::imshow("2-闭运算", closed);
    cv::imshow("3-最终结果", result);
    
    cv::waitKey(0);
    return 0;
}
</code></pre>
<h3>方案3: 自适应版（根据图像大小调整核）</h3>
<pre><code>cv::Mat adaptiveMorphology(const cv::Mat&amp; binary) {
    // 根据图像大小自适应核尺寸
    int kernelSize = std::max(3, (int)(binary.cols * 0.005));
    if (kernelSize % 2 == 0) kernelSize++;  // 确保是奇数
    
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                               cv::Size(kernelSize, kernelSize));
    
    cv::Mat closed, result;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    std::cout &lt;&lt; "使用核尺寸: " &lt;&lt; kernelSize &lt;&lt; "×" &lt;&lt; kernelSize &lt;&lt; std::endl;
    return result;
}
</code></pre>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 02 装甲板颜色提取</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_02/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_02/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::split()</code></td>
<td>分离BGR通道</td>
</tr>
<tr>
<td><code>cv::cvtColor()</code></td>
<td>颜色空间转换</td>
</tr>
<tr>
<td><code>cv::inRange()</code></td>
<td>颜色范围筛选</td>
</tr>
<tr>
<td><code>cv::threshold()</code></td>
<td>简单阈值二值化</td>
</tr>
<tr>
<td><code>cv::subtract()</code></td>
<td>通道相减</td>
</tr>
<tr>
<td><code>cv::bitwise_or/and()</code></td>
<td>位运算组合mask</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<p>装甲板的灯条有两个特点：</p>
<ol>
<li><strong>特定颜色</strong>（红色或蓝色）</li>
<li><strong>高亮度</strong>（灯条是发光的）</li>
</ol>
<h3>通道相减法</h3>
<ul>
<li><strong>原理</strong>: BGR图像中，红色区域R通道值高、B通道值低，相减后红色凸显</li>
<li><strong>优点</strong>: 速度极快（1-2ms），实时性好</li>
<li><strong>缺点</strong>: 易受环境光干扰，需要后续强筛选</li>
<li><strong>适用</strong>: 比赛实战、光照稳定环境</li>
</ul>
<h3>HSV筛选法</h3>
<ul>
<li><strong>原理</strong>: HSV分离了颜色和亮度，可精确筛选颜色范围</li>
<li><strong>优点</strong>: 抗干扰能力强，准确度高</li>
<li><strong>缺点</strong>: 速度较慢（5-10ms），参数需调优</li>
<li><strong>适用</strong>: 复杂光照、高精度需求</li>
</ul>
<hr />
<h2>1. cv::split() - 分离BGR通道</h2>
<h3>基础用法</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    // 分离通道
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);    
    // 现在：
    // channels[0] = B通道（蓝色分量）
    // channels[1] = G通道（绿色分量）
    // channels[2] = R通道（红色分量）  
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>2. 通道相减法</h2>
<h3>提取红色</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");
// 分离通道
std::vector&lt;cv::Mat&gt; channels;
cv::split(img, channels);
// 红色 = R通道 - B通道
cv::Mat red;
cv::subtract(channels[2], channels[0], red);
// 二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// 查看效果

</code></pre>
<h3>提取蓝色</h3>
<pre><code>// 蓝色 = B通道 - R通道
cv::Mat blue;
cv::subtract(channels[0], channels[2], blue);

cv::Mat binary_blue;
cv::threshold(blue, binary_blue, 100, 255, cv::THRESH_BINARY);
</code></pre>
<hr />
<h2>3. cv::cvtColor() - 颜色空间转换</h2>
<h3></h3>
<h3>常用转换代码</h3>
<ul>
<li><code>COLOR_BGR2GRAY</code>  BGR转灰度</li>
<li><code>COLOR_BGR2HSV</code>  BGR转HSV</li>
<li><code>COLOR_BGR2RGB</code> BGR转RGB</li>
<li><code>COLOR_HSV2BGR</code>  HSV转回BGR</li>
</ul>
<h3>HSV颜色空间详解</h3>
<p>HSV把颜色分解为3个维度：</p>
<pre><code>H (色调 Hue): 0-180
├─ 0-10:    红色(第一段)
├─ 100-124: 蓝色  装甲板蓝色
└─ 170-180: 红色(第二段) 装甲板红色

S (饱和度 Saturation): 0-255
└─ 100-255: 鲜艳色 灯条在这里

V (明度 Value): 0-255
└─ 100-255: 明亮 灯条在这里
</code></pre>
<h3>BGR转HSV</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

</code></pre>
<hr />
<h2>4. cv::inRange() - 颜色范围筛选</h2>
<ul>
<li><code>src</code>  输入图像（通常是HSV）</li>
<li><code>lowerb</code>  下界（Scalar(H_min, S_min, V_min)）</li>
<li><code>upperb</code>  上界（Scalar(H_max, S_max, V_max)）</li>
<li><code>dst</code>  输出二值图（在范围内=255，否则=0）</li>
</ul>
<h3>提取红色（完整版）</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// 红色的H值跨越了0-180的边界！需要分两段
// 第一段: H=0-10
cv::Scalar lower_red1(0, 100, 100);    // (H, S, V)
cv::Scalar upper_red1(10, 255, 255);

// 第二段: H=170-180
cv::Scalar lower_red2(170, 100, 100);
cv::Scalar upper_red2(180, 255, 255);

// 分别提取两段
cv::Mat mask1, mask2, red_mask;
cv::inRange(hsv, lower_red1, upper_red1, mask1);
cv::inRange(hsv, lower_red2, upper_red2, mask2);

// 合并两段（位运算：或）
cv::bitwise_or(mask1, mask2, red_mask);

</code></pre>
<h3>提取蓝色</h3>
<pre><code>// 蓝色只需要一段
cv::Scalar lower_blue(100, 100, 100);  // H=100-130
cv::Scalar upper_blue(130, 255, 255);

cv::Mat blue_mask;
cv::inRange(hsv, lower_blue, upper_blue, blue_mask);
</code></pre>
<h3>参数调优技巧</h3>
<p><strong>创建滑块实时调参</strong>：</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

// 全局变量
int h_min = 0, h_max = 10;
int s_min = 100, s_max = 255;
int v_min = 100, v_max = 255;

void on_trackbar(int, void*) {
    // 回调函数，每次滑块变化时调用
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 创建窗口
    cv::namedWindow("调参");
    
    // 创建滑块
    cv::createTrackbar("H min", "调参", &amp;h_min, 180, on_trackbar);
    cv::createTrackbar("H max", "调参", &amp;h_max, 180, on_trackbar);
    cv::createTrackbar("S min", "调参", &amp;s_min, 255, on_trackbar);
    cv::createTrackbar("S max", "调参", &amp;s_max, 255, on_trackbar);
    cv::createTrackbar("V min", "调参", &amp;v_min, 255, on_trackbar);
    cv::createTrackbar("V max", "调参", &amp;v_max, 255, on_trackbar);
    
    while (true) {
        cv::Scalar lower(h_min, s_min, v_min);
        cv::Scalar upper(h_max, s_max, v_max);
        
        cv::Mat mask;
        cv::inRange(hsv, lower, upper, mask);
        
        cv::imshow("原图", img);
        cv::imshow("mask", mask);
        
        if (cv::waitKey(30) == 27) break;
    }
    
    // 打印最终参数
    std::cout &lt;&lt; "最优参数:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "lower: (" &lt;&lt; h_min &lt;&lt; ", " &lt;&lt; s_min &lt;&lt; ", " &lt;&lt; v_min &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "upper: (" &lt;&lt; h_max &lt;&lt; ", " &lt;&lt; s_max &lt;&lt; ", " &lt;&lt; v_max &lt;&lt; ")" &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<hr />
<h2>5. cv::threshold() - 简单阈值二值化</h2>
<ul>
<li><code>THRESH_BINARY</code> | 标准二值化</li>
<li><code>THRESH_BINARY_INV</code> | 反向二值化</li>
<li><code>THRESH_TRUNC</code> | 截断</li>
<li><code>THRESH_TOZERO</code> | 低于阈值归零</li>
</ul>
<h3>配合通道相减使用</h3>
<pre><code>// 提取红色
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// 阈值二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// 像素 &gt; 100 → 255(白)
// 像素 &lt;= 100 → 0(黑)
</code></pre>
<h3>自适应阈值（应对光照不均）</h3>
<pre><code>cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

cv::Mat adaptive;
cv::adaptiveThreshold(gray, adaptive, 255,
                      cv::ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv::THRESH_BINARY, 11, 2);
// blockSize=11: 邻域大小
// C=2: 常数调整值
</code></pre>
<hr />
<h2>6. cv::bitwise 位运算</h2>
<h3>常用函数</h3>
<pre><code>void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_not(InputArray src, OutputArray dst);
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst);
</code></pre>
<h3>合并多个mask</h3>
<pre><code>// 红色有两段，需要合并
cv::Mat red_mask1, red_mask2, red_final;
cv::inRange(hsv, lower_red1, upper_red1, red_mask1);
cv::inRange(hsv, lower_red2, upper_red2, red_mask2);
cv::bitwise_or(red_mask1, red_mask2, red_final);
</code></pre>
<h3>提取同时满足多个条件的区域</h3>
<pre><code>// 同时是红色 且 亮度很高
cv::Mat color_mask, brightness_mask, final_mask;
cv::inRange(hsv, lower_red, upper_red, color_mask);
cv::threshold(hsv_channels[2], brightness_mask, 200, 255, cv::THRESH_BINARY);
cv::bitwise_and(color_mask, brightness_mask, final_mask);
</code></pre>
<h3>反转mask</h3>
<pre><code>cv::Mat mask, inverted;
cv::inRange(hsv, lower, upper, mask);
cv::bitwise_not(mask, inverted);  // 黑白反转
</code></pre>
<hr />
<h2>完整实战代码</h2>
<h3>方案1: 通道相减法（快速）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedFast(const cv::Mat&amp; img) {
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);
    
    // R - B
    cv::Mat red;
    cv::subtract(channels[2], channels[0], red);
    
    // 二值化
    cv::Mat binary;
    cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
    
    return binary;
}

int main() {
    cv::Mat img = cv::imread("red_armor.jpg");
    cv::Mat binary = extractRedFast(img);
    
    cv::imshow("原图", img);
    cv::imshow("红色提取", binary);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>方案2: HSV筛选法（精确）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedAccurate(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 红色两段
    cv::Scalar lower1(0, 100, 100);
    cv::Scalar upper1(10, 255, 255);
    cv::Scalar lower2(170, 100, 100);
    cv::Scalar upper2(180, 255, 255);
    
    cv::Mat mask1, mask2, mask;
    cv::inRange(hsv, lower1, upper1, mask1);
    cv::inRange(hsv, lower2, upper2, mask2);
    cv::bitwise_or(mask1, mask2, mask);
    
    return mask;
}

cv::Mat extractBlue(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    cv::Scalar lower(100, 100, 100);
    cv::Scalar upper(130, 255, 255);
    
    cv::Mat mask;
    cv::inRange(hsv, lower, upper, mask);
    
    return mask;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    cv::Mat red_mask = extractRedAccurate(img);
    cv::Mat blue_mask = extractBlue(img);
    
    cv::imshow("原图", img);
    cv::imshow("红色mask", red_mask);
    cv::imshow("蓝色mask", blue_mask);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 04 轮廓检测</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_04/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_04/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::findContours()</code></td>
<td>查找轮廓</td>
</tr>
<tr>
<td><code>cv::contourArea()</code></td>
<td>计算轮廓面积</td>
</tr>
<tr>
<td><code>cv::minAreaRect()</code></td>
<td>最小旋转矩形</td>
</tr>
<tr>
<td><code>cv::RotatedRect</code></td>
<td>旋转矩形类</td>
</tr>
<tr>
<td><code>cv::drawContours()</code></td>
<td>绘制轮廓</td>
</tr>
<tr>
<td><code>cv::boundingRect()</code></td>
<td>正矩形包围框</td>
</tr>
<tr>
<td><code>cv::fitEllipse()</code></td>
<td>椭圆拟合</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<ul>
<li>
<p>经过形态学处理后，二值图已经很干净：</p>
</li>
<li>
<p>现在要做的是：</p>
</li>
</ul>
<ol>
<li><strong>找轮廓</strong> - 把每个白色区域的边界找出来</li>
<li><strong>拟合矩形</strong> - 用旋转矩形描述每个轮廓</li>
<li><strong>筛选灯条</strong> - 根据长宽比、面积、角度等特征过滤</li>
</ol>
<hr />
<h2>1. cv::findContours() - 查找轮廓</h2>
<h3>参数详解</h3>
<h4>mode - 轮廓检索模式</h4>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RETR_EXTERNAL</code></td>
<td>只检测最外层轮廓</td>
<td><strong>RM推荐</strong>，忽略内部孔洞</td>
</tr>
<tr>
<td><code>RETR_LIST</code></td>
<td>检测所有轮廓，不建立层级</td>
<td>当需要所有轮廓时</td>
</tr>
<tr>
<td><code>RETR_TREE</code></td>
<td>检测所有并建立完整层级树</td>
<td>复杂嵌套结构</td>
</tr>
<tr>
<td><code>RETR_CCOMP</code></td>
<td>两层层级（外轮廓和孔）</td>
<td>较少使用</td>
</tr>
</tbody>
</table>
<h4>method - 轮廓近似方法</h4>
<table>
<thead>
<tr>
<th>method</th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CHAIN_APPROX_NONE</code></td>
<td>保存所有轮廓点</td>
<td>精确但占内存</td>
</tr>
<tr>
<td><code>CHAIN_APPROX_SIMPLE</code></td>
<td>压缩轮廓，只保留关键点</td>
<td><strong>RM推荐</strong>，节省内存</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // 获取二值图（假设已实现）
    cv::Mat binary = processImage(img);
    
    // 查找轮廓
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, 
                     cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "找到 " &lt;&lt; contours.size() &lt;&lt; " 个轮廓" &lt;&lt; std::endl;
    
    // 遍历所有轮廓
    for (size_t i = 0; i &lt; contours.size(); i++) {
        std::cout &lt;&lt; "轮廓 " &lt;&lt; i &lt;&lt; " 有 " &lt;&lt; contours[i].size() 
                  &lt;&lt; " 个点" &lt;&lt; std::endl;
    }
    
    return 0;
}
</code></pre>
<h3>重要注意事项</h3>
<h4>注意1: findContours会修改输入图像！</h4>
<pre><code>
//  正确：传入副本
cv::Mat binary_copy = binary.clone();
cv::findContours(binary_copy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 或者直接在临时对象上调用
cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
</code></pre>
<h4>注意2: 输入必须是二值图</h4>
<pre><code>//  错误：彩色图不行
cv::Mat img = cv::imread("armor.jpg");
cv::findContours(img, contours, ...);  //  结果不对

//  正确：必须是二值图（0或255）
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
cv::findContours(binary, contours, ...);
</code></pre>
<hr />
<h2>2. 轮廓数据结构理解</h2>
<h3>轮廓的本质</h3>
<pre><code>// 轮廓 = 点的集合
std::vector&lt;cv::Point&gt; contour = contours[0];

// 每个点是(x, y)坐标
cv::Point p = contour[0];
std::cout &lt;&lt; "第一个点: (" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; std::endl;
</code></pre>
<h3>轮廓操作示例</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 轮廓数量
int num = contours.size();

// 第i个轮廓的点数
int pointCount = contours[i].size();

// 访问第i个轮廓的第j个点
cv::Point p = contours[i][j];
</code></pre>
<hr />
<h2>3. cv::contourArea() - 计算轮廓面积</h2>
<h3>函数原型</h3>
<pre><code>double cv::contourArea(InputArray contour, bool oriented = false);
</code></pre>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    std::cout &lt;&lt; "轮廓面积: " &lt;&lt; area &lt;&lt; " 像素" &lt;&lt; std::endl;
}
</code></pre>
<h3>用于过滤噪点</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; validContours;

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    
    // 过滤太小的轮廓（噪点）
    if (area &lt; 100) continue;
    
    // 过滤太大的轮廓（可能是整个装甲板或背景）
    if (area &gt; 10000) continue;
    
    // 保留合理大小的轮廓
    validContours.push_back(contour);
}

std::cout &lt;&lt; "过滤后剩余 " &lt;&lt; validContours.size() &lt;&lt; " 个轮廓" &lt;&lt; std::endl;
</code></pre>
<h3>面积阈值如何选择？</h3>
<p><strong>推荐方法</strong>：</p>
<pre><code>// 根据图像大小自适应
int imageArea = binary.rows * binary.cols;
double minArea = imageArea * 0.0001;  // 0.01%
double maxArea = imageArea * 0.05;    // 5%

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    if (area &gt; minArea &amp;&amp; area &lt; maxArea) {
        // 合理范围
    }
}
</code></pre>
<hr />
<h2>4. cv::minAreaRect() - 最小旋转矩形</h2>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // 拟合最小旋转矩形
    cv::RotatedRect rect = cv::minAreaRect(contour);
    
    // 获取矩形信息
    cv::Point2f center = rect.center;      // 中心点
    cv::Size2f size = rect.size;           // 尺寸(width, height)
    float angle = rect.angle;              // 旋转角度(-90到0)
    
    std::cout &lt;&lt; "中心: (" &lt;&lt; center.x &lt;&lt; ", " &lt;&lt; center.y &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "尺寸: " &lt;&lt; size.width &lt;&lt; " × " &lt;&lt; size.height &lt;&lt; std::endl;
    std::cout &lt;&lt; "角度: " &lt;&lt; angle &lt;&lt; "°" &lt;&lt; std::endl;
}
</code></pre>
<hr />
<h2>5. cv::RotatedRect 类详解</h2>
<h3>核心属性</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// 中心点
cv::Point2f center = rect.center;  // 矩形中心的(x,y)坐标

// 尺寸
cv::Size2f size = rect.size;       // width × height
float width = size.width;
float height = size.height;

// 旋转角度
float angle = rect.angle;          // 范围: -90° ~ 0°
</code></pre>
<h3>angle的陷阱</h3>
<p><strong>OpenCV的angle定义很反直觉！</strong></p>
<pre><code>// angle的含义：
// 从水平方向逆时针旋转到矩形长边的角度
// 范围：-90° 到 0°
// 例子：
angle = -90°  → 矩形垂直（竖着）
angle = -45°  → 矩形倾斜45度
angle = 0°    → 矩形水平（横着）
</code></pre>
<h3>确保height是长边</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

float width = rect.size.width;
float height = rect.size.height;

//  OpenCV不保证height &gt; width！
// 需要手动调整
if (width &gt; height) {
    std::swap(width, height);
    // 如果需要，也可以调整angle
}

// 现在 height 一定是长边
float aspectRatio = height / width;  // 长宽比
</code></pre>
<h3>获取四个顶点坐标</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// 获取四个顶点
cv::Point2f vertices[4];
rect.points(vertices);

// vertices[0], vertices[1], vertices[2], vertices[3]
// 按逆时针顺序排列

// 绘制旋转矩形
for (int i = 0; i &lt; 4; i++) {
    cv::line(img, vertices[i], vertices[(i+1)%4], 
             cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<hr />
<h2>6. 灯条特征筛选（核心）</h2>
<h3>灯条的典型特征</h3>
<table>
<thead>
<tr>
<th>特征</th>
<th>合理范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>长宽比</strong></td>
<td>2.0 ~ 10.0</td>
<td>灯条是细长的</td>
</tr>
<tr>
<td><strong>面积</strong></td>
<td>100 ~ 5000像素</td>
<td>根据分辨率调整</td>
</tr>
<tr>
<td><strong>角度</strong></td>
<td>接近垂直</td>
<td>通常在±30°内</td>
</tr>
<tr>
<td><strong>填充度</strong></td>
<td>&gt; 0.5</td>
<td>轮廓面积/外接矩形面积</td>
</tr>
</tbody>
</table>
<h3>完整筛选代码</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    float angle;
};

std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary) {
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::vector&lt;LightBar&gt; lightBars;
    
    for (const auto&amp; contour : contours) {
        // 1. 面积筛选
        double area = cv::contourArea(contour);
        if (area &lt; 100 || area &gt; 5000) continue;
        
        // 2. 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 3. 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // 4. 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0 || aspectRatio &gt; 10.0) continue;
        
        // 5. 角度筛选（可选，根据实际情况）
        // 灯条应该接近垂直
        float angle = std::abs(rect.angle);
        if (angle &gt; 30 &amp;&amp; angle &lt; 60) continue;  // 太斜的排除
        
        // 6. 填充度筛选（可选）
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) continue;  // 太空的不是灯条
        
        // 通过所有筛选，保存
        LightBar bar;
        bar.rect = rect;
        bar.area = area;
        bar.aspectRatio = aspectRatio;
        bar.angle = angle;
        lightBars.push_back(bar);
    }
    
    std::cout &lt;&lt; "找到 " &lt;&lt; lightBars.size() &lt;&lt; " 个灯条" &lt;&lt; std::endl;
    return lightBars;
}
</code></pre>
<hr />
<h2>7. cv::drawContours() - 绘制轮廓（调试）</h2>
<h3>基础用法</h3>
<pre><code>cv::Mat display = img.clone();


// 绘制所有轮廓
cv::drawContours(display, contours, -1, cv::Scalar(0, 255, 0), 2);
// -1 表示绘制所有轮廓

// 绘制第i个轮廓
cv::drawContours(display, contours, i, cv::Scalar(255, 0, 0), 2);

// 填充轮廓
cv::drawContours(display, contours, i, cv::Scalar(0, 0, 255), -1);
// thickness=-1 表示填充
</code></pre>
<h3>彩色调试可视化</h3>
<pre><code>void visualizeContours(const cv::Mat&amp; img, 
                       const std::vector&lt;std::vector&lt;cv::Point&gt;&gt;&amp; contours) {
    cv::Mat display = img.clone();
    
    // 为每个轮廓随机颜色
    cv::RNG rng(12345);
    
    for (size_t i = 0; i &lt; contours.size(); i++) {
        cv::Scalar color(rng.uniform(0, 256), 
                        rng.uniform(0, 256), 
                        rng.uniform(0, 256));
        
        // 绘制轮廓
        cv::drawContours(display, contours, i, color, 2);
        
        // 标注序号
        cv::Moments m = cv::moments(contours[i]);
        cv::Point2f center(m.m10/m.m00, m.m01/m.m00);
        cv::putText(display, std::to_string(i), center,
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
    }
    
    cv::imshow("轮廓可视化", display);
}
</code></pre>
<hr />
<h2>8. 绘制旋转矩形</h2>
<h3>标准方法</h3>
<pre><code>void drawRotatedRect(cv::Mat&amp; img, const cv::RotatedRect&amp; rect, 
                     const cv::Scalar&amp; color, int thickness = 2) {
    cv::Point2f vertices[4];
    rect.points(vertices);
    
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], color, thickness);
    }
}

// 使用
for (const auto&amp; bar : lightBars) {
    drawRotatedRect(display, bar.rect, cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<h3>增强版（带中心点和文字）</h3>
<pre><code>void drawLightBar(cv::Mat&amp; img, const LightBar&amp; bar, int id) {
    // 绘制旋转矩形
    cv::Point2f vertices[4];
    bar.rect.points(vertices);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制中心点
    cv::circle(img, bar.rect.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 标注信息
    std::string text = "ID:" + std::to_string(id) + 
                       " R:" + std::to_string((int)bar.aspectRatio);
    cv::putText(img, text, 
                cv::Point(bar.rect.center.x + 10, bar.rect.center.y),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 255), 2);
}
</code></pre>
<hr />
<h2>10. cv::fitEllipse() - 椭圆拟合（能量机关用）</h2>
<h3>函数原型</h3>
<pre><code>RotatedRect cv::fitEllipse(InputArray points);
</code></pre>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // 至少需要5个点
    if (contour.size() &lt; 5) continue;
    
    // 拟合椭圆
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 绘制椭圆
    cv::ellipse(img, ellipse, cv::Scalar(0, 255, 255), 2);
}
</code></pre>
<h3>能量机关扇叶识别</h3>
<pre><code>// 能量机关的R标是椭圆形
bool isEnergyRune(const std::vector&lt;cv::Point&gt;&amp; contour) {
    if (contour.size() &lt; 5) return false;
    
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 椭圆的长短轴比应该接近1（近似圆形）
    float ratio = ellipse.size.width / ellipse.size.height;
    if (ratio &lt; 0.8 || ratio &gt; 1.2) return false;
    
    // 面积合理
    double area = CV_PI * ellipse.size.width/2 * ellipse.size.height/2;
    if (area &lt; 500 || area &gt; 3000) return false;
    
    return true;
}
</code></pre>
<hr />
<h2>完整实战代码</h2>
<h3>完整的灯条检测系统</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

// 灯条结构体
struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    
    LightBar(const cv::RotatedRect&amp; r, double a, float ar)
        : rect(r), area(a), aspectRatio(ar) {}
};

// 灯条检测函数
std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary, 
                                      const cv::Mat&amp; display) {
    // 1. 查找轮廓
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "总轮廓数: " &lt;&lt; contours.size() &lt;&lt; std::endl;
    
    std::vector&lt;LightBar&gt; lightBars;
    
    // 2. 遍历筛选
    for (size_t i = 0; i &lt; contours.size(); i++) {
        const auto&amp; contour = contours[i];
        
        // 面积筛选
        double area = cv::contourArea(contour);
        if (area &lt; 100) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 面积=" &lt;&lt; area 
                      &lt;&lt; "  太小" &lt;&lt; std::endl;
            continue;
        }
        if (area &gt; 5000) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 面积=" &lt;&lt; area 
                      &lt;&lt; " 太大" &lt;&lt; std::endl;
            continue;
        }
        
        // 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 长宽比=" &lt;&lt; aspectRatio 
                      &lt;&lt; " 太矮" &lt;&lt; std::endl;
            continue;
        }
        if (aspectRatio &gt; 10.0) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 长宽比=" &lt;&lt; aspectRatio 
                      &lt;&lt; "太细" &lt;&lt; std::endl;
            continue;
        }
        
        // 填充度筛选
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 填充度=" &lt;&lt; fillRatio 
                      &lt;&lt; "  太空" &lt;&lt; std::endl;
            continue;
        }
        
        // 通过筛选！
        std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ":  灯条候选" &lt;&lt; std::endl;
        std::cout &lt;&lt; "    面积=" &lt;&lt; area &lt;&lt; ", 长宽比=" &lt;&lt; aspectRatio 
                  &lt;&lt; ", 填充度=" &lt;&lt; fillRatio &lt;&lt; std::endl;
        
        lightBars.emplace_back(rect, area, aspectRatio);
        
        // 绘制（调试用）
        if (!display.empty()) {
            cv::Point2f vertices[4];
            rect.points(vertices);
            for (int j = 0; j &lt; 4; j++) {
                cv::line(display, vertices[j], vertices[(j+1)%4],
                         cv::Scalar(0, 255, 0), 2);
            }
            cv::circle(display, rect.center, 5, cv::Scalar(0, 0, 255), -1);
        }
    }
    
    std::cout &lt;&lt; "\n最终找到 " &lt;&lt; lightBars.size() &lt;&lt; " 个灯条" &lt;&lt; std::endl;
    return lightBars;
}

int main() {
    // 读取图像
    cv::Mat img = cv::imread("armor.jpg");
    if (img.empty()) {
        std::cerr &lt;&lt; "无法读取图像" &lt;&lt; std::endl;
        return -1;
    }
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学处理（假设已实现）
    binary = morphologyProcess(binary);
    
    // 灯条检测
    cv::Mat display = img.clone();
    std::vector&lt;LightBar&gt; lightBars = detectLightBars(binary, display);
    
    // 显示结果
    cv::imshow("原图", img);
    cv::imshow("二值图", binary);
    cv::imshow("检测结果", display);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>常见问题排查</h2>
<h3>问题1: 找不到轮廓</h3>
<pre><code>// 检查清单：
// 1. 二值图是否正确？
cv::imshow("binary", binary);  // 应该是黑白的

// 2. 前景是白色吗？
// findContours找的是白色区域！如果反了需要反转
cv::bitwise_not(binary, binary);

// 3. 图像是单通道吗？
std::cout &lt;&lt; "通道数: " &lt;&lt; binary.channels() &lt;&lt; std::endl;  // 应该是1
</code></pre>
<h3>问题2: 找到太多轮廓（都是噪点）</h3>
<pre><code>// 解决方案：
// 1. 加强形态学处理
cv::morphologyEx(binary, binary, cv::MORPH_OPEN, kernel);

// 2. 提高面积阈值
if (area &lt; 200) continue;  // 增大

// 3. 添加填充度筛选
double fillRatio = area / (width * height);
if (fillRatio &lt; 0.6) continue;
</code></pre>
<h3>问题3: 灯条被筛掉了</h3>
<pre><code>// 调试步骤：
// 1. 打印每个轮廓的参数
for (size_t i = 0; i &lt; contours.size(); i++) {
    double area = cv::contourArea(contours[i]);
    cv::RotatedRect rect = cv::minAreaRect(contours[i]);
    float ratio = rect.size.height / rect.size.width;
    std::cout &lt;&lt; i &lt;&lt; ": area=" &lt;&lt; area &lt;&lt; ", ratio=" &lt;&lt; ratio &lt;&lt; std::endl;
}

// 2. 放宽筛选条件
if (aspectRatio &lt; 1.5 || aspectRatio &gt; 15.0) continue;  // 放宽范围

// 3. 可视化被筛掉的轮廓
cv::drawContours(rejected_img, contours, i, cv::Scalar(0,0,255), 2);
</code></pre>
<h3>问题4: 旋转矩形角度不对</h3>
<pre><code>// OpenCV的angle有时不符合预期
// 解决方案：自己计算角度
cv::Point2f vertices[4];
rect.points(vertices);

// 计算长边的角度
cv::Point2f edge = vertices[1] - vertices[0];
float angle = std::atan2(edge.y, edge.x) * 180 / CV_PI;
</code></pre>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>中南自瞄</title>
    <link href="https://www.nanye404.top/posts/fyt/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/fyt/</id>
    <published>2025-10-23T00:00:00.000Z</published>
    <updated>2025-10-23T00:00:00.000Z</updated>
    <summary>中南自瞄的代码框架解读</summary>
    <content type="html"><![CDATA[<h2>装甲板检测</h2>
<h3><strong>检测类</strong></h3>
<ul>
<li>Detector
<ul>
<li>成员
<ul>
<li><code>LightParams</code> 灯条参数
<ul>
<li><code>min_ratio</code>，<code>max_ratio</code> 宽高比</li>
<li><code>max_angle</code> 最大倾斜角</li>
<li><code>color_diff_thresh</code> 颜色阈值，用来判断颜色（通道相减）</li>
</ul>
</li>
<li><code>ArmorParams</code> 装甲板参数
<ul>
<li><code>min_light_ratio</code> 最小灯条宽高比（那上面的是什么）</li>
<li><code>center_distance</code> 装甲板距离</li>
<li><code>max_angle</code> 最大倾斜角（那上面的是什么）</li>
</ul>
</li>
<li><code>binary_thres</code> 二值化阈值</li>
<li><code>detect_color</code> 颜色</li>
<li><code>classifier</code> 识别数字 <code>corner_corrector</code> 角点修正（智能指针？不会用）</li>
<li><code>binary_img</code> 二值化图像</li>
<li><code>rm_interfaces::msg::DebugLights debug_lights</code> <code>rm_interfaces::msg::DebugArmors debug_armors</code> 发布消息</li>
<li><code>gray_img_</code> 灰度图</li>
<li><code>lights_</code> <code>armors_</code> 检测的所有灯条和装甲板</li>
</ul>
</li>
<li>函数（noexcept性能优化？）
<ul>
<li><code>detect</code> 检测入口
<ul>
<li><code>preprocessImage</code> 图像预处理
<ul>
<li>转灰度，二值化</li>
</ul>
</li>
<li><code>findLights</code>
<ul>
<li>寻找轮廓，然后简单判断，如果点太少就跳过</li>
<li>转换成灯条</li>
<li>判断是否是灯条
<ul>
<li>判断颜色</li>
<li>保存</li>
</ul>
</li>
<li>按横坐标排序，返回</li>
</ul>
</li>
<li><code>matchLights</code> 匹配装甲板</li>
</ul>
</li>
<li><code>getAllNumbersImage</code> 调试函数</li>
<li><code>drawResults</code> 绘制结果</li>
<li><code>isLight</code> 判断灯条 <code>isArmor</code> 判断装甲板（为啥一个公有一个私有，对于什么公有什么私有有点晕其实）</li>
<li><code>containLight</code> 判断是否已配对</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 01 图像读取与显示</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_01/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_01/</id>
    <published>2025-10-23T00:00:00.000Z</published>
    <updated>2025-10-23T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::imread()</code></td>
<td>读取图片到内存</td>
</tr>
<tr>
<td><code>cv::imshow()</code></td>
<td>显示图片窗口</td>
</tr>
<tr>
<td><code>cv::waitKey()</code></td>
<td>等待按键</td>
</tr>
<tr>
<td><code>cv::imwrite()</code></td>
<td>保存图片</td>
</tr>
<tr>
<td><code>cv::Mat</code></td>
<td>图像数据类型</td>
</tr>
<tr>
<td><code>cv::VideoCapture</code></td>
<td>打开相机/视频</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::imread() - 读取图片</h2>
<h3>参数说明</h3>
<ul>
<li><code>filename</code>    图片路径（相对或绝对路径）
-<code>flags</code> 读取模式（见下表）</li>
</ul>
<p><strong>flags常用值:</strong></p>
<ul>
<li><code>cv::IMREAD_COLOR</code> (默认) - 读取彩色图，忽略透明度</li>
<li><code>cv::IMREAD_GRAYSCALE</code> - 转为灰度图</li>
<li><code>cv::IMREAD_UNCHANGED</code> - 包含Alpha通道</li>
</ul>
<h3>基础用法</h3>
<pre><code>
    // 读取彩色图（装甲板识别用这个）
    cv::Mat img = cv::imread("armor.jpg", cv::IMREAD_COLOR);
    
    //  必须检查是否读取成功，不检查后续操作会崩溃
    if (img.empty()) {
        std::cout &lt;&lt; " 图片读取失败！" &lt;&lt; std::endl;
        return -1;
    }
    
    // 打印图片信息
    std::cout &lt;&lt; " 图片读取成功" &lt;&lt; std::endl;
    std::cout &lt;&lt; "   尺寸: " &lt;&lt; img.cols &lt;&lt; " x " &lt;&lt; img.rows &lt;&lt; std::endl;
    std::cout &lt;&lt; "   通道数: " &lt;&lt; img.channels() &lt;&lt; std::endl;

</code></pre>
<h3>输出示例</h3>
<pre><code> 图片读取成功
   尺寸: 1280 x 720
   通道数: 3
</code></pre>
<h3>注意路径的写法</h3>
<pre><code>cv::Mat img = cv::imread("/home/user/img.jpg");     // 绝对路径
cv::Mat img = cv::imread("img.jpg");       //相对路径

</code></pre>
<blockquote>
<p><strong>OpenCV读取的图片是BGR格式，不是RGB！</strong><br />
这在后续颜色识别时非常重要。如果你要转RGB需要用 <code>cv::cvtColor()</code></p>
</blockquote>
<hr />
<h2>2. cv::imshow() - 显示图片</h2>
<h3>参数说明</h3>
<ul>
<li><code>winname</code>（自己起名）</li>
<li><code>mat</code> 要显示的图像</li>
</ul>
<h3>基础用法</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");

// 显示图片
cv::imshow("原图", img);

//  必须配合waitKey()，否则窗口闪现即消失
cv::waitKey(0);  // 0表示无限等待，直到按任意键

// 关闭所有窗口
cv::destroyAllWindows();
</code></pre>
<h3>显示多个窗口</h3>
<pre><code>cv::Mat img1 = cv::imread("red_armor.jpg");
cv::Mat img2 = cv::imread("blue_armor.jpg");

cv::imshow("红方装甲板", img1);
cv::imshow("蓝方装甲板", img2);

cv::waitKey(0);
cv::destroyAllWindows();
</code></pre>
<hr />
<h2>3. cv::waitKey() - 等待按键</h2>
<h3>等待任意键</h3>
<pre><code>cv::imshow("Image", img);
cv::waitKey(0);  // 按任意键继续
</code></pre>
<h3>检测特定按键</h3>
<pre><code>cv::imshow("Image", img);
int key = cv::waitKey(0);

if (key == 27) {  // ESC键
    std::cout &lt;&lt; "用户取消" &lt;&lt; std::endl;
} else if (key == 's' || key == 'S') {  // S键
    cv::imwrite("saved.jpg", img);
    std::cout &lt;&lt; "图片已保存" &lt;&lt; std::endl;
}
</code></pre>
<h3>实时视频显示（30fps）</h3>
<pre><code>while (true) {
    cv::Mat frame = getFrame();  // 获取一帧
    cv::imshow("Video", frame);
    
    // 等待33ms（约30fps），按ESC退出
    if (cv::waitKey(33) == 27) break;
}
</code></pre>
<hr />
<h2>4. cv::Mat - 图像数据类型</h2>
<h3>核心概念</h3>
<p><code>cv::Mat</code> 是OpenCV的核心数据结构，可以理解为一个<strong>多维数组</strong>：</p>
<ul>
<li>2D图像 = 二维矩阵</li>
<li>彩色图像 = 三维矩阵（宽×高×通道）</li>
</ul>
<h3>创建Mat对象</h3>
<h4>方法1: 通过imread创建</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");
</code></pre>
<h4>方法2: 创建空白图像</h4>
<pre><code>// 创建640×480的黑色图像
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

</code></pre>
<h3>常用属性</h3>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// 基本信息
int width = img.cols;      // 宽度（列数）
int height = img.rows;     // 高度（行数）
int channels = img.channels();  // 通道数（1=灰度，3=彩色）
bool isEmpty = img.empty();     // 是否为空

// 数据类型
int type = img.type();     // CV_8UC3 等
int depth = img.depth();   // CV_8U 等

// 内存信息
size_t total = img.total();    // 总像素数 = rows × cols
size_t bytes = img.total() * img.elemSize();  // 占用字节数
</code></pre>
<h3>Mat类型代码说明</h3>
<pre><code>// CV_&lt;bit-depth&gt;{U|S|F}C&lt;channels&gt;
CV_8UC1   // 8位无符号，1通道（灰度图）
CV_8UC3   // 8位无符号，3通道（BGR彩色图）
CV_32FC1  // 32位浮点，1通道
CV_16SC3  // 16位有符号，3通道
</code></pre>
<hr />
<h2>5. cv::imwrite() - 保存图片</h2>
<h3>基础用法</h3>
<pre><code>cv::Mat img = cv::imread("input.jpg");

// 处理图像...

// 保存为JPG（有损压缩）
cv::imwrite("output.jpg", img);

// 保存为PNG（无损压缩，推荐保存二值图）
cv::imwrite("binary.png", binaryImg);
</code></pre>
<h3>设置压缩质量</h3>
<pre><code>// JPG质量控制（0-100，默认95）
std::vector&lt;int&gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // 质量90%
cv::imwrite("output.jpg", img, jpg_params);

// PNG压缩级别（0-9，默认3）
std::vector&lt;int&gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // 最大压缩
cv::imwrite("output.png", img, png_params);
</code></pre>
<hr />
<h2>6. cv::VideoCapture - 打开相机/视频</h2>
<h3>打开相机</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    // 打开默认相机（设备ID=0）
    cv::VideoCapture cap(0);
    
    // 检查是否成功打开
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; " 相机打开失败" &lt;&lt; std::endl;
        return -1;
    }
  
    cv::Mat frame;
    while (true) {
        // 读取一帧
        cap.read(frame);
        // 或者: cap &gt;&gt; frame;
        
        if (frame.empty()) {
            std::cerr &lt;&lt; " 无法读取帧" &lt;&lt; std::endl;
            break;
        }
        
        // 显示
        cv::imshow("Camera", frame);
        
        // 按ESC退出
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<h3>读取视频文件</h3>
<pre><code>cv::VideoCapture cap("video.mp4");

if (!cap.isOpened()) {
    std::cerr &lt;&lt; "视频文件打开失败" &lt;&lt; std::endl;
    return -1;
}

// 获取视频信息
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &lt;&lt; "视频信息: " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height 
          &lt;&lt; " @ " &lt;&lt; fps &lt;&lt; "fps, 共" &lt;&lt; frame_count &lt;&lt; "帧" &lt;&lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow("Video", frame);
    if (cv::waitKey(1000/fps) == 27) break;  // 按原速播放
}
</code></pre>
<hr />
<h2>本阶段实战练习</h2>
<p>&lt;/details&gt;</p>
<h3>练习: 相机实时预览</h3>
<p>实现一个相机预览程序，显示当前FPS</p>
<p>&lt;details&gt;
&lt;summary&gt; 参考答案&lt;/summary&gt;</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "相机打开失败" &lt;&lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &gt;&gt; frame;
        if (frame.empty()) break;
        
        // 计算FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&lt;double&gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // 在图像上绘制FPS
        std::string fps_text = "FPS: " + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow("Camera Preview", frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<p>&lt;/details&gt;</p>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>更新日志</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>这里是更新日志</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>更新了个人简介</li>
<li>更新了rm笔记</li>
<li>更新了双指针的框架</li>
<li>评论没挂服务器所以不能用</li>
</ul>
<h2>2025-10-23</h2>
<ul>
<li>更新了快慢指针</li>
</ul>
<h2>2025-10-24</h2>
<ul>
<li>更新了两篇opencv入门，ai写的，以后看着能不能精简一下</li>
</ul>
<h2>2025-10-26</h2>
<ul>
<li>装甲板识别基本更完</li>
<li>双指针更完</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="日志"></category>
  </entry>
  <entry>
    <title>双指针</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>双指针常见技巧</summary>
    <content type="html"><![CDATA[<ul>
<li>本篇参考labuladong的算法笔记编写</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">双指针在数组的运用</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">快慢指针</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">二分搜索</a></li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">数之和</a></li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">回文/反转</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">双指针在链表的运用</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">合并</a></li>
<li><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E8%A7%A3">分解</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr />
<h2>双指针在数组的运用</h2>
<hr />
<h2>快慢指针</h2>
<h3>数组的原地修改</h3>
<ul>
<li>力扣第 26 题「删除有序数组中的重复项」，让你在有序数组去重：
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</li>
</ul>
<hr />
<ul>
<li>给你一个<strong>非严格递增排列</strong>的数组<code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。然后返回 <code>nums</code> 中唯一元素的个数。</li>
<li>考虑 <code>nums </code>的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 k。</li>
<li><code>nums</code> 的前 k 个元素应包含 排序后 的唯一数字。下标 <code>k - 1 </code>之后的剩余元素可以忽略。</li>
</ul>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<pre><code>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案
int k = removeDuplicates(nums); // 调用
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>如果所有断言都通过，那么您的题解将被<strong>通过</strong>。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的
</code></pre>
<ul>
<li><strong>原地</strong>意味着只能对当前数组进行修改，不能新建一个数组</li>
<li>这里所需要用到的就是<strong>快慢指针</strong></li>
<li>简单来说就是一个快指针去识别，另一个慢指针去操作</li>
<li><strong>注意</strong>  这里指针是广义上的指针，数组的索引也可以是<strong>指针</strong></li>
<li>如果 <code>fast</code> 遇到值为 <code>val </code>的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow </code>前进一步。</li>
</ul>
<p>具体代码如下</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
</code></pre>
<ul>
<li>注意这里需要<strong>先<code>slow++</code>再赋值</strong>，要不然第一个会被吞掉</li>
</ul>
<hr />
<ul>
<li>下面一道题也是快慢指针的思想，如果掌握了前一道题，这题会很简单</li>
<li><strong>力扣283移动0</strong>https://leetcode.cn/problems/move-zeroes/</li>
<li>给定一个数组 <strong>nums</strong>，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li>
<li>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</li>
</ul>
<p>示例 1:</p>
<pre><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:
</code></pre>
<pre><code>输入: nums = [0]
输出: [0]
</code></pre>
<p>这里我就直接上代码了</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int slow = 0;  // 指向下一个非零应放置的位置
        for (int fast = 0; fast &lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow 之后的全部置为 0
        for (int i = slow; i &lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

</code></pre>
<hr />
<h2>二分搜索</h2>
<ul>
<li>
<p>在我们都玩过的猜数字游戏中，用的就是二分搜素的技巧</p>
</li>
<li>
<p>我们先看最笨的顺序查找，我们从1-100遍历全部数字，虽然说运气好可能一下会猜中，但是期望的次数还是很多，复杂度为O(n)</p>
</li>
<li>
<p>如果是凭感觉找，一样还是要看运气</p>
</li>
<li>
<p>如果第一次猜50，然后继续一半一半缩小区间，最坏也能在7次内解决</p>
<ul>
<li>如何数字来到1-1000000，二分搜索最坏20次就能找到答案</li>
</ul>
</li>
<li>
<p>二分搜索的时间复杂度是O(log  N)</p>
</li>
<li>
<p>下面是最基本代码</p>
</li>
</ul>
<pre><code>int binarySearch(vector&lt;int&gt;&amp; nums, int target) {
    // 一左一右两个指针相向而行
    int left = 0, right = nums.size() - 1;
    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; 
        else if (nums[mid] &gt; target)
            right = mid - 1;
    }
    return -1;
}
</code></pre>
<h2>数之和</h2>
<ul>
<li>作为力扣的第一道题，很多人上来直接就是两个for循环暴力枚举，但实际上有更聪明的枚举方式，这个题就是一个典型的双指针问题</li>
<li>https://leetcode.cn/problems/two-sum/</li>
</ul>
<hr />
<ul>
<li>给定一个整数数组<code> num</code>s 和一个整数目标值<code> target</code>，请你在该数组中找出 <strong>和为目标值</strong><code> target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</li>
</ul>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：nums = [3,2,4], target = 6
输出：[1,2]

</code></pre>
<ul>
<li>这题的思路和二分搜索很相似，而且这种问题显然让数组有序会更好做</li>
<li>当数组有序之后，<code>首项+尾项/2</code>很接近所有数的平均数，因此也最可能接近<code>target</code>。</li>
<li>我们让<code>left</code>指向最小<code>right</code>指向最大,如果小了就让left++，大了就让right--
--- 下面是代码</li>
</ul>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;pair&lt;int, int&gt;&gt; vec;//这里为了保留原数组的索引
        for (int i = 0; i &lt; nums.size(); ++i)
            vec.push_back({nums[i], i});

        sort(vec.begin(), vec.end());

        int left = 0, right = vec.size() - 1;
        while (left &lt; right) {
            int sum = vec[left].first + vec[right].first;
            if (sum == target) {
                return {vec[left].second, vec[right].second};
            } else if (sum &lt; target) {
                left++;
            } else {
                right--;
            }
        }
        
    }
};
</code></pre>
<ul>
<li>其实这题的最优解是哈希表，但是现在讲的是双指针，后面再说</li>
</ul>
<hr />
<h2>回文/反转</h2>
<h3>反转字符串</h3>
<ul>
<li>https://leetcode.cn/problems/reverse-string/description/</li>
<li>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</li>
<li>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
示例 1：</li>
</ul>
<pre><code>输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
</code></pre>
<p>示例 2：</p>
<pre><code>输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
</code></pre>
<ul>
<li>这题很简单，我就直接给代码了</li>
</ul>
<pre><code>class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        int n = s.size();
        for (int left = 0, right = n - 1; left &lt; right; ++left, --right) {
            swap(s[left], s[right]);
        }
    }
};
</code></pre>
<h3>最长回文子串</h3>
<ul>
<li>给你一个字符串 <code>s</code>，找到<code>s</code>中最长的 <strong>回文</strong> 子串。</li>
</ul>
<p>示例 1：</p>
<pre><code>输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：s = "cbbd"
输出："bb"
</code></pre>
<ul>
<li>像这种回文/对称，应该想到用双指针</li>
<li>但是需要先判断一下回文序列的奇偶，奇偶需要不同的处理方式
<ul>
<li>如果是奇数，那么两个指针应该重合，再向两侧寻找</li>
<li>如果是偶数，两个指针停留在相同的字符上，再向两侧寻找</li>
</ul>
</li>
</ul>
<pre><code>lass Solution {
public:
    string longestPalindrome(string s) {
        string res = "";
        for (int i = 0; i &lt; s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            string s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            string s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() &gt; s1.length() ? res : s1;
            res = res.length() &gt; s2.length() ? res : s2;
        }
        return res;
    }

private:
    string palindrome(string s, int l, int r) {
        // 防止索引越界
        while (l &gt;= 0 &amp;&amp; r &lt; s.length() &amp;&amp; s[l] == s[r]) {
            // 向两边展开
            l--;
            r++;
        }
        // 此时 s[l+1..r-1] 就是最长回文串
        return s.substr(l + 1, r - l - 1);
    }
};

</code></pre>
<h2>滑动窗口</h2>
<ul>
<li>滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组。</li>
</ul>
<h3>滑动窗口框架</h3>
<pre><code>void slidingWindow(string s) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    auto window = ...

    int left = 0, right = 0;
    while (right &lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        window.add(c);
        // 增大窗口
        right++;

        // 进行窗口内数据的一系列更新
        ...

        // *** debug 输出的位置 ***
        printf("window: [%d, %d)\n", left, right);
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            window.remove(d);
            // 缩小窗口
            left++;

            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

</code></pre>
<h2>字符串的排列</h2>
<ul>
<li>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的 排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
<li>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 子串 。
示例 1：</li>
</ul>
<pre><code>输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
</code></pre>
<p>示例 2：</p>
<pre><code>输入：s1= "ab" s2 = "eidboaoo"
输出：false
</code></pre>
<ul>
<li>窗口大小固定为 s1.size()
<ul>
<li>因为 s2 中可能存在的子串长度必须等于 s1。</li>
</ul>
</li>
<li>维护一个频次数组
<ul>
<li>用 cnt1[26] 保存 s1 中每个字母出现的次数。</li>
<li>遍历 s2 时，维护一个窗口 [l, r]，每次加入一个字符，尝试匹配 cnt1。</li>
</ul>
</li>
<li>匹配条件
<ul>
<li>定义 count = k = s1.size()，表示还差多少个字符能匹配成功。</li>
<li>每次加入新字符 s2[r]：
<ul>
<li>让 cnt1[s2[r]]--。</li>
<li>如果 cnt1[s2[r]] 还大于 0，说明这个字符是需要的 → count--。</li>
</ul>
</li>
<li>当窗口长度等于 k 时：
<ul>
<li>如果 count == 0，说明窗口里的字符正好是一个排列 → 返回 true。</li>
<li>窗口右移时，把 s2[l] 移出：
<ul>
<li>如果 ++cnt1[s2[l]] &gt; 0，说明移出了一个必须的字符 → count++。</li>
</ul>
</li>
<li>下一步窗口大小 &gt;k 了，需要l++  → 维持窗口</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>class Solution {
public:
    // 判断 s 中是否存在 t 的排列
    bool checkInclusion(string t, string s) {
        unordered_map&lt;char, int&gt; need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        while (right &lt; s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // 判断左侧窗口是否要收缩
            while (right - left &gt;= t.size()) {
                // 在这里判断是否找到了合法的子串
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }
};
</code></pre>
<hr />
<h2>双指针在链表的运用</h2>
<hr />
<h2>合并两个有序列表</h2>
<ul>
<li>https://leetcode.cn/problems/merge-two-sorted-lists/description/</li>
<li>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1:
&lt;img src="/img/merge_ex1.jpg"&gt;</li>
</ul>
<pre><code>输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
</code></pre>
<p>示例 2：</p>
<pre><code>输入：l1 = [], l2 = []
输出：[]
</code></pre>
<p>示例 3：</p>
<pre><code>输入：l1 = [], l2 = [0]
输出：[0]
</code></pre>
<ul>
<li>比较简单，下面是代码</li>
</ul>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 虚拟头结点
        ListNode dummy(-1), *p = &amp;dummy;
        ListNode *p1 = l1, *p2 = l2;
        
        while (p1 != nullptr &amp;&amp; p2 != nullptr) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1-&gt;val &gt; p2-&gt;val) {
                p-&gt;next = p2;
                p2 = p2-&gt;next;
            } else {
                p-&gt;next = p1;
                p1 = p1-&gt;next;
            }
            // p 指针不断前进
            p = p-&gt;next;
        }
        
        if (p1 != nullptr) {
            p-&gt;next = p1;
        }
        
        if (p2 != nullptr) {
            p-&gt;next = p2;
        }
        
        return dummy.next;
    }
};
</code></pre>
<hr />
<h2>合并<code>k</code>个有序链表</h2>
<ul>
<li>https://leetcode.cn/problems/merge-k-sorted-lists/description/</li>
<li>给你一个链表数组，每个链表都已经按升序排列。</li>
<li>请你将所有链表合并到一个升序链表中，返回合并后的链表。
示例 1：</li>
</ul>
<pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<p>示例 2：</p>
<pre><code>输入：lists = []
输出：[]
</code></pre>
<ul>
<li>合并 <code>k</code> 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 <code>k</code> 个节点中的最小节点，接到结果链表上</li>
</ul>
<pre><code>class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        if (lists.empty()) return nullptr;
        // 虚拟头结点
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        // 优先级队列，最小堆
        auto cmp = [](ListNode* a, ListNode* b) { return a-&gt;val &gt; b-&gt;val; };
        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp);
        // 将 k 个链表的头结点加入最小堆
        for (ListNode* head : lists) {
            if (head != nullptr) {
                pq.push(head);
            }
        }

        while (!pq.empty()) {
            // 获取最小节点，接到结果链表中
            ListNode* node = pq.top();
            pq.pop();
            p-&gt;next = node;
            if (node-&gt;next != nullptr) {
                pq.push(node-&gt;next);
            }
            // p 指针不断前进
            p = p-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<hr />
<h2>单链表的分解</h2>
<ul>
<li>
<p>https://leetcode.cn/problems/partition-list/description/</p>
</li>
<li>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 小于 <code>x</code> <strong>的节点都出现在</strong> 大于或等于 <code>x</code> 的节点之前。</p>
</li>
<li>
<p>你应当 保留 两个分区中每个节点的初始相对位置。
示例 1：
&lt;img src="/img/partition.jpg"&gt;</p>
</li>
</ul>
<pre><code>输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
</code></pre>
<p>示例 2：</p>
<pre><code>输入：head = [2,1], x = 2
输出：[1,2]
</code></pre>
<ul>
<li>是不是很像之前讲过的移动0？</li>
<li>思路其实都差不多，快慢指针的思想，一个查找，一个处理</li>
<li>然后把所有大于等于x的穿成一个新的链表，最后两个链表合并即可</li>
<li>下面是代码</li>
</ul>
<pre><code>class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        // 存放小于 x 的链表的虚拟头结点
        ListNode* dummy1 = new ListNode(-1);
        // 存放大于等于 x 的链表的虚拟头结点
        ListNode* dummy2 = new ListNode(-1);
        // p1, p2 指针负责生成结果链表
        ListNode* p1 = dummy1, *p2 = dummy2;
        // p 负责遍历原链表，类似合并两个有序链表的逻辑
        // 这里是将一个链表分解成两个链表
        ListNode* p = head;
        while (p != nullptr) {
            if (p-&gt;val &gt;= x) {
                p2-&gt;next = p;
                p2 = p2-&gt;next;
            } else {
                p1-&gt;next = p;
                p1 = p1-&gt;next;
            }
            // 不能直接让 p 指针前进，
            // p = p-&gt;next
            // 断开原链表中的每个节点的 next 指针
            ListNode* temp = p-&gt;next;
            p-&gt;next = nullptr;
            p = temp;
        }
        // 连接两个链表
        p1-&gt;next = dummy2-&gt;next;

        return dummy1-&gt;next;
    }
};
</code></pre>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>视频测试</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>视频测试。</summary>
    <content type="html"><![CDATA[<p>这是视频测试</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="测试"></category>
  </entry>
</feed>