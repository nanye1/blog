<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>å—å¶ã®å°çª</title>
  <subtitle>æ¬¢è¿æ¥ç©awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-10-24T01:57:02.254Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>RMè£…ç”²æ¿è¯†åˆ« - 01 å›¾åƒè¯»å–ä¸æ˜¾ç¤º</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_01/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_01/</id>
    <published>2025-10-23T00:00:00.000Z</published>
    <updated>2025-10-23T00:00:00.000Z</updated>
    <summary></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>é˜¶æ®µç›®æ ‡</strong>: èƒ½è¯»å–å›¾ç‰‡ã€æ˜¾ç¤ºå¤„ç†ç»“æœã€ä¿å­˜æ–‡ä»¶<br />
<strong>é€‚åˆäººç¾¤</strong>: åˆšæ¥è§¦OpenCVçš„æ–°æ‰‹<br />
<strong>é¢„è®¡ç”¨æ—¶</strong>: 30åˆ†é’Ÿ</p>
</blockquote>
<hr />
<h2>ğŸ“š æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>ä½œç”¨</th>
<th>é‡è¦æ€§</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::imread()</code></td>
<td>è¯»å–å›¾ç‰‡åˆ°å†…å­˜</td>
<td>â­â­â­ æ ¸å¿ƒ</td>
</tr>
<tr>
<td><code>cv::imshow()</code></td>
<td>æ˜¾ç¤ºå›¾ç‰‡çª—å£</td>
<td>â­â­â­ æ ¸å¿ƒ</td>
</tr>
<tr>
<td><code>cv::waitKey()</code></td>
<td>ç­‰å¾…æŒ‰é”®</td>
<td>â­â­â­ æ ¸å¿ƒ</td>
</tr>
<tr>
<td><code>cv::imwrite()</code></td>
<td>ä¿å­˜å›¾ç‰‡</td>
<td>â­â­ å¸¸ç”¨</td>
</tr>
<tr>
<td><code>cv::Mat</code></td>
<td>å›¾åƒæ•°æ®ç±»å‹</td>
<td>â­â­â­ æ ¸å¿ƒ</td>
</tr>
<tr>
<td><code>cv::VideoCapture</code></td>
<td>æ‰“å¼€ç›¸æœº/è§†é¢‘</td>
<td>â­â­ è¿›é˜¶</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::imread() - è¯»å–å›¾ç‰‡</h2>
<h3>ğŸ“– å‡½æ•°åŸå‹</h3>
<pre><code>cv::Mat cv::imread(const String&amp; filename, int flags = IMREAD_COLOR);
</code></pre>
<h3>ğŸ“‹ å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>ç±»å‹</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td>string</td>
<td>å›¾ç‰‡è·¯å¾„ï¼ˆç›¸å¯¹æˆ–ç»å¯¹è·¯å¾„ï¼‰</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>int</td>
<td>è¯»å–æ¨¡å¼ï¼ˆè§ä¸‹è¡¨ï¼‰</td>
</tr>
</tbody>
</table>
<p><strong>flagså¸¸ç”¨å€¼:</strong></p>
<ul>
<li><code>cv::IMREAD_COLOR</code> (é»˜è®¤) - è¯»å–å½©è‰²å›¾ï¼Œå¿½ç•¥é€æ˜åº¦</li>
<li><code>cv::IMREAD_GRAYSCALE</code> - è½¬ä¸ºç°åº¦å›¾</li>
<li><code>cv::IMREAD_UNCHANGED</code> - åŒ…å«Alphaé€šé“</li>
</ul>
<h3>ğŸ’» åŸºç¡€ç”¨æ³•</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

int main() {
    // è¯»å–å½©è‰²å›¾ï¼ˆè£…ç”²æ¿è¯†åˆ«ç”¨è¿™ä¸ªï¼‰
    cv::Mat img = cv::imread("armor.jpg", cv::IMREAD_COLOR);
    
    // âš ï¸ å¿…é¡»æ£€æŸ¥æ˜¯å¦è¯»å–æˆåŠŸï¼
    if (img.empty()) {
        std::cout &lt;&lt; "âŒ å›¾ç‰‡è¯»å–å¤±è´¥ï¼" &lt;&lt; std::endl;
        return -1;
    }
    
    // æ‰“å°å›¾ç‰‡ä¿¡æ¯
    std::cout &lt;&lt; "âœ… å›¾ç‰‡è¯»å–æˆåŠŸ" &lt;&lt; std::endl;
    std::cout &lt;&lt; "   å°ºå¯¸: " &lt;&lt; img.cols &lt;&lt; " x " &lt;&lt; img.rows &lt;&lt; std::endl;
    std::cout &lt;&lt; "   é€šé“æ•°: " &lt;&lt; img.channels() &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<h3>ğŸ¯ è¾“å‡ºç¤ºä¾‹</h3>
<pre><code>âœ… å›¾ç‰‡è¯»å–æˆåŠŸ
   å°ºå¯¸: 1280 x 720
   é€šé“æ•°: 3
</code></pre>
<h3>âš ï¸ å¸¸è§é”™è¯¯</h3>
<h4>é”™è¯¯1: è·¯å¾„å†™é”™</h4>
<pre><code>// âŒ Windowsè·¯å¾„æ²¡æœ‰è½¬ä¹‰åæ–œæ 
cv::Mat img = cv::imread("C:\Users\image.jpg");

// âœ… æ­£ç¡®å†™æ³•ï¼ˆä¸‰ç§ä»»é€‰ï¼‰
cv::Mat img = cv::imread("C:\\Users\\image.jpg");     // è½¬ä¹‰åæ–œæ 
cv::Mat img = cv::imread("C:/Users/image.jpg");       // ä½¿ç”¨æ­£æ–œæ 
cv::Mat img = cv::imread(R"(C:\Users\image.jpg)");    // åŸå§‹å­—ç¬¦ä¸²
</code></pre>
<h4>é”™è¯¯2: å¿˜è®°æ£€æŸ¥empty()</h4>
<pre><code>// âŒ å±é™©ï¼å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåç»­æ“ä½œä¼šå´©æºƒ
cv::Mat img = cv::imread("not_exist.jpg");
cv::imshow("Window", img);  // ğŸ’¥ å´©æºƒ

// âœ… æ­£ç¡®å†™æ³•
cv::Mat img = cv::imread("not_exist.jpg");
if (img.empty()) {
    std::cerr &lt;&lt; "æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ ¼å¼ä¸æ”¯æŒ" &lt;&lt; std::endl;
    return -1;
}
</code></pre>
<h3>ğŸ’¡ é‡è¦çŸ¥è¯†ç‚¹</h3>
<blockquote>
<p><strong>OpenCVè¯»å–çš„å›¾ç‰‡æ˜¯BGRæ ¼å¼ï¼Œä¸æ˜¯RGBï¼</strong><br />
è¿™åœ¨åç»­é¢œè‰²è¯†åˆ«æ—¶éå¸¸é‡è¦ã€‚å¦‚æœä½ è¦è½¬RGBéœ€è¦ç”¨ <code>cv::cvtColor()</code></p>
</blockquote>
<hr />
<h2>2. cv::imshow() - æ˜¾ç¤ºå›¾ç‰‡</h2>
<h3>ğŸ“– å‡½æ•°åŸå‹</h3>
<pre><code>void cv::imshow(const String&amp; winname, InputArray mat);
</code></pre>
<h3>ğŸ“‹ å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>ç±»å‹</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>winname</code></td>
<td>string</td>
<td>çª—å£åç§°ï¼ˆè‡ªå·±èµ·åï¼‰</td>
</tr>
<tr>
<td><code>mat</code></td>
<td>Mat</td>
<td>è¦æ˜¾ç¤ºçš„å›¾åƒ</td>
</tr>
</tbody>
</table>
<h3>ğŸ’» åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");

// æ˜¾ç¤ºå›¾ç‰‡
cv::imshow("åŸå›¾", img);

// âš ï¸ å¿…é¡»é…åˆwaitKey()ï¼Œå¦åˆ™çª—å£é—ªç°å³æ¶ˆå¤±ï¼
cv::waitKey(0);  // 0è¡¨ç¤ºæ— é™ç­‰å¾…ï¼Œç›´åˆ°æŒ‰ä»»æ„é”®

// å…³é—­æ‰€æœ‰çª—å£
cv::destroyAllWindows();
</code></pre>
<h3>ğŸ’» æ˜¾ç¤ºå¤šä¸ªçª—å£</h3>
<pre><code>cv::Mat img1 = cv::imread("red_armor.jpg");
cv::Mat img2 = cv::imread("blue_armor.jpg");

cv::imshow("çº¢æ–¹è£…ç”²æ¿", img1);
cv::imshow("è“æ–¹è£…ç”²æ¿", img2);

cv::waitKey(0);
cv::destroyAllWindows();
</code></pre>
<h3>âš ï¸ å¸¸è§é”™è¯¯</h3>
<pre><code>// âŒ é”™è¯¯ï¼šçª—å£é—ªä¸€ä¸‹å°±æ¶ˆå¤±
cv::imshow("Window", img);
// ç¼ºå°‘ waitKey()

// âœ… æ­£ç¡®å†™æ³•
cv::imshow("Window", img);
cv::waitKey(0);
</code></pre>
<hr />
<h2>3. cv::waitKey() - ç­‰å¾…æŒ‰é”®</h2>
<h3>ğŸ“– å‡½æ•°åŸå‹</h3>
<pre><code>int cv::waitKey(int delay = 0);
</code></pre>
<h3>ğŸ“‹ å‚æ•°è¯´æ˜</h3>
<table>
<thead>
<tr>
<th>å‚æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delay</code></td>
<td>ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œ0è¡¨ç¤ºæ— é™ç­‰å¾…</td>
</tr>
<tr>
<td><strong>è¿”å›å€¼</strong></td>
<td>æŒ‰ä¸‹çš„é”®çš„ASCIIç ï¼Œè¶…æ—¶è¿”å›-1</td>
</tr>
</tbody>
</table>
<h3>ğŸ’» å®ç”¨æŠ€å·§</h3>
<h4>æŠ€å·§1: ç­‰å¾…ä»»æ„é”®</h4>
<pre><code>cv::imshow("Image", img);
cv::waitKey(0);  // æŒ‰ä»»æ„é”®ç»§ç»­
</code></pre>
<h4>æŠ€å·§2: æ£€æµ‹ç‰¹å®šæŒ‰é”®</h4>
<pre><code>cv::imshow("Image", img);
int key = cv::waitKey(0);

if (key == 27) {  // ESCé”®
    std::cout &lt;&lt; "ç”¨æˆ·å–æ¶ˆ" &lt;&lt; std::endl;
} else if (key == 's' || key == 'S') {  // Sé”®
    cv::imwrite("saved.jpg", img);
    std::cout &lt;&lt; "å›¾ç‰‡å·²ä¿å­˜" &lt;&lt; std::endl;
}
</code></pre>
<h4>æŠ€å·§3: å®æ—¶è§†é¢‘æ˜¾ç¤ºï¼ˆ30fpsï¼‰</h4>
<pre><code>while (true) {
    cv::Mat frame = getFrame();  // è·å–ä¸€å¸§
    cv::imshow("Video", frame);
    
    // ç­‰å¾…33msï¼ˆçº¦30fpsï¼‰ï¼ŒæŒ‰ESCé€€å‡º
    if (cv::waitKey(33) == 27) break;
}
</code></pre>
<hr />
<h2>4. cv::Mat - å›¾åƒæ•°æ®ç±»å‹</h2>
<h3>ğŸ“– æ ¸å¿ƒæ¦‚å¿µ</h3>
<p><code>cv::Mat</code> æ˜¯OpenCVçš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ª<strong>å¤šç»´æ•°ç»„</strong>ï¼š</p>
<ul>
<li>2Då›¾åƒ = äºŒç»´çŸ©é˜µ</li>
<li>å½©è‰²å›¾åƒ = ä¸‰ç»´çŸ©é˜µï¼ˆå®½Ã—é«˜Ã—é€šé“ï¼‰</li>
</ul>
<h3>ğŸ’» åˆ›å»ºMatå¯¹è±¡</h3>
<h4>æ–¹æ³•1: é€šè¿‡imreadåˆ›å»º</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");
</code></pre>
<h4>æ–¹æ³•2: åˆ›å»ºç©ºç™½å›¾åƒ</h4>
<pre><code>// åˆ›å»º640Ã—480çš„é»‘è‰²å›¾åƒ
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

// åˆ›å»ºç™½è‰²å›¾åƒ
cv::Mat white(480, 640, CV_8UC3, cv::Scalar(255, 255, 255));

// åˆ›å»ºçº¢è‰²å›¾åƒ
cv::Mat red(480, 640, CV_8UC3, cv::Scalar(0, 0, 255));  // BGRæ ¼å¼ï¼
</code></pre>
<h3>ğŸ“‹ å¸¸ç”¨å±æ€§</h3>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// åŸºæœ¬ä¿¡æ¯
int width = img.cols;      // å®½åº¦ï¼ˆåˆ—æ•°ï¼‰
int height = img.rows;     // é«˜åº¦ï¼ˆè¡Œæ•°ï¼‰
int channels = img.channels();  // é€šé“æ•°ï¼ˆ1=ç°åº¦ï¼Œ3=å½©è‰²ï¼‰
bool isEmpty = img.empty();     // æ˜¯å¦ä¸ºç©º

// æ•°æ®ç±»å‹
int type = img.type();     // CV_8UC3 ç­‰
int depth = img.depth();   // CV_8U ç­‰

// å†…å­˜ä¿¡æ¯
size_t total = img.total();    // æ€»åƒç´ æ•° = rows Ã— cols
size_t bytes = img.total() * img.elemSize();  // å ç”¨å­—èŠ‚æ•°
</code></pre>
<h3>ğŸ’» è®¿é—®åƒç´ å€¼</h3>
<h4>æ–¹æ³•1: atè®¿é—®ï¼ˆå®‰å…¨ä½†æ…¢ï¼‰</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// è®¿é—®(100, 200)ä½ç½®çš„åƒç´ 
cv::Vec3b pixel = img.at&lt;cv::Vec3b&gt;(100, 200);
uchar blue = pixel[0];
uchar green = pixel[1];
uchar red = pixel[2];

// ä¿®æ”¹åƒç´ 
img.at&lt;cv::Vec3b&gt;(100, 200) = cv::Vec3b(255, 0, 0);  // è®¾ä¸ºè“è‰²
</code></pre>
<h4>æ–¹æ³•2: æŒ‡é’ˆè®¿é—®ï¼ˆå¿«ä½†éœ€å°å¿ƒï¼‰</h4>
<pre><code>for (int y = 0; y &lt; img.rows; y++) {
    uchar* row = img.ptr&lt;uchar&gt;(y);  // è·å–ç¬¬yè¡Œçš„æŒ‡é’ˆ
    for (int x = 0; x &lt; img.cols; x++) {
        uchar b = row[x * 3 + 0];
        uchar g = row[x * 3 + 1];
        uchar r = row[x * 3 + 2];
    }
}
</code></pre>
<h3>ğŸ“‹ Matç±»å‹ä»£ç è¯´æ˜</h3>
<pre><code>// CV_&lt;bit-depth&gt;{U|S|F}C&lt;channels&gt;
CV_8UC1   // 8ä½æ— ç¬¦å·ï¼Œ1é€šé“ï¼ˆç°åº¦å›¾ï¼‰
CV_8UC3   // 8ä½æ— ç¬¦å·ï¼Œ3é€šé“ï¼ˆBGRå½©è‰²å›¾ï¼‰
CV_32FC1  // 32ä½æµ®ç‚¹ï¼Œ1é€šé“
CV_16SC3  // 16ä½æœ‰ç¬¦å·ï¼Œ3é€šé“
</code></pre>
<hr />
<h2>5. cv::imwrite() - ä¿å­˜å›¾ç‰‡</h2>
<h3>ğŸ“– å‡½æ•°åŸå‹</h3>
<pre><code>bool cv::imwrite(const String&amp; filename, InputArray img);
</code></pre>
<h3>ğŸ’» åŸºç¡€ç”¨æ³•</h3>
<pre><code>cv::Mat img = cv::imread("input.jpg");

// å¤„ç†å›¾åƒ...

// ä¿å­˜ä¸ºJPGï¼ˆæœ‰æŸå‹ç¼©ï¼‰
cv::imwrite("output.jpg", img);

// ä¿å­˜ä¸ºPNGï¼ˆæ— æŸå‹ç¼©ï¼Œæ¨èä¿å­˜äºŒå€¼å›¾ï¼‰
cv::imwrite("binary.png", binaryImg);
</code></pre>
<h3>ğŸ’» è®¾ç½®å‹ç¼©è´¨é‡</h3>
<pre><code>// JPGè´¨é‡æ§åˆ¶ï¼ˆ0-100ï¼Œé»˜è®¤95ï¼‰
std::vector&lt;int&gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // è´¨é‡90%
cv::imwrite("output.jpg", img, jpg_params);

// PNGå‹ç¼©çº§åˆ«ï¼ˆ0-9ï¼Œé»˜è®¤3ï¼‰
std::vector&lt;int&gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // æœ€å¤§å‹ç¼©
cv::imwrite("output.png", img, png_params);
</code></pre>
<hr />
<h2>6. cv::VideoCapture - æ‰“å¼€ç›¸æœº/è§†é¢‘</h2>
<h3>ğŸ“– å‡½æ•°åŸå‹</h3>
<pre><code>cv::VideoCapture cap(int device);         // æ‰“å¼€ç›¸æœº
cv::VideoCapture cap(const String&amp; filename);  // æ‰“å¼€è§†é¢‘æ–‡ä»¶
</code></pre>
<h3>ğŸ’» æ‰“å¼€ç›¸æœº</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    // æ‰“å¼€é»˜è®¤ç›¸æœºï¼ˆè®¾å¤‡ID=0ï¼‰
    cv::VideoCapture cap(0);
    
    // æ£€æŸ¥æ˜¯å¦æˆåŠŸæ‰“å¼€
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "âŒ ç›¸æœºæ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
        return -1;
    }
    
    // è®¾ç½®ç›¸æœºå‚æ•°ï¼ˆå¯é€‰ï¼‰
    cap.set(cv::CAP_PROP_FRAME_WIDTH, 1280);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 720);
    cap.set(cv::CAP_PROP_FPS, 60);
    
    cv::Mat frame;
    while (true) {
        // è¯»å–ä¸€å¸§
        cap.read(frame);
        // æˆ–è€…: cap &gt;&gt; frame;
        
        if (frame.empty()) {
            std::cerr &lt;&lt; "âŒ æ— æ³•è¯»å–å¸§" &lt;&lt; std::endl;
            break;
        }
        
        // æ˜¾ç¤º
        cv::imshow("Camera", frame);
        
        // æŒ‰ESCé€€å‡º
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<h3>ğŸ’» è¯»å–è§†é¢‘æ–‡ä»¶</h3>
<pre><code>cv::VideoCapture cap("video.mp4");

if (!cap.isOpened()) {
    std::cerr &lt;&lt; "è§†é¢‘æ–‡ä»¶æ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
    return -1;
}

// è·å–è§†é¢‘ä¿¡æ¯
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &lt;&lt; "è§†é¢‘ä¿¡æ¯: " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height 
          &lt;&lt; " @ " &lt;&lt; fps &lt;&lt; "fps, å…±" &lt;&lt; frame_count &lt;&lt; "å¸§" &lt;&lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow("Video", frame);
    if (cv::waitKey(1000/fps) == 27) break;  // æŒ‰åŸé€Ÿæ’­æ”¾
}
</code></pre>
<hr />
<h2>ğŸ¯ æœ¬é˜¶æ®µå®æˆ˜ç»ƒä¹ </h2>
<h3>ç»ƒä¹ 1: å›¾ç‰‡æŸ¥çœ‹å™¨</h3>
<p>ç¼–å†™ä¸€ä¸ªç®€å•çš„å›¾ç‰‡æŸ¥çœ‹å™¨ï¼Œæ”¯æŒï¼š</p>
<ul>
<li>è¯»å–å¹¶æ˜¾ç¤ºå›¾ç‰‡</li>
<li>æŒ‰ <code>s</code> ä¿å­˜å›¾ç‰‡å‰¯æœ¬</li>
<li>æŒ‰ <code>ESC</code> é€€å‡º</li>
</ul>
<p>&lt;details&gt;
&lt;summary&gt;ğŸ’¡ å‚è€ƒç­”æ¡ˆ&lt;/summary&gt;</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;

int main(int argc, char** argv) {
    if (argc &lt; 2) {
        std::cout &lt;&lt; "ç”¨æ³•: " &lt;&lt; argv[0] &lt;&lt; " &lt;image_path&gt;" &lt;&lt; std::endl;
        return -1;
    }
    
    cv::Mat img = cv::imread(argv[1]);
    if (img.empty()) {
        std::cerr &lt;&lt; "æ— æ³•è¯»å–å›¾ç‰‡: " &lt;&lt; argv[1] &lt;&lt; std::endl;
        return -1;
    }
    
    std::cout &lt;&lt; "æŒ‰ 's' ä¿å­˜, æŒ‰ ESC é€€å‡º" &lt;&lt; std::endl;
    
    while (true) {
        cv::imshow("å›¾ç‰‡æŸ¥çœ‹å™¨", img);
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 's' || key == 'S') {
            cv::imwrite("saved.jpg", img);
            std::cout &lt;&lt; "å·²ä¿å­˜åˆ° saved.jpg" &lt;&lt; std::endl;
        }
    }
    
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<p>&lt;/details&gt;</p>
<h3>ç»ƒä¹ 2: ç›¸æœºå®æ—¶é¢„è§ˆ</h3>
<p>å®ç°ä¸€ä¸ªç›¸æœºé¢„è§ˆç¨‹åºï¼Œæ˜¾ç¤ºå½“å‰FPS</p>
<p>&lt;details&gt;
&lt;summary&gt;ğŸ’¡ å‚è€ƒç­”æ¡ˆ&lt;/summary&gt;</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "ç›¸æœºæ‰“å¼€å¤±è´¥" &lt;&lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &gt;&gt; frame;
        if (frame.empty()) break;
        
        // è®¡ç®—FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&lt;double&gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // åœ¨å›¾åƒä¸Šç»˜åˆ¶FPS
        std::string fps_text = "FPS: " + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow("Camera Preview", frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<p>&lt;/details&gt;</p>
<hr />
<h2>âœ… æ£€æŸ¥æ¸…å•</h2>
<p>å®Œæˆæœ¬é˜¶æ®µåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š</p>
<ul>
<li>[ ] ç”¨ <code>cv::imread()</code> è¯»å–å›¾ç‰‡å¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸ</li>
<li>[ ] ç”¨ <code>cv::imshow()</code> å’Œ <code>cv::waitKey()</code> æ˜¾ç¤ºå›¾ç‰‡</li>
<li>[ ] ç†è§£Matå¯¹è±¡çš„åŸºæœ¬å±æ€§ï¼ˆrows, cols, channelsï¼‰</li>
<li>[ ] ç”¨ <code>cv::imwrite()</code> ä¿å­˜å¤„ç†ç»“æœ</li>
<li>[ ] ç”¨ <code>cv::VideoCapture</code> æ‰“å¼€ç›¸æœºå¹¶å®æ—¶æ˜¾ç¤º</li>
</ul>
<hr />
<h2>ğŸ“š ä¸‹ä¸€æ­¥</h2>
<p>å®Œæˆæœ¬é˜¶æ®µåï¼Œç»§ç»­å­¦ä¹ ï¼š</p>
<ul>
<li><strong>[02-é¢œè‰²æå–]</strong> - å¦‚ä½•æå–çº¢/è“è‰²ç¯æ¡</li>
<li><strong>[04-è½®å»“æ£€æµ‹]</strong> - å¦‚ä½•æ‰¾åˆ°ç¯æ¡çš„ä½ç½®</li>
</ul>
<hr />
<h2>ğŸ”— å‚è€ƒèµ„æ–™</h2>
<ul>
<li><a href="https://docs.opencv.org/4.x/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">OpenCVå®˜æ–¹æ–‡æ¡£ - imread</a></li>
<li><a href="https://docs.opencv.org/4.x/d3/d63/classcv_1_1Mat.html">OpenCVå®˜æ–¹æ–‡æ¡£ - Mat</a></li>
<li><a href="https://docs.opencv.org/4.x/d8/dfe/classcv_1_1VideoCapture.html">OpenCVå®˜æ–¹æ–‡æ¡£ - VideoCapture</a></li>
</ul>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>æ›´æ–°æ—¥å¿—</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>è¿™é‡Œæ˜¯æ›´æ–°æ—¥å¿—</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>æ›´æ–°äº†ä¸ªäººç®€ä»‹</li>
<li>æ›´æ–°äº†rmç¬”è®°</li>
<li>æ›´æ–°äº†åŒæŒ‡é’ˆçš„æ¡†æ¶</li>
<li>è¯„è®ºæ²¡æŒ‚æœåŠ¡å™¨æ‰€ä»¥ä¸èƒ½ç”¨</li>
</ul>
<h2>2025-10-23</h2>
<ul>
<li>æ›´æ–°äº†å¿«æ…¢æŒ‡é’ˆ</li>
</ul>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="æ—¥å¿—"></category>
  </entry>
  <entry>
    <title>åŒæŒ‡é’ˆ</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>åŒæŒ‡é’ˆå¸¸è§æŠ€å·§</summary>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">å¿«æ…¢æŒ‡é’ˆ</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">äºŒåˆ†æœç´¢</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">æ»‘åŠ¨çª—å£</a></li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">å›æ–‡/åè½¬</a></li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">æ•°ä¹‹å’Œ</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">åŒæŒ‡é’ˆåœ¨é“¾è¡¨çš„è¿ç”¨</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6">åˆå¹¶</a></li>
<li><a href="#%E5%88%86%E8%A7%A3">åˆ†è§£</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">å…¶ä»–</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
</ul>
<hr />
<h2>åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨</h2>
<hr />
<h2>å¿«æ…¢æŒ‡é’ˆ</h2>
<h3>æ•°ç»„çš„åŸåœ°ä¿®æ”¹</h3>
<ul>
<li>åŠ›æ‰£ç¬¬ 26 é¢˜ã€Œåˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ã€ï¼Œè®©ä½ åœ¨æœ‰åºæ•°ç»„å»é‡ï¼š
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</li>
</ul>
<hr />
<ul>
<li>ç»™ä½ ä¸€ä¸ª<strong>éä¸¥æ ¼é€’å¢æ’åˆ—</strong>çš„æ•°ç»„<code>nums</code> ï¼Œè¯·ä½ <strong>åŸåœ°</strong>åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ <strong>åªå‡ºç°ä¸€æ¬¡</strong>ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„<strong>ç›¸å¯¹é¡ºåº</strong>åº”è¯¥ä¿æŒ<strong>ä¸€è‡´</strong>ã€‚ç„¶åè¿”å› <code>nums</code> ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚</li>
<li>è€ƒè™‘ <code>nums </code>çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º <code>k</code>ã€‚å»é‡åï¼Œè¿”å›å”¯ä¸€å…ƒç´ çš„æ•°é‡ kã€‚</li>
<li><code>nums</code> çš„å‰ k ä¸ªå…ƒç´ åº”åŒ…å« æ’åºå çš„å”¯ä¸€æ•°å­—ã€‚ä¸‹æ ‡ <code>k - 1 </code>ä¹‹åçš„å‰©ä½™å…ƒç´ å¯ä»¥å¿½ç•¥ã€‚</li>
</ul>
<p>åˆ¤é¢˜æ ‡å‡†:</p>
<p>ç³»ç»Ÿä¼šç”¨ä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•ä½ çš„é¢˜è§£:</p>
<pre><code>int[] nums = [...]; // è¾“å…¥æ•°ç»„
int[] expectedNums = [...]; // é•¿åº¦æ­£ç¡®çš„æœŸæœ›ç­”æ¡ˆ
int k = removeDuplicates(nums); // è°ƒç”¨
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>å¦‚æœæ‰€æœ‰æ–­è¨€éƒ½é€šè¿‡ï¼Œé‚£ä¹ˆæ‚¨çš„é¢˜è§£å°†è¢«<strong>é€šè¿‡</strong>ã€‚</p>
<p>ç¤ºä¾‹ 1ï¼š</p>
<pre><code>è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š2, nums = [1,2,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2 ï¼Œå¹¶ä¸”åŸæ•°ç»„ nums çš„å‰ä¸¤ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 1, 2 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
</code></pre>
<p>ç¤ºä¾‹ 2ï¼š</p>
<pre><code>è¾“å…¥ï¼šnums = [0,0,1,1,1,2,2,3,3,4]
è¾“å‡ºï¼š5, nums = [0,1,2,3,4,_,_,_,_,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5 ï¼Œ å¹¶ä¸”åŸæ•°ç»„ nums çš„å‰äº”ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 0, 1, 2, 3, 4 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„
</code></pre>
<ul>
<li><strong>åŸåœ°</strong>æ„å‘³ç€åªèƒ½å¯¹å½“å‰æ•°ç»„è¿›è¡Œä¿®æ”¹ï¼Œä¸èƒ½æ–°å»ºä¸€ä¸ªæ•°ç»„</li>
<li>è¿™é‡Œæ‰€éœ€è¦ç”¨åˆ°çš„å°±æ˜¯<strong>å¿«æ…¢æŒ‡é’ˆ</strong></li>
<li>ç®€å•æ¥è¯´å°±æ˜¯ä¸€ä¸ªå¿«æŒ‡é’ˆå»è¯†åˆ«ï¼Œå¦ä¸€ä¸ªæ…¢æŒ‡é’ˆå»æ“ä½œ</li>
<li><strong>æ³¨æ„</strong>  è¿™é‡ŒæŒ‡é’ˆæ˜¯å¹¿ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œæ•°ç»„çš„ç´¢å¼•ä¹Ÿå¯ä»¥æ˜¯<strong>æŒ‡é’ˆ</strong></li>
<li>å¦‚æœ <code>fast</code> é‡åˆ°å€¼ä¸º <code>val </code>çš„å…ƒç´ ï¼Œåˆ™ç›´æ¥è·³è¿‡ï¼Œå¦åˆ™å°±èµ‹å€¼ç»™ <code>slow</code> æŒ‡é’ˆï¼Œå¹¶è®© <code>slow </code>å‰è¿›ä¸€æ­¥ã€‚</li>
</ul>
<p>å…·ä½“ä»£ç å¦‚ä¸‹</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
</code></pre>
<ul>
<li>æ³¨æ„è¿™é‡Œéœ€è¦<strong>å…ˆ<code>slow++</code>å†èµ‹å€¼</strong>ï¼Œè¦ä¸ç„¶ç¬¬ä¸€ä¸ªä¼šè¢«åæ‰</li>
</ul>
<hr />
<ul>
<li>ä¸‹é¢ä¸€é“é¢˜ä¹Ÿæ˜¯å¿«æ…¢æŒ‡é’ˆçš„æ€æƒ³ï¼Œå¦‚æœæŒæ¡äº†å‰ä¸€é“é¢˜ï¼Œè¿™é¢˜ä¼šå¾ˆç®€å•</li>
<li><strong>åŠ›æ‰£283ç§»åŠ¨0</strong>https://leetcode.cn/problems/move-zeroes/</li>
<li>ç»™å®šä¸€ä¸ªæ•°ç»„ <strong>nums</strong>ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚</li>
<li>è¯·æ³¨æ„ ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚</li>
</ul>
<p>ç¤ºä¾‹ 1:</p>
<pre><code>è¾“å…¥: nums = [0,1,0,3,12]
è¾“å‡º: [1,3,12,0,0]
ç¤ºä¾‹ 2:
</code></pre>
<pre><code>è¾“å…¥: nums = [0]
è¾“å‡º: [0]
</code></pre>
<p>è¿™é‡Œæˆ‘å°±ç›´æ¥ä¸Šä»£ç äº†</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int slow = 0;  // æŒ‡å‘ä¸‹ä¸€ä¸ªéé›¶åº”æ”¾ç½®çš„ä½ç½®
        for (int fast = 0; fast &lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow ä¹‹åçš„å…¨éƒ¨ç½®ä¸º 0
        for (int i = slow; i &lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

</code></pre>
<hr />
<h2>äºŒåˆ†æœç´¢</h2>
<ul>
<li>
<p>åœ¨æˆ‘ä»¬éƒ½ç©è¿‡çš„çŒœæ•°å­—æ¸¸æˆä¸­ï¼Œç”¨çš„å°±æ˜¯äºŒåˆ†æœç´ çš„æŠ€å·§</p>
</li>
<li>
<p>æˆ‘ä»¬å…ˆçœ‹æœ€ç¬¨çš„é¡ºåºæŸ¥æ‰¾ï¼Œæˆ‘ä»¬ä»1-100éå†å…¨éƒ¨æ•°å­—ï¼Œè™½ç„¶è¯´è¿æ°”å¥½å¯èƒ½ä¸€ä¸‹ä¼šçŒœä¸­ï¼Œä½†æ˜¯æœŸæœ›çš„æ¬¡æ•°è¿˜æ˜¯å¾ˆå¤šï¼Œå¤æ‚åº¦ä¸ºO(n)</p>
</li>
<li>
<p>å¦‚æœæ˜¯å‡­æ„Ÿè§‰æ‰¾ï¼Œä¸€æ ·è¿˜æ˜¯è¦çœ‹è¿æ°”</p>
</li>
<li>
<p>å¦‚æœç¬¬ä¸€æ¬¡çŒœ50ï¼Œç„¶åç»§ç»­ä¸€åŠä¸€åŠç¼©å°åŒºé—´ï¼Œæœ€åä¹Ÿèƒ½åœ¨7æ¬¡å†…è§£å†³</p>
<ul>
<li>å¦‚ä½•æ•°å­—æ¥åˆ°1-1000000ï¼ŒäºŒåˆ†æœç´¢æœ€å20æ¬¡å°±èƒ½æ‰¾åˆ°ç­”æ¡ˆ</li>
</ul>
</li>
<li>
<p>äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(log  N)</p>
</li>
<li>
<p>ä¸‹é¢æ˜¯æœ€åŸºæœ¬ä»£ç </p>
</li>
</ul>
<pre><code>int binarySearch(vector&lt;int&gt;&amp; nums, int target) {
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    int left = 0, right = nums.size() - 1;
    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; 
        else if (nums[mid] &gt; target)
            right = mid - 1;
    }
    return -1;
}
</code></pre>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="ç®—æ³•"></category>
  </entry>
  <entry>
    <title>è£…ç”²æ¿è‡ªåŠ¨è¯†åˆ«ä¸ä½å§¿ä¼°è®¡å­¦ä¹ </title>
    <link href="https://www.nanye404.top/posts/armor/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>ä¸€äº›å°ç¬”è®°</summary>
    <content type="html"><![CDATA[<h2>ç›®å½•</h2>
<ol>
<li><a href="#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88">æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A">å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š</a></li>
<li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86">ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰</a>
<ul>
<li>4.1 æ•°å­—åˆ†ç±»å™¨ <code>NumberClassifier</code></li>
<li>4.2 è§†è§‰æ£€æµ‹å™¨ <code>Detector</code></li>
<li>4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® <code>LightCornerCorrector</code></li>
<li>4.4 ä½å§¿ä¼°è®¡ <code>ArmorPoseEstimator</code>ï¼ˆPnP + BAï¼‰</li>
<li>4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ <code>BaSolver</code> / <code>GraphOptimizer</code></li>
<li>4.6 ROS2 èŠ‚ç‚¹ <code>ArmorDetectorNode</code></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97">å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96">å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF">å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA">è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰</a></li>
<li><a href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84">æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„</a></li>
</ol>
<hr />
<h2>æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ</h2>
<p><strong>ç›®æ ‡</strong>ï¼šä»ç›¸æœºæ¥çš„å½©è‰²å›¾åƒä¸­ï¼Œè‡ªåŠ¨æ‰¾å‡ºâ€œ<strong>ä¸¤æ ¹ç¯æ¡ç»„æˆçš„è£…ç”²æ¿</strong>â€ï¼Œ<strong>è¯†åˆ«è£…ç”²æ•°å­—</strong>ï¼Œå¹¶ä¼°è®¡è£…ç”²æ¿åœ¨<strong>ç›¸æœºåæ ‡ç³»</strong>ä¸‹çš„ä¸‰ç»´ä½å§¿ï¼ˆä½ç½® + å§¿æ€ï¼‰ï¼Œæœ€åé€šè¿‡ <strong>ROS2</strong> å‘å¸ƒç»“æœä¸å¯è§†åŒ–ã€‚</p>
<p><strong>å…³é”®é˜¶æ®µ</strong>ï¼š</p>
<ol>
<li>å›¾åƒé¢„å¤„ç† â†’ äºŒå€¼åŒ–è½®å»“ â†’ <strong>ç¯æ¡å€™é€‰</strong>ã€‚</li>
<li>ç¯æ¡å‡ ä½•ç­›é€‰ &amp; é¢œè‰²åˆ¤å®š â†’ <strong>ç¯æ¡é…å¯¹æˆè£…ç”²æ¿</strong>ã€‚</li>
<li>é€è§†å±•å¼€ä¸­éƒ¨åŒºåŸŸ â†’ <strong>æ•°å­—åˆ†ç±»</strong>ï¼ˆONNX æ¨¡å‹ï¼‰ã€‚</li>
<li>å¯¹ç¯æ¡ä¸Šä¸‹è§’ç‚¹åš<strong>å‡ ä½•ç»†åŒ–</strong>ï¼ˆæå‡ PnP ç¨³å®šæ€§ï¼‰ã€‚</li>
<li>ç”¨ <strong>PnP æ±‚åˆè§£</strong> â†’ æ¡ä»¶å…è®¸æ—¶ç”¨ **BAï¼ˆä»…ä¼˜åŒ– yawï¼‰**åšå°ä¼˜åŒ–ã€‚</li>
<li>å°è£…ä¸º ROS2 èŠ‚ç‚¹ï¼š<strong>è®¢é˜…å›¾åƒ/ç›¸æœºå†…å‚/TF</strong>ï¼Œå‘å¸ƒè°ƒè¯•å›¾åƒä¸ <strong>Marker</strong>ã€‚</li>
</ol>
<hr />
<h2>å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š</h2>
<ul>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;å›¾åƒè¯»å–ä¸æ˜¾ç¤º&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &lt;/a&gt;</li>
</ul>
<h2>ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰</h2>
<pre><code>Image(rgb8)
   â””â”€â–º é¢„å¤„ç†(ç°åº¦/é˜ˆå€¼)
          â””â”€â–º è½®å»“â†’ç¯æ¡(Light)
                 â””â”€â–º åŒè‰² + å‡ ä½•å…³ç³» â†’ è£…ç”²(Armor)
                        â”œâ”€â–º (å¯é€‰) ç¯æ¡è§’ç‚¹ç²¾ä¿®
                        â”œâ”€â–º é€è§†å±•å¼€æ•°å­—ROI â†’ äºŒå€¼åŒ– â†’ åˆ†ç±»
                        â””â”€â–º PnPæ±‚ä½å§¿ â†’ (å¯é€‰) BAä¼˜åŒ–yaw
                               â””â”€â–º å‘å¸ƒArmors + RViz Marker + è°ƒè¯•å›¾åƒ
</code></pre>
<hr />
<h2>æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰</h2>
<h3>4.1 æ•°å­—åˆ†ç±»å™¨ <code>NumberClassifier</code></h3>
<p><strong>èŒè´£</strong>ï¼šä»è£…ç”²æ¿ä¸¤æ ¹ç¯æ¡ä¹‹é—´è£å‡ºæ•°å­—å›¾ï¼ˆå›ºå®šå°ºå¯¸ï¼‰ï¼ŒäºŒå€¼åŒ–åå–‚ç»™ ONNX åˆ†ç±»ç½‘ç»œï¼Œå¾—åˆ°ç±»åˆ«ä¸ç½®ä¿¡åº¦ã€‚</p>
<p><strong>æ ¸å¿ƒï¼šé€è§†å±•å¼€ + äºŒå€¼åŒ– + DNN å‰å‘</strong></p>
<pre><code>// é€è§†å±•å¼€å¹¶è£ ROIï¼ˆå®½åº¦éšå¤§å°è£…ç”²è€Œå˜ï¼‰
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp; src, const Armor&amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // ä¸­éƒ¨ ROI â†’ ç°åº¦&amp;OTSU â†’ 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
</code></pre>
<pre><code>// å‰å‘åˆ†ç±» + ç»“æœè§£ç 
void NumberClassifier::classify(const cv::Mat&amp;, Armor&amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;conf, nullptr, &amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format("{}:{:.1f}%", armor.number, armor.confidence * 100.0);
}
</code></pre>
<pre><code>// è¿‡æ»¤ï¼šæŒ‰é˜ˆå€¼/å¿½ç•¥åˆ—è¡¨ + å¤§å°è£…ç”²ä¸ç±»åˆ«çš„äº’æ–¥è§„åˆ™
void NumberClassifier::eraseIgnoreClasses(std::vector&lt;Armor&gt;&amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;a) {
    if (a.confidence &lt; threshold) return true;
    for (auto&amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == "outpost" || a.number == "2" || a.number == "sentry");
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == "1"      || a.number == "base");
    return mismatch;
  }), armors.end());
}
</code></pre>
<p><strong>è¦ç‚¹</strong>ï¼šROI å®½åº¦ä¸è£…ç”²å°ºå¯¸åŒ¹é…ï¼›OTSU è®©é˜ˆå€¼æ›´ç¨³ï¼›<code>blobFromImage</code> å°è£…å½’ä¸€åŒ–ä¸ NHWCâ†’NCHWã€‚</p>
<hr />
<h3>4.2 è§†è§‰æ£€æµ‹å™¨ <code>Detector</code></h3>
<p><strong>èŒè´£</strong>ï¼šç°åº¦/é˜ˆå€¼ â†’ è½®å»“ â†’ ç¯æ¡ï¼ˆå½¢çŠ¶ + å€¾è§’ï¼‰â†’ ç»Ÿè®¡é¢œè‰² â†’ å·¦å³åŒè‰²é…å¯¹ â†’ è£…ç”²ã€‚è‹¥æœ‰åˆ†ç±»å™¨ä¸è§’ç‚¹ä¿®æ­£å™¨ï¼Œåˆ™å¹¶è¡Œè¿›è¡Œæ•°å­—åˆ†ç±»ä¸è§’ç‚¹ç»†åŒ–ã€‚</p>
<p><strong>æ€»ä½“æµç¨‹</strong></p>
<pre><code>std::vector&lt;Armor&gt; Detector::detect(const cv::Mat&amp; input) noexcept {
  binary_img = preprocessImage(input);               // ç°åº¦+å›ºå®šé˜ˆå€¼
  lights_    = findLights(input, binary_img);        // è½®å»“â†’Lightï¼ˆæ¯”ä¾‹/è§’åº¦/é¢œè‰²ï¼‰
  armors_    = matchLights(lights_);                 // å·¦å³é…å¯¹ â†’ Armor

  if (!armors_.empty() &amp;&amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;input](Armor&amp; a){
      a.number_img = classifier-&gt;extractNumber(input, a);
      classifier-&gt;classify(input, a);
      if (corner_corrector) corner_corrector-&gt;correctCorners(a, gray_img_);
    });
    classifier-&gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
</code></pre>
<p><strong>å…³é”®åˆ¤å®šï¼šç¯æ¡ä¸é…å¯¹</strong></p>
<pre><code>// ç¯æ¡ç­›é€‰ï¼šçŸ­é•¿è¾¹æ¯” + å€¾è§’
bool Detector::isLight(const Light&amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &lt; ratio &amp;&amp; ratio &lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &lt; light_params.max_angle;
  return ratio_ok &amp;&amp; angle_ok;
}

// é¢œè‰²ï¼šåœ¨è½®å»“åƒç´ ä¸­ç»Ÿè®¡R/Bå¼ºåº¦å·®ï¼ˆçº¢/è“ï¼‰
for (auto&amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &gt; light_params.color_diff_thresh)
  light.color = (sum_r &gt; sum_b ? RED : BLUE);

// å¤¹ç¯æ£€æµ‹ï¼šä¸¤ç¯æ¡å¤–æ¥çŸ©å½¢å†…æ˜¯å¦è¿˜â€œå¤¹â€ç€åˆ«çš„ç¯æ¡ï¼ˆä¸”æ’é™¤æ•°å­—/çº¢ç‚¹ç­‰å¹²æ‰°ï¼‰
bool containLight(int i, int j, const std::vector&lt;Light&gt;&amp; lights);

// é…å¯¹ï¼šåŒè‰² + Xæ–¹å‘æ‰«æ + ä¸­å¿ƒè·çª—å£ï¼ˆåŒºåˆ†å¤§å°è£…ç”²ï¼‰+ ä¸¤ç¯æ¡é•¿åº¦ç›¸è¿‘ + å¤¹è§’é™åˆ¶
std::vector&lt;Armor&gt; Detector::matchLights(const std::vector&lt;Light&gt;&amp; lights) noexcept;
</code></pre>
<hr />
<h3>4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® <code>LightCornerCorrector</code></h3>
<p><strong>èŒè´£</strong>ï¼šæ›´ç²¾ç¡®åœ°æ‰¾åˆ°æ¯æ ¹ç¯æ¡çš„<strong>ä¸Šä¸‹ç«¯ç‚¹</strong>ä¸<strong>ä¸­å¿ƒ/è½´å‘</strong>ï¼Œæå‡ PnP çš„ 2D-3D å¯¹åº”ç²¾åº¦ï¼ˆåœ¨äºŒå€¼åŒ–æˆ–å™ªå£°ç¯å¢ƒä¸‹å°¤å…¶æœ‰ç”¨ï¼‰ã€‚</p>
<p><strong>ç®—æ³•æ€è·¯</strong>ï¼š</p>
<ol>
<li>ä»¥ç¯æ¡å¤–æ¥æ¡†ä¸ºåŸºç¡€åš<strong>é€‚åº¦æ‰©å±•</strong>å¹¶æ£€æŸ¥è¾¹ç•Œï¼›</li>
<li>å¯¹è¯¥å°åŒºåŸŸåš<strong>é‡å¿ƒä¸ä¸»æ–¹å‘</strong>ä¼°è®¡ï¼ˆäº®åº¦åŠ æƒ + PCA/ä¸€é˜¶çŸ©ï¼‰ï¼Œå¾—åˆ°<strong>å¯¹ç§°è½´</strong>ï¼›</li>
<li>æ²¿å¯¹ç§°è½´çš„ä¸Šä¸‹æ–¹å‘ï¼Œä»¥å¤šä¸ªå¹³è¡Œâ€œæ‰«æçº¿â€å¯»æ‰¾<strong>äº®åº¦çªå˜æœ€å¤§</strong>çš„ä½ç½®ä½œä¸ºç«¯ç‚¹å€™é€‰ï¼Œæœ€åæ±‚å¹³å‡ã€‚</li>
</ol>
<p><strong>è¦ç‚¹ä»£ç </strong></p>
<pre><code>// è§’ç‚¹ä¿®æ­£å…¥å£ï¼šå®½åº¦å¤ªå°åˆ™è·³è¿‡ï¼Œé¿å…å™ªå£°
void LightCornerCorrector::correctCorners(Armor&amp; armor, const cv::Mat&amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp; è§’ç‚¹ */ }
  if (armor.right_light.width &gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp; è§’ç‚¹ */ }
}

// æ²¿å¯¹ç§°è½´å¯»æ‰¾â€œäº®åº¦çªå˜æœ€å¤§â€çš„ç‚¹ä½œä¸ºè§’ç‚¹ï¼ˆå¤šæ¡å¹³è¡Œçº¿ï¼Œå–å€™é€‰å¹³å‡ï¼‰
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp; gray, const Light&amp; light,
                                             const SymmetryAxis&amp; axis, std::string order) {
  // ... æ‰«æ START~END çš„å°æ®µï¼Œç´¯è®¡äº®åº¦å·®æœ€å¤§å¤„ ...
  // è¿”å›å‡å€¼ç‚¹ï¼›æ— å€™é€‰åˆ™è¿”å› (-1,-1)
}
</code></pre>
<hr />
<h3>4.4 ä½å§¿ä¼°è®¡ <code>ArmorPoseEstimator</code>ï¼ˆPnP + BAï¼‰</h3>
<p><strong>èŒè´£</strong>ï¼šæŠŠè£…ç”²å››è§’çš„ 2D åƒç´ ç‚¹ä¸å·²çŸ¥ 3D æ¨¡å‹ç‚¹ï¼ˆå¤§/å°è£…ç”²çš„çœŸå®å°ºå¯¸ï¼‰å¯¹åº”ï¼Œè§£å‡º R/tã€‚è‹¥ roll å°ä¸”å¼€å¯ BAï¼Œåˆ™è¿›ä¸€æ­¥ä»…åœ¨ <strong>yaw</strong> ç»´è¿›è¡Œå›¾ä¼˜åŒ–ï¼Œä½¿æŠ•å½±è¯¯å·®æ›´å°ã€‚</p>
<p><strong>æ ¸å¿ƒæµç¨‹</strong></p>
<pre><code>// 1) PnP åˆè§£ï¼ˆsolvePnPGeneric å¯èƒ½è¿”å›ä¸¤ç»„è§£ï¼‰
if (pnp_solver_-&gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) è§£çš„é€‰æ‹©ï¼ˆè¯¯å·®/roll/ç¯æ¡å€¾è§’â†’yawæ­£è´Ÿï¼‰

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;&amp; roll &lt; 15) {
    // 3) BAï¼šä»…ä¼˜åŒ– yawï¼Œå°å¹…ä¿®æ­£ R ä»¥å‡å°æŠ•å½±è¯¯å·®
    R = ba_solver_-&gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) å¡«å……æ¶ˆæ¯ï¼ˆä½å§¿ + æ–‡æœ¬ï¼‰
}
</code></pre>
<p><strong>ä¸¤è§£é€‰æ‹©ï¼ˆç›´è§‰ï¼‰</strong>ï¼š</p>
<ul>
<li>å…ˆçœ‹<strong>é‡æŠ•å½±è¯¯å·®</strong>ä¸ <strong>roll</strong>ï¼ˆå¤ªå·®çš„è§£ç›´æ¥æ”¾å¼ƒåˆ‡æ¢ï¼‰ï¼›</li>
<li>å†ç”¨<strong>ç¯æ¡åœ¨åƒé¢ä¸Šçš„æ•´ä½“å€¾æ–œ</strong>æ¥åˆ¤æ–­å½“å‰<strong>yaw çš„æ­£è´Ÿæ˜¯å¦â€œåˆç†â€</strong>ï¼Œå¿…è¦æ—¶å¯¹è°ƒè§£ã€‚</li>
</ul>
<hr />
<h3>4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ <code>BaSolver</code> / <code>GraphOptimizer</code></h3>
<p><strong>æ€æƒ³</strong>ï¼šåªæŠŠ<strong>è£…ç”² yaw</strong> å½“æˆä¼˜åŒ–å˜é‡ï¼ˆä¸€ä¸ªé¡¶ç‚¹ <code>VertexYaw</code>ï¼‰ï¼Œè£…ç”²çš„ 3D è§’ç‚¹ä¸ºå›ºå®šé¡¶ç‚¹ã€‚è§‚æµ‹ä¸ºæ¯ä¸ªè§’ç‚¹åœ¨å›¾åƒé‡Œçš„åƒç´ ä½ç½®ï¼Œè¯¯å·®å°±æ˜¯<strong>è§‚æµ‹åƒç´ </strong>å‡å»<strong>æŠ•å½±åƒç´ </strong>ã€‚è¿™æ · BA æ—¢è½»é‡åˆèƒ½ç¨³ä½å§¿æ€ã€‚</p>
<p><strong>æ„å›¾ä¸ä¼˜åŒ–</strong></p>
<pre><code>// å¡«å›¾ï¼šä¸€ä¸ª yaw é¡¶ç‚¹ + å››ä¸ªå›ºå®šçš„ 3D é¡¶ç‚¹ + å››æ¡æŠ•å½±è¯¯å·®è¾¹ï¼ˆå¸¦ Huber é²æ£’æ ¸ï¼‰
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&gt;setVertex(0, v_yaw); e-&gt;setVertex(1, vp);
  e-&gt;setMeasurement(pixel_observation);
  e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
</code></pre>
<pre><code>// è‡ªå®šä¹‰é¡¶ç‚¹å¢é‡ï¼šåœ¨ SO3 ä¸Šç”¨æä»£æ•°æ›´æ–° yawï¼Œé¿å…è§’åº¦è·³å˜
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
</code></pre>
<pre><code>// æŠ•å½±è¾¹è¯¯å·®ï¼šåƒç´ è§‚æµ‹ - æŠ•å½±(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&lt;VertexYaw*&gt;(_vertices[0])-&gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&lt;2&gt;();
  _error = obs - proj;
}
</code></pre>
<hr />
<h3>4.6 ROS2 èŠ‚ç‚¹ <code>ArmorDetectorNode</code></h3>
<p><strong>èŒè´£</strong>ï¼šæŠŠæ£€æµ‹ â†’ åˆ†ç±» â†’ï¼ˆå¯é€‰ï¼‰è§’ç‚¹ä¿®æ­£ â†’ PnP/BA â†’ å‘å¸ƒå¯è§†åŒ–ï¼Œå…¨æµç¨‹åœ¨ ROS2 ä¸­è·‘èµ·æ¥ã€‚è´Ÿè´£ï¼šå‚æ•°ã€è®¢é˜…/å‘å¸ƒã€TFã€è°ƒè¯•ã€‚</p>
<p><strong>èŠ‚ç‚¹åˆå§‹åŒ–ï¼ˆèŠ‚é€‰ï¼‰</strong></p>
<pre><code>// è¯»å–å‚æ•°ï¼Œåˆå§‹åŒ– Detectorã€NumberClassifierã€LightCornerCorrector
int binary_thres = declare_parameter("binary_thres", 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&lt;Detector&gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/lenet.onnx");
auto label_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/label.txt");
double threshold = declare_parameter("classifier_threshold", 0.7);
auto ignores = declare_parameter&lt;std::vector&lt;std::string&gt;&gt;("ignore_classes", {"negative"});
detector_-&gt;classifier = std::make_unique&lt;NumberClassifier&gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter("use_pca", true);
if (use_pca) detector_-&gt;corner_corrector = std::make_unique&lt;LightCornerCorrector&gt;();
</code></pre>
<p><strong>å›¾åƒå›è°ƒï¼ˆèŠ‚é€‰ï¼‰</strong></p>
<pre><code>// 1) TF: odom â†’ ç›¸æœºçš„æ—‹è½¬çŸ©é˜µï¼ˆIMUâ†’Cameraï¼‰
auto odom_to_cam = tf2_buffer_-&gt;lookupTransform(odom_frame_, img_msg-&gt;header.frame_id, img_msg-&gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) æ£€æµ‹ + åˆ†ç±» + è§’ç‚¹ä¿®æ­£
auto armors = detector_-&gt;detect(cv_bridge::toCvShare(img_msg, "rgb8")-&gt;image);

// 3) PnP/BA æå–ä½å§¿
armors_msg_.armors = armor_pose_estimator_-&gt;extractArmorPoses(armors, imu_to_camera);

// 4) å¯è§†åŒ–ä¸å‘å¸ƒï¼šMarker / è°ƒè¯•å›¾åƒ / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&gt;publish(armors_msg_);
</code></pre>
<hr />
<h2>å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰</h2>
<ul>
<li><code>binary_thres</code>ï¼šé˜ˆå€¼é«˜â†’å™ªç‚¹å°‘ä½†ç¯æ¡å¯èƒ½æ–­ï¼›é˜ˆå€¼ä½â†’è¿é€šåŸŸç²˜è¿ã€‚å…ˆæ‰“å¼€è°ƒè¯•å›¾åƒè¯é¢˜è§‚å¯Ÿå†è°ƒã€‚</li>
<li><code>light.min_ratio / max_ratio / max_angle</code>ï¼šæ§åˆ¶ç¯æ¡çš„â€œç»†é•¿â€å’Œâ€œè¿‘å‚ç›´â€ç¨‹åº¦ï¼›è¯¯æ£€å¤šå°±æ”¶ç´§ï¼Œæ¼æ£€å¤šå°±æ”¾å®½ã€‚</li>
<li><code>light.color_diff_thresh</code>ï¼šè¶Šå¤§è¶Šâ€œä¿å®ˆâ€åœ°åˆ¤æ–­é¢œè‰²ï¼›å¤ªå°ä¼šæŠŠæ‚æ•£å…‰å½“æˆçº¢/è“ã€‚</li>
<li><code>armor.*_center_distance</code>ï¼šä¸¤ç¯æ¡ä¸­å¿ƒè·çª—å£ï¼›ä¸ç„¦è·/è·ç¦»æœ‰å…³ï¼Œé•œå¤´å˜åŒ–åè¦é‡è°ƒã€‚</li>
<li><code>classifier_threshold / ignore_classes</code>ï¼šåˆ†ç±»é˜ˆå€¼ä¸å¿½ç•¥ç±»ï¼Œå…ˆæ¾åç´§ï¼Œç»“åˆå®æµ‹æ··æ·†å†æ”¶æ•›ã€‚</li>
<li><code>use_pca</code>ï¼šè§’ç‚¹ä¿®æ­£ï¼Œå™ªå£°ç¯å¢ƒæˆ–åˆ†è¾¨ç‡ä¸é«˜æ—¶å¸¸æœ‰å¸®åŠ©ã€‚</li>
<li><code>use_ba</code>ï¼šè½»é‡çš„ yaw ä¼˜åŒ–ï¼Œèƒ½å‡æŠ–ã€ç¨³å§¿æ€ï¼›ä½†åœ¨æç«¯è§†è§’ä¸‹å¯èƒ½æ”¶ç›Šæœ‰é™ã€‚</li>
</ul>
<hr />
<h2>å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–</h2>
<ol>
<li><strong>å‡†å¤‡</strong>ï¼šç›¸æœºè¯é¢˜ <code>image_raw</code>ã€<code>camera_info</code>ï¼Œå¹¶ç¡®è®¤ TF é“¾è·¯ï¼ˆ<code>odom â†’ camera</code>ï¼‰ã€‚</li>
<li><strong>å¯åŠ¨èŠ‚ç‚¹</strong>ï¼šåŠ è½½å‚æ•°ï¼ˆä¸Šé¢æåˆ°çš„é˜ˆå€¼ä¸çª—å£ï¼‰å¹¶æ‰“å¼€ <code>debug</code>ã€‚</li>
<li><strong>RViz</strong>ï¼šæ·»åŠ  <code>MarkerArray</code> è®¢é˜… <code>armor_detector/marker</code>ï¼›æŠŠè°ƒè¯•å›¾åƒè¯é¢˜ï¼ˆ<code>binary_img/number_img/result_img</code>ï¼‰ä¹Ÿå¼€å‡ºæ¥ã€‚</li>
<li><strong>è§‚å¯Ÿä¸è°ƒæ•´</strong>ï¼š
<ul>
<li>å…ˆè®©<strong>ç¯æ¡å€™é€‰</strong>ç¨³å®š â†’ å†çœ‹<strong>é…å¯¹</strong>æ˜¯å¦åˆç† â†’ æœ€åçœ‹<strong>æ•°å­—åˆ†ç±»</strong>ä¸<strong>ä½å§¿</strong>æ˜¯å¦ç¨³å®šã€‚</li>
<li>é€é¡¹å¾®è°ƒå‚æ•°ï¼Œè®°å½•æ¯é¡¹è°ƒæ•´å¯¹å¬å›/ç²¾åº¦çš„å½±å“ã€‚</li>
</ul>
</li>
</ol>
<hr />
<h2>å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯</h2>
<ul>
<li><strong>ç¯æ¡â€œå¤¹ç¯â€/è¯¯é…å¯¹</strong>ï¼šæ£€æŸ¥ <code>containLight</code> è§„åˆ™ä¸æ•°å­—/çº¢ç‚¹å®½åº¦è¿‡æ»¤ï¼›é€‚å½“æé«˜ <code>color_diff_thresh</code>ã€‚</li>
<li><strong>åˆ†ç±»ä¸ç¨³</strong>ï¼šå¯¹æ¯” <code>number_img</code> æ˜¯å¦å¹²å‡€ï¼›æ£€æŸ¥ ROI å®½åº¦æ˜¯å¦ä¸å¤§/å°è£…ç”²ä¸€è‡´ï¼›é€‚å½“è°ƒé˜ˆå€¼æˆ–å¿½ç•¥ç±»ã€‚</li>
<li><strong>ä½å§¿â€œç¿»é¢â€</strong>ï¼šç†è§£ <code>sortPnPResult</code> çš„é€‰æ‹©é€»è¾‘ï¼ˆè¯¯å·®ã€rollã€ç¯æ¡å€¾è§’ä¸ yaw æ­£è´Ÿï¼‰ï¼Œå¿…è¦æ—¶åœ¨è¿‘æ™¯è´´çº¸çº¹ç†ä¸Šåšè¾…åŠ©ã€‚</li>
<li><strong>å§¿æ€æŠ–åŠ¨</strong>ï¼šå¼€å¯ <code>use_ba</code>ï¼›æˆ–åœ¨ <code>LightCornerCorrector</code> ä¸­åŠ å¤§å€™é€‰æ¡æ•°ã€‚</li>
</ul>
<hr />
<h2>è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰</h2>
<ol>
<li><strong>æŠŠé˜ˆå€¼æ”¹æˆè‡ªé€‚åº”</strong>ï¼šå°è¯• <code>cv::adaptiveThreshold</code> æˆ–æ ¹æ®åŒºåŸŸäº®åº¦åŠ¨æ€è°ƒ <code>binary_thres</code>ã€‚</li>
<li><strong>åŠ å…¥æ—¶åºç¨³å®š</strong>ï¼šåœ¨ <code>Detector</code> è¾“å‡ºä¸Šåšè·Ÿè¸ªï¼ˆKalman/åŒˆç‰™åˆ©åŒ¹é…ï¼‰ï¼Œè®©æ•°å­—ä¸å§¿æ€åœ¨å¸§é—´æ›´ç¨³ã€‚</li>
<li><strong>æ•°æ®å¢å¼ºä¸å†è®­ç»ƒ</strong>ï¼šå¯¹ <code>number_img</code> åšéšæœºä»¿å°„/å™ªå£°å¢å¼ºï¼Œå¾®è°ƒ ONNX æ¨¡å‹ï¼Œè§‚å¯Ÿæ··æ·†ç±»çš„æ”¹å–„ã€‚</li>
<li><strong>å¤šç›®æ ‡é€‰æ‹©ç­–ç•¥</strong>ï¼šå½“åŒå±å¤šå—è£…ç”²æ—¶ï¼ŒåŸºäº <code>distance_to_image_center</code>ã€ç½®ä¿¡åº¦æˆ–å†å² ID é€‰æ‹©ç›®æ ‡ã€‚</li>
</ol>
<hr />
<h2>æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„</h2>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>è§†é¢‘æµ‹è¯•</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>è§†é¢‘æµ‹è¯•ã€‚</summary>
    <content type="html"><![CDATA[<p>è¿™æ˜¯è§†é¢‘æµ‹è¯•</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>å—å¶é…±</name>
    </author>
    <category term="æµ‹è¯•"></category>
  </entry>
</feed>