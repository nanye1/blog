<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南叶の小窝</title>
  <subtitle>欢迎来玩awa</subtitle>
  <link href="https://www.nanye404.top/" rel="alternate" type="text/html"/>
  <link href="https://www.nanye404.top/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://www.nanye404.top/</id>
  <updated>2025-10-24T15:52:44.637Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>RM装甲板识别 - 03 形态学处理</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_03/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_03/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::getStructuringElement()</code></td>
<td>创建形态学核</td>
</tr>
<tr>
<td><code>cv::dilate()</code></td>
<td>膨胀（变胖）</td>
</tr>
<tr>
<td><code>cv::erode()</code></td>
<td>腐蚀（变瘦）</td>
</tr>
<tr>
<td><code>cv::morphologyEx()</code></td>
<td>高级形态学</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<p>颜色提取后的二值图有两个主要问题：</p>
<h3>问题1: 噪点（小白点到处都是）</h3>
<h3>问题2: 断裂（灯条中间有缝隙）</h3>
<p><strong>形态学操作就是解决这些问题的工具！</strong></p>
<hr />
<h2>形态学四种处理方式</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>效果</th>
<th>比喻</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>膨胀 dilate</strong></td>
<td>白色区域变大</td>
<td>涂胖笔</td>
<td>连接断裂</td>
</tr>
<tr>
<td><strong>腐蚀 erode</strong></td>
<td>白色区域变小</td>
<td>橡皮擦</td>
<td>去除噪点</td>
</tr>
<tr>
<td><strong>开运算 open</strong></td>
<td>先腐蚀后膨胀</td>
<td>先擦后涂</td>
<td>去噪保形</td>
</tr>
<tr>
<td><strong>闭运算 close</strong></td>
<td>先膨胀后腐蚀</td>
<td>先涂后擦</td>
<td>填缝保形</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::getStructuringElement() - 创建形态学核</h2>
<h3>函数原型</h3>
<pre><code>Mat cv::getStructuringElement(int shape, Size ksize, 
                               Point anchor = Point(-1,-1));
</code></pre>
<h3>核形状类型</h3>
<table>
<thead>
<tr>
<th>shape</th>
<th>说明</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_RECT</code></td>
<td>矩形（最常用）</td>
<td>各方向均匀</td>
</tr>
<tr>
<td><code>MORPH_ELLIPSE</code></td>
<td>椭圆形</td>
<td>边缘更圆滑</td>
</tr>
<tr>
<td><code>MORPH_CROSS</code></td>
<td>十字形</td>
<td>只作用于上下左右</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>// 创建3×3矩形核
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 创建5×5椭圆核
cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));

// 创建7×7十字核
cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(7, 7));
</code></pre>
<h3>核大小如何选择？</h3>
<table>
<thead>
<tr>
<th>尺寸</th>
<th>效果</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>3×3</td>
<td>轻微处理</td>
<td>小噪点、细微缝隙</td>
</tr>
<tr>
<td>5×5</td>
<td>中等效果</td>
<td><strong>推荐</strong>，平衡效果和性能</td>
</tr>
<tr>
<td>7×7</td>
<td>强力效果</td>
<td>大噪点、大缝隙（可能破坏灯条形状）</td>
</tr>
<tr>
<td>9×9+</td>
<td>极强效果</td>
<td>慎用！容易把灯条变形</td>
</tr>
</tbody>
</table>
<hr />
<h2>2. cv::dilate() - 膨胀操作</h2>
<h3>函数原型</h3>
<pre><code>void cv::dilate(InputArray src, OutputArray dst, InputArray kernel,
                Point anchor = Point(-1,-1), int iterations = 1);
</code></pre>
<h3>📋 参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src</code></td>
<td>输入二值图</td>
</tr>
<tr>
<td><code>dst</code></td>
<td>输出结果</td>
</tr>
<tr>
<td><code>kernel</code></td>
<td>形态学核</td>
</tr>
<tr>
<td><code>anchor</code></td>
<td>锚点位置（-1,-1表示中心）</td>
</tr>
<tr>
<td><code>iterations</code></td>
<td>迭代次数（重复膨胀几次）</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 腐蚀一次
cv::Mat eroded;
cv::erode(binary, eroded, kernel);

cv::imshow("原始二值图", binary);
cv::imshow("腐蚀后", eroded);
cv::waitKey(0);
</code></pre>
<h3>应用场景</h3>
<ul>
<li>去除小噪点</li>
<li>分离粘连物体</li>
</ul>
<h3>腐蚀的副作用</h3>
<ul>
<li>灯条也会变细</li>
<li>解决方案：腐蚀后再膨胀回来（开运算）</li>
</ul>
<hr />
<h2>4. cv::morphologyEx() - 高级形态学操作</h2>
<h3>函数原型</h3>
<pre><code>void cv::morphologyEx(InputArray src, OutputArray dst, int op,
                      InputArray kernel, Point anchor = Point(-1,-1),
                      int iterations = 1);
</code></pre>
<h3>操作类型</h3>
<table>
<thead>
<tr>
<th>op</th>
<th>操作</th>
<th>公式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MORPH_OPEN</code></td>
<td>开运算</td>
<td>erode → dilate</td>
<td><strong>去噪保形</strong></td>
</tr>
<tr>
<td><code>MORPH_CLOSE</code></td>
<td>闭运算</td>
<td>dilate → erode</td>
<td><strong>填缝保形</strong></td>
</tr>
<tr>
<td><code>MORPH_GRADIENT</code></td>
<td>形态学梯度</td>
<td>dilate - erode</td>
<td>提取边缘</td>
</tr>
<tr>
<td><code>MORPH_TOPHAT</code></td>
<td>顶帽</td>
<td>src - open</td>
<td>提取小亮点</td>
</tr>
<tr>
<td><code>MORPH_BLACKHAT</code></td>
<td>黑帽</td>
<td>close - src</td>
<td>提取小暗点</td>
</tr>
</tbody>
</table>
<hr />
<h2>5. 闭运算 (MORPH_CLOSE)</h2>
<h3>工作原理</h3>
<ul>
<li>闭运算 = 先膨胀 → 再腐蚀</li>
</ul>
<h3>基础用法</h3>
<pre><code>cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// 闭运算
cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);

cv::imshow("原始", binary);
cv::imshow("闭运算后", closed);
cv::waitKey(0);
</code></pre>
<h3>应用场景</h3>
<ul>
<li>连接灯条的细微断裂</li>
<li>填补灯条内部的小黑洞</li>
<li>保持灯条的整体形状</li>
</ul>
<h3>注意事项</h3>
<pre><code>// 核太大会让两个灯条粘在一起！
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
//  可能导致左右灯条合并

// 推荐使用5×5或7×7
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
</code></pre>
<hr />
<h2>6. 开运算 (MORPH_OPEN) - 去噪利器</h2>
<h3>工作原理</h3>
<ul>
<li>开运算 = 先腐蚀 → 再膨胀</li>
</ul>
<h3>基础用法</h3>
<pre><code>cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 开运算
cv::Mat opened;
cv::morphologyEx(binary, opened, cv::MORPH_OPEN, kernel);
</code></pre>
<h3>应用场景</h3>
<ul>
<li>去除小噪点</li>
<li>分离轻微粘连的物体</li>
<li>平滑物体边缘</li>
</ul>
<hr />
<h2>7. RM装甲板识别推荐流程</h2>
<h3>标准流程（两步法）</h3>
<pre><code>cv::Mat processArmor(const cv::Mat&amp; img) {
    // 1. 颜色提取
    cv::Mat binary = extractColor(img);  // 从第02章获得
    
    // 2. 形态学处理
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 第一步：闭运算（填补灯条缝隙）
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // 第二步：开运算（去除噪点）
    cv::Mat result;
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    return result;
}
</code></pre>
<hr />
<h2>8. 形态学梯度 (MORPH_GRADIENT)</h2>
<h3>工作原理</h3>
<pre><code>梯度 = 膨胀 - 腐蚀
</code></pre>
<h3>基础用法</h3>
<pre><code>cv::Mat gradient;
cv::morphologyEx(binary, gradient, cv::MORPH_GRADIENT, kernel);
</code></pre>
<h3>效果</h3>
<p>提取物体的<strong>外轮廓线</strong>，类似边缘检测</p>
<h3>应用场景</h3>
<ul>
<li>能量机关扇叶边缘检测</li>
<li>装甲板外框提取（不常用）</li>
</ul>
<hr />
<h2>完整实战代码</h2>
<h3>方案1: 快速版（单次操作）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学核
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 闭运算（最常用）
    cv::Mat result;
    cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
    
    // 显示对比
    cv::imshow("原始二值图", binary);
    cv::imshow("形态学处理后", result);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>方案2: 标准版（两步法）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat morphologyProcess(const cv::Mat&amp; binary) {
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 第一步：闭运算填缝
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // 第二步：开运算去噪
    cv::Mat opened;
    cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
    
    return opened;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat binary = extractColor(img);
    
    cv::Mat result = morphologyProcess(binary);
    
    // 显示三步对比
    cv::imshow("1-原始", binary);
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, 
                     cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5)));
    cv::imshow("2-闭运算", closed);
    cv::imshow("3-最终结果", result);
    
    cv::waitKey(0);
    return 0;
}
</code></pre>
<h3>方案3: 自适应版（根据图像大小调整核）</h3>
<pre><code>cv::Mat adaptiveMorphology(const cv::Mat&amp; binary) {
    // 根据图像大小自适应核尺寸
    int kernelSize = std::max(3, (int)(binary.cols * 0.005));
    if (kernelSize % 2 == 0) kernelSize++;  // 确保是奇数
    
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                               cv::Size(kernelSize, kernelSize));
    
    cv::Mat closed, result;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    std::cout &lt;&lt; "使用核尺寸: " &lt;&lt; kernelSize &lt;&lt; "×" &lt;&lt; kernelSize &lt;&lt; std::endl;
    return result;
}
</code></pre>
<hr />
<h2>常见问题排查</h2>
<h3>问题1: 处理后灯条消失了</h3>
<pre><code>// 原因：核太大，把灯条也腐蚀掉了
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));

// 解决：减小核尺寸
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
</code></pre>
<h3>问题2: 两个灯条粘在一起了</h3>
<pre><code>// 原因：闭运算膨胀太强
// 解决1：减小核尺寸
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 解决2：减少迭代次数
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel, cv::Point(-1,-1), 1);

// 解决3：不用闭运算，只用轻微膨胀
cv::dilate(binary, result, kernel, cv::Point(-1,-1), 1);
</code></pre>
<h3>问题3: 噪点还是很多</h3>
<pre><code>// 原因：核太小
cv::Mat kernel_small = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 解决：增大核或增加迭代次数
cv::Mat kernel_big = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(7, 7));
// 或者
cv::morphologyEx(binary, result, cv::MORPH_OPEN, kernel, cv::Point(-1,-1), 2);
</code></pre>
<h3>问题4: 不知道用哪个操作</h3>
<pre><code>// 决策树：
if (灯条有断裂/缝隙) {
    使用闭运算 MORPH_CLOSE
}
if (有很多小噪点) {
    使用开运算 MORPH_OPEN
}
if (既有断裂又有噪点) {
    先闭运算，再开运算  // ← RM标准流程
}
</code></pre>
<hr />
<h2>调试技巧</h2>
<h3>技巧1: 可视化每一步</h3>
<pre><code>cv::Mat binary = extractColor(img);

cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// 保存每一步
cv::imshow("1-原始", binary);

cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
cv::imshow("2-闭运算", closed);

cv::Mat opened;
cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
cv::imshow("3-开运算", opened);

cv::waitKey(0);
</code></pre>
<h3>技巧2: 创建滑块调参</h3>
<pre><code>int kernelSize = 5;

void on_trackbar(int, void*) {}

int main() {
    cv::namedWindow("调参");
    cv::createTrackbar("核尺寸", "调参", &amp;kernelSize, 15, on_trackbar);
    
    while (true) {
        if (kernelSize % 2 == 0) kernelSize++;  // 确保奇数
        if (kernelSize &lt; 3) kernelSize = 3;
        
        cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                                   cv::Size(kernelSize, kernelSize));
        
        cv::Mat result;
        cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
        
        cv::imshow("结果", result);
        if (cv::waitKey(30) == 27) break;
    }
    
    return 0;
}
</code></pre>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 02 装甲板颜色提取</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_02/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_02/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::split()</code></td>
<td>分离BGR通道</td>
</tr>
<tr>
<td><code>cv::cvtColor()</code></td>
<td>颜色空间转换</td>
</tr>
<tr>
<td><code>cv::inRange()</code></td>
<td>颜色范围筛选</td>
</tr>
<tr>
<td><code>cv::threshold()</code></td>
<td>简单阈值二值化</td>
</tr>
<tr>
<td><code>cv::subtract()</code></td>
<td>通道相减</td>
</tr>
<tr>
<td><code>cv::bitwise_or/and()</code></td>
<td>位运算组合mask</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<p>装甲板的灯条有两个特点：</p>
<ol>
<li><strong>特定颜色</strong>（红色或蓝色）</li>
<li><strong>高亮度</strong>（灯条是发光的）</li>
</ol>
<p>RM视觉中有<strong>两条主流路线</strong>：</p>
<h3>路线1: 通道相减法</h3>
<ul>
<li><strong>原理</strong>: BGR图像中，红色区域R通道值高、B通道值低，相减后红色凸显</li>
<li><strong>优点</strong>: 速度极快（1-2ms），实时性好</li>
<li><strong>缺点</strong>: 易受环境光干扰，需要后续强筛选</li>
<li><strong>适用</strong>: 比赛实战、光照稳定环境</li>
</ul>
<h3>路线2: HSV筛选法</h3>
<ul>
<li><strong>原理</strong>: HSV分离了颜色和亮度，可精确筛选颜色范围</li>
<li><strong>优点</strong>: 抗干扰能力强，准确度高</li>
<li><strong>缺点</strong>: 速度较慢（5-10ms），参数需调优</li>
<li><strong>适用</strong>: 复杂光照、高精度需求</li>
</ul>
<hr />
<h2>1. cv::split() - 分离BGR通道</h2>
<h3>函数原型</h3>
<pre><code>void cv::split(const Mat&amp; src, Mat* mvbegin);
void cv::split(InputArray src, OutputArrayOfArrays mvs);
</code></pre>
<h3>核心概念</h3>
<p>OpenCV的彩色图是<strong>BGR三通道</strong>（不是RGB！）：</p>
<ul>
<li><strong>B通道 (channels[0])</strong>: 蓝色分量 (0-255)</li>
<li><strong>G通道 (channels[1])</strong>: 绿色分量 (0-255)</li>
<li><strong>R通道 (channels[2])</strong>: 红色分量 (0-255)</li>
</ul>
<h3>基础用法</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // 分离通道
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);
    
    // 现在：
    // channels[0] = B通道（蓝色分量）
    // channels[1] = G通道（绿色分量）
    // channels[2] = R通道（红色分量）
    
    // 可视化各通道
    cv::imshow("B通道", channels[0]);
    cv::imshow("G通道", channels[1]);
    cv::imshow("R通道", channels[2]);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>通道含义理解</h3>
<p>假设有一个像素的BGR值是 <code>(50, 100, 200)</code>：</p>
<pre><code>cv::Vec3b pixel(50, 100, 200);  // (B, G, R)
// B=50:  蓝色分量很低
// G=100: 绿色分量中等
// R=200: 红色分量很高
// 所以这个像素是：红色偏多的橙红色
</code></pre>
<p><strong>观察规律</strong>：</p>
<ul>
<li>红色灯条：R通道很亮，B通道很暗</li>
<li>蓝色灯条：B通道很亮，R通道很暗</li>
</ul>
<hr />
<h2>2. 通道相减法（RM经典）</h2>
<h3>提取红色</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");

// 分离通道
std::vector&lt;cv::Mat&gt; channels;
cv::split(img, channels);

// 红色 = R通道 - B通道
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// 二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);

// 查看效果
cv::imshow("原图", img);
cv::imshow("R通道", channels[2]);
cv::imshow("B通道", channels[0]);
cv::imshow("相减结果", red);
cv::imshow("二值化", binary);
cv::waitKey(0);
</code></pre>
<h3>提取蓝色</h3>
<pre><code>// 蓝色 = B通道 - R通道
cv::Mat blue;
cv::subtract(channels[0], channels[2], blue);

cv::Mat binary_blue;
cv::threshold(blue, binary_blue, 100, 255, cv::THRESH_BINARY);
</code></pre>
<h3>为什么通道相减有效？</h3>
<p><strong>原理分析</strong>：</p>
<table>
<thead>
<tr>
<th>区域类型</th>
<th>R值</th>
<th>B值</th>
<th>R-B结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>红色灯条</td>
<td>250</td>
<td>50</td>
<td><strong>200</strong> (很亮)</td>
</tr>
<tr>
<td>蓝色灯条</td>
<td>50</td>
<td>250</td>
<td>0 (饱和到0)</td>
</tr>
<tr>
<td>白色区域</td>
<td>200</td>
<td>200</td>
<td>0 (相互抵消)</td>
</tr>
<tr>
<td>黑色区域</td>
<td>20</td>
<td>20</td>
<td>0 (都很暗)</td>
</tr>
</tbody>
</table>
<p>通道相减后，<strong>只有红色灯条会保留高亮值</strong>！</p>
<h3>通道相减的局限性</h3>
<pre><code>// 问题1: 环境中的红色物体也会被提取
// 比如：红色衣服、红色海报、红色灯光

// 问题2: 光照不均会导致漏检
// 暗处的红色灯条可能 R-B &lt; 阈值

// 解决方案：需要后续用形态学+轮廓筛选来过滤
</code></pre>
<hr />
<h2>3. cv::cvtColor() - 颜色空间转换</h2>
<h3>函数原型</h3>
<pre><code>void cv::cvtColor(InputArray src, OutputArray dst, int code);
</code></pre>
<h3>常用转换代码</h3>
<table>
<thead>
<tr>
<th>code</th>
<th>说明</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COLOR_BGR2GRAY</code></td>
<td>BGR转灰度</td>
<td>简化图像处理</td>
</tr>
<tr>
<td><code>COLOR_BGR2HSV</code></td>
<td>BGR转HSV</td>
<td><strong>装甲板识别核心</strong></td>
</tr>
<tr>
<td><code>COLOR_BGR2RGB</code></td>
<td>BGR转RGB</td>
<td>与其他库对接</td>
</tr>
<tr>
<td><code>COLOR_HSV2BGR</code></td>
<td>HSV转回BGR</td>
<td>调试可视化</td>
</tr>
</tbody>
</table>
<h3>HSV颜色空间详解</h3>
<p>HSV把颜色分解为3个维度：</p>
<pre><code>H (色调 Hue): 0-180
├─ 0-10:    红色(第一段)
├─ 11-25:   橙色
├─ 26-34:   黄色
├─ 35-77:   绿色
├─ 78-99:   青色
├─ 100-124: 蓝色  装甲板蓝色
├─ 125-155: 紫色
└─ 170-180: 红色(第二段) 装甲板红色

S (饱和度 Saturation): 0-255
├─ 0-50:   灰白色（颜色不纯）
├─ 50-100: 淡色
└─ 100-255: 鲜艳色 灯条在这里

V (明度 Value): 0-255
├─ 0-50:   黑暗
├─ 50-100: 暗淡
└─ 100-255: 明亮 灯条在这里
</code></pre>
<h3>BGR转HSV</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// 查看HSV各通道
std::vector&lt;cv::Mat&gt; hsv_channels;
cv::split(hsv, hsv_channels);

cv::imshow("H通道(色调)", hsv_channels[0]);
cv::imshow("S通道(饱和度)", hsv_channels[1]);
cv::imshow("V通道(明度)", hsv_channels[2]);
cv::waitKey(0);
</code></pre>
<h3>为什么HSV更适合颜色识别？</h3>
<p><strong>BGR的问题</strong>：</p>
<pre><code>// 亮红色 vs 暗红色，BGR值差异大
亮红色: (0, 0, 255)
暗红色: (0, 0, 100)
// 用BGR很难用一个范围同时包含它们

// 但在HSV中：
亮红色: (0, 255, 255)  // H=0, S=255, V=255
暗红色: (0, 255, 100)  // H=0, S=255, V=100
// H和S相同！只是V不同，可以用 H in [0,10] 统一识别
</code></pre>
<hr />
<h2>4. cv::inRange() - 颜色范围筛选</h2>
<h3>函数原型</h3>
<pre><code>void cv::inRange(InputArray src, InputArray lowerb, 
                 InputArray upperb, OutputArray dst);
</code></pre>
<h3>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src</code></td>
<td>输入图像（通常是HSV）</td>
</tr>
<tr>
<td><code>lowerb</code></td>
<td>下界（Scalar(H_min, S_min, V_min)）</td>
</tr>
<tr>
<td><code>upperb</code></td>
<td>上界（Scalar(H_max, S_max, V_max)）</td>
</tr>
<tr>
<td><code>dst</code></td>
<td>输出二值图（在范围内=255，否则=0）</td>
</tr>
</tbody>
</table>
<h3>提取红色（完整版）</h3>
<pre><code>cv::Mat img = cv::imread("red_armor.jpg");
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// 红色的H值跨越了0-180的边界！需要分两段
// 第一段: H=0-10
cv::Scalar lower_red1(0, 100, 100);    // (H, S, V)
cv::Scalar upper_red1(10, 255, 255);

// 第二段: H=170-180
cv::Scalar lower_red2(170, 100, 100);
cv::Scalar upper_red2(180, 255, 255);

// 分别提取两段
cv::Mat mask1, mask2, red_mask;
cv::inRange(hsv, lower_red1, upper_red1, mask1);
cv::inRange(hsv, lower_red2, upper_red2, mask2);

// 合并两段（位运算：或）
cv::bitwise_or(mask1, mask2, red_mask);

// 查看效果
cv::imshow("原图", img);
cv::imshow("mask1 (H=0-10)", mask1);
cv::imshow("mask2 (H=170-180)", mask2);
cv::imshow("最终红色mask", red_mask);
cv::waitKey(0);
</code></pre>
<h3>提取蓝色</h3>
<pre><code>// 蓝色只需要一段
cv::Scalar lower_blue(100, 100, 100);  // H=100-130
cv::Scalar upper_blue(130, 255, 255);

cv::Mat blue_mask;
cv::inRange(hsv, lower_blue, upper_blue, blue_mask);
</code></pre>
<h3>参数调优技巧</h3>
<p><strong>创建滑块实时调参</strong>：</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

// 全局变量
int h_min = 0, h_max = 10;
int s_min = 100, s_max = 255;
int v_min = 100, v_max = 255;

void on_trackbar(int, void*) {
    // 回调函数，每次滑块变化时调用
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 创建窗口
    cv::namedWindow("调参");
    
    // 创建滑块
    cv::createTrackbar("H min", "调参", &amp;h_min, 180, on_trackbar);
    cv::createTrackbar("H max", "调参", &amp;h_max, 180, on_trackbar);
    cv::createTrackbar("S min", "调参", &amp;s_min, 255, on_trackbar);
    cv::createTrackbar("S max", "调参", &amp;s_max, 255, on_trackbar);
    cv::createTrackbar("V min", "调参", &amp;v_min, 255, on_trackbar);
    cv::createTrackbar("V max", "调参", &amp;v_max, 255, on_trackbar);
    
    while (true) {
        cv::Scalar lower(h_min, s_min, v_min);
        cv::Scalar upper(h_max, s_max, v_max);
        
        cv::Mat mask;
        cv::inRange(hsv, lower, upper, mask);
        
        cv::imshow("原图", img);
        cv::imshow("mask", mask);
        
        if (cv::waitKey(30) == 27) break;
    }
    
    // 打印最终参数
    std::cout &lt;&lt; "最优参数:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "lower: (" &lt;&lt; h_min &lt;&lt; ", " &lt;&lt; s_min &lt;&lt; ", " &lt;&lt; v_min &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "upper: (" &lt;&lt; h_max &lt;&lt; ", " &lt;&lt; s_max &lt;&lt; ", " &lt;&lt; v_max &lt;&lt; ")" &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<h3>推荐参数范围</h3>
<table>
<thead>
<tr>
<th>颜色</th>
<th>H范围</th>
<th>S范围</th>
<th>V范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>红色</strong></td>
<td>0-10, 170-180</td>
<td>100-255</td>
<td>100-255</td>
<td>两段合并</td>
</tr>
<tr>
<td><strong>蓝色</strong></td>
<td>100-130</td>
<td>100-255</td>
<td>100-255</td>
<td>单段即可</td>
</tr>
<tr>
<td>白色</td>
<td>任意</td>
<td>0-30</td>
<td>200-255</td>
<td>低饱和度+高亮度</td>
</tr>
<tr>
<td>黑色</td>
<td>任意</td>
<td>任意</td>
<td>0-50</td>
<td>只看亮度</td>
</tr>
</tbody>
</table>
<p><strong>这些参数不是固定的！</strong> 需要根据：</p>
<ul>
<li>相机型号</li>
<li>光照条件</li>
<li>灯条亮度
实际调整！</li>
</ul>
<hr />
<h2>5. cv::threshold() - 简单阈值二值化</h2>
<h3>函数原型</h3>
<pre><code>double cv::threshold(InputArray src, OutputArray dst, 
                     double thresh, double maxval, int type);
</code></pre>
<h3>常用类型</h3>
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>THRESH_BINARY</code></td>
<td>标准二值化</td>
<td><code>pixel &gt; thresh ? maxval : 0</code></td>
</tr>
<tr>
<td><code>THRESH_BINARY_INV</code></td>
<td>反向二值化</td>
<td><code>pixel &gt; thresh ? 0 : maxval</code></td>
</tr>
<tr>
<td><code>THRESH_TRUNC</code></td>
<td>截断</td>
<td><code>pixel &gt; thresh ? thresh : pixel</code></td>
</tr>
<tr>
<td><code>THRESH_TOZERO</code></td>
<td>低于阈值归零</td>
<td><code>pixel &gt; thresh ? pixel : 0</code></td>
</tr>
</tbody>
</table>
<h3>配合通道相减使用</h3>
<pre><code>// 提取红色
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// 阈值二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// 像素 &gt; 100 → 255(白)
// 像素 &lt;= 100 → 0(黑)
</code></pre>
<h3>💻 自适应阈值（应对光照不均）</h3>
<pre><code>cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

cv::Mat adaptive;
cv::adaptiveThreshold(gray, adaptive, 255,
                      cv::ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv::THRESH_BINARY, 11, 2);
// blockSize=11: 邻域大小
// C=2: 常数调整值
</code></pre>
<hr />
<h2>6. cv::bitwise 位运算</h2>
<h3>常用函数</h3>
<pre><code>void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_not(InputArray src, OutputArray dst);
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst);
</code></pre>
<h3>合并多个mask</h3>
<pre><code>// 红色有两段，需要合并
cv::Mat red_mask1, red_mask2, red_final;
cv::inRange(hsv, lower_red1, upper_red1, red_mask1);
cv::inRange(hsv, lower_red2, upper_red2, red_mask2);
cv::bitwise_or(red_mask1, red_mask2, red_final);
</code></pre>
<h3>提取同时满足多个条件的区域</h3>
<pre><code>// 同时是红色 且 亮度很高
cv::Mat color_mask, brightness_mask, final_mask;
cv::inRange(hsv, lower_red, upper_red, color_mask);
cv::threshold(hsv_channels[2], brightness_mask, 200, 255, cv::THRESH_BINARY);
cv::bitwise_and(color_mask, brightness_mask, final_mask);
</code></pre>
<h3>反转mask</h3>
<pre><code>cv::Mat mask, inverted;
cv::inRange(hsv, lower, upper, mask);
cv::bitwise_not(mask, inverted);  // 黑白反转
</code></pre>
<hr />
<h2>完整实战代码</h2>
<h3>方案1: 通道相减法（快速）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedFast(const cv::Mat&amp; img) {
    std::vector&lt;cv::Mat&gt; channels;
    cv::split(img, channels);
    
    // R - B
    cv::Mat red;
    cv::subtract(channels[2], channels[0], red);
    
    // 二值化
    cv::Mat binary;
    cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
    
    return binary;
}

int main() {
    cv::Mat img = cv::imread("red_armor.jpg");
    cv::Mat binary = extractRedFast(img);
    
    cv::imshow("原图", img);
    cv::imshow("红色提取", binary);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<h3>方案2: HSV筛选法（精确）</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

cv::Mat extractRedAccurate(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 红色两段
    cv::Scalar lower1(0, 100, 100);
    cv::Scalar upper1(10, 255, 255);
    cv::Scalar lower2(170, 100, 100);
    cv::Scalar upper2(180, 255, 255);
    
    cv::Mat mask1, mask2, mask;
    cv::inRange(hsv, lower1, upper1, mask1);
    cv::inRange(hsv, lower2, upper2, mask2);
    cv::bitwise_or(mask1, mask2, mask);
    
    return mask;
}

cv::Mat extractBlue(const cv::Mat&amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    cv::Scalar lower(100, 100, 100);
    cv::Scalar upper(130, 255, 255);
    
    cv::Mat mask;
    cv::inRange(hsv, lower, upper, mask);
    
    return mask;
}

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    cv::Mat red_mask = extractRedAccurate(img);
    cv::Mat blue_mask = extractBlue(img);
    
    cv::imshow("原图", img);
    cv::imshow("红色mask", red_mask);
    cv::imshow("蓝色mask", blue_mask);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>常见问题排查</h2>
<h3>问题1: 提取不出颜色</h3>
<pre><code>// 检查清单：
// 1. 确认图像不是空的
if (img.empty()) return;

// 2. 打印HSV值看看范围对不对
cv::Vec3b pixel = hsv.at&lt;cv::Vec3b&gt;(y, x);  // 点击灯条位置
std::cout &lt;&lt; "H=" &lt;&lt; (int)pixel[0] 
          &lt;&lt; " S=" &lt;&lt; (int)pixel[1] 
          &lt;&lt; " V=" &lt;&lt; (int)pixel[2] &lt;&lt; std::endl;

// 3. 用滑块调参
</code></pre>
<h3>问题2: 提取出太多杂色</h3>
<pre><code>// 解决方案：
// 1. 提高S和V的下限（只要鲜艳+明亮的）
cv::Scalar lower(0, 150, 150);  // 提高S_min和V_min

// 2. 后续用形态学降噪
// 3. 轮廓筛选时过滤小面积
</code></pre>
<h3>问题3: 红色只检测到一半</h3>
<pre><code>// 原因：忘记合并红色的两段
// 解决：
cv::bitwise_or(mask1, mask2, final_mask);
</code></pre>
<hr />
<h2>检查清单</h2>
<p>完成本阶段后，你应该能够：</p>
<ul>
<li>[ ] 理解BGR和HSV的区别</li>
<li>[ ] 用 <code>cv::split()</code> 分离通道并计算 R-B</li>
<li>[ ] 用 <code>cv::inRange()</code> 提取红色/蓝色</li>
<li>[ ] 知道红色需要两段范围合并</li>
<li>[ ] 能用滑块调试HSV参数</li>
<li>[ ] 理解通道相减法和HSV法的优劣</li>
</ul>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 04 轮廓检测</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_04/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_04/</id>
    <published>2025-10-24T00:00:00.000Z</published>
    <updated>2025-10-24T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>📚 本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::findContours()</code></td>
<td>查找轮廓</td>
</tr>
<tr>
<td><code>cv::contourArea()</code></td>
<td>计算轮廓面积</td>
</tr>
<tr>
<td><code>cv::minAreaRect()</code></td>
<td>最小旋转矩形</td>
</tr>
<tr>
<td><code>cv::RotatedRect</code></td>
<td>旋转矩形类</td>
</tr>
<tr>
<td><code>cv::drawContours()</code></td>
<td>绘制轮廓</td>
</tr>
<tr>
<td><code>cv::boundingRect()</code></td>
<td>正矩形包围框</td>
</tr>
<tr>
<td><code>cv::fitEllipse()</code></td>
<td>椭圆拟合</td>
</tr>
</tbody>
</table>
<hr />
<h2>核心思路</h2>
<ul>
<li>
<p>经过形态学处理后，二值图已经很干净：</p>
</li>
<li>
<p>现在要做的是：</p>
</li>
</ul>
<ol>
<li><strong>找轮廓</strong> - 把每个白色区域的边界找出来</li>
<li><strong>拟合矩形</strong> - 用旋转矩形描述每个轮廓</li>
<li><strong>筛选灯条</strong> - 根据长宽比、面积、角度等特征过滤</li>
</ol>
<hr />
<h2>1. cv::findContours() - 查找轮廓</h2>
<h3>函数原型</h3>
<pre><code>void cv::findContours(InputOutputArray image, 
                      OutputArrayOfArrays contours,
                      int mode, int method, 
                      Point offset = Point());
</code></pre>
<h3>参数详解</h3>
<h4>mode - 轮廓检索模式</h4>
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RETR_EXTERNAL</code></td>
<td>只检测最外层轮廓</td>
<td><strong>RM推荐</strong>，忽略内部孔洞</td>
</tr>
<tr>
<td><code>RETR_LIST</code></td>
<td>检测所有轮廓，不建立层级</td>
<td>当需要所有轮廓时</td>
</tr>
<tr>
<td><code>RETR_TREE</code></td>
<td>检测所有并建立完整层级树</td>
<td>复杂嵌套结构</td>
</tr>
<tr>
<td><code>RETR_CCOMP</code></td>
<td>两层层级（外轮廓和孔）</td>
<td>较少使用</td>
</tr>
</tbody>
</table>
<h4>method - 轮廓近似方法</h4>
<table>
<thead>
<tr>
<th>method</th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CHAIN_APPROX_NONE</code></td>
<td>保存所有轮廓点</td>
<td>精确但占内存</td>
</tr>
<tr>
<td><code>CHAIN_APPROX_SIMPLE</code></td>
<td>压缩轮廓，只保留关键点</td>
<td><strong>RM推荐</strong>，节省内存</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

int main() {
    cv::Mat img = cv::imread("armor.jpg");
    
    // 获取二值图（假设已实现）
    cv::Mat binary = processImage(img);
    
    // 查找轮廓
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, 
                     cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "找到 " &lt;&lt; contours.size() &lt;&lt; " 个轮廓" &lt;&lt; std::endl;
    
    // 遍历所有轮廓
    for (size_t i = 0; i &lt; contours.size(); i++) {
        std::cout &lt;&lt; "轮廓 " &lt;&lt; i &lt;&lt; " 有 " &lt;&lt; contours[i].size() 
                  &lt;&lt; " 个点" &lt;&lt; std::endl;
    }
    
    return 0;
}
</code></pre>
<h3>重要注意事项</h3>
<h4>注意1: findContours会修改输入图像！</h4>
<pre><code>//  错误：原始binary被修改了
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

//  正确：传入副本
cv::Mat binary_copy = binary.clone();
cv::findContours(binary_copy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 或者直接在临时对象上调用
cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
</code></pre>
<h4>注意2: 输入必须是二值图</h4>
<pre><code>//  错误：彩色图不行
cv::Mat img = cv::imread("armor.jpg");
cv::findContours(img, contours, ...);  //  结果不对

//  正确：必须是二值图（0或255）
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
cv::findContours(binary, contours, ...);
</code></pre>
<hr />
<h2>2. 轮廓数据结构理解</h2>
<h3>轮廓的本质</h3>
<pre><code>// 轮廓 = 点的集合
std::vector&lt;cv::Point&gt; contour = contours[0];

// 每个点是(x, y)坐标
cv::Point p = contour[0];
std::cout &lt;&lt; "第一个点: (" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; std::endl;
</code></pre>
<h3>轮廓操作示例</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 轮廓数量
int num = contours.size();

// 第i个轮廓的点数
int pointCount = contours[i].size();

// 访问第i个轮廓的第j个点
cv::Point p = contours[i][j];
</code></pre>
<hr />
<h2>3. cv::contourArea() - 计算轮廓面积</h2>
<h3>函数原型</h3>
<pre><code>double cv::contourArea(InputArray contour, bool oriented = false);
</code></pre>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    std::cout &lt;&lt; "轮廓面积: " &lt;&lt; area &lt;&lt; " 像素" &lt;&lt; std::endl;
}
</code></pre>
<h3>用于过滤噪点</h3>
<pre><code>std::vector&lt;std::vector&lt;cv::Point&gt;&gt; validContours;

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    
    // 过滤太小的轮廓（噪点）
    if (area &lt; 100) continue;
    
    // 过滤太大的轮廓（可能是整个装甲板或背景）
    if (area &gt; 10000) continue;
    
    // 保留合理大小的轮廓
    validContours.push_back(contour);
}

std::cout &lt;&lt; "过滤后剩余 " &lt;&lt; validContours.size() &lt;&lt; " 个轮廓" &lt;&lt; std::endl;
</code></pre>
<h3>面积阈值如何选择？</h3>
<p>这取决于：</p>
<ol>
<li><strong>图像分辨率</strong> - 1920×1080 vs 640×480</li>
<li><strong>装甲板距离</strong> - 近距离灯条大，远距离灯条小</li>
<li><strong>相机FOV</strong> - 视场角大小</li>
</ol>
<p><strong>推荐方法</strong>：</p>
<pre><code>// 根据图像大小自适应
int imageArea = binary.rows * binary.cols;
double minArea = imageArea * 0.0001;  // 0.01%
double maxArea = imageArea * 0.05;    // 5%

for (const auto&amp; contour : contours) {
    double area = cv::contourArea(contour);
    if (area &gt; minArea &amp;&amp; area &lt; maxArea) {
        // 合理范围
    }
}
</code></pre>
<hr />
<h2>4. cv::minAreaRect() - 最小旋转矩形</h2>
<h3>函数原型</h3>
<pre><code>RotatedRect cv::minAreaRect(InputArray points);
</code></pre>
<h3>为什么用旋转矩形？</h3>
<p>灯条通常是<strong>倾斜</strong>的，普通矩形无法准确描述：</p>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // 拟合最小旋转矩形
    cv::RotatedRect rect = cv::minAreaRect(contour);
    
    // 获取矩形信息
    cv::Point2f center = rect.center;      // 中心点
    cv::Size2f size = rect.size;           // 尺寸(width, height)
    float angle = rect.angle;              // 旋转角度(-90到0)
    
    std::cout &lt;&lt; "中心: (" &lt;&lt; center.x &lt;&lt; ", " &lt;&lt; center.y &lt;&lt; ")" &lt;&lt; std::endl;
    std::cout &lt;&lt; "尺寸: " &lt;&lt; size.width &lt;&lt; " × " &lt;&lt; size.height &lt;&lt; std::endl;
    std::cout &lt;&lt; "角度: " &lt;&lt; angle &lt;&lt; "°" &lt;&lt; std::endl;
}
</code></pre>
<hr />
<h2>5. cv::RotatedRect 类详解</h2>
<h3>核心属性</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// 中心点
cv::Point2f center = rect.center;  // 矩形中心的(x,y)坐标

// 尺寸
cv::Size2f size = rect.size;       // width × height
float width = size.width;
float height = size.height;

// 旋转角度
float angle = rect.angle;          // 范围: -90° ~ 0°
</code></pre>
<h3>angle的陷阱</h3>
<p><strong>OpenCV的angle定义很反直觉！</strong></p>
<pre><code>// angle的含义：
// 从水平方向逆时针旋转到矩形长边的角度
// 范围：-90° 到 0°

// 例子：
angle = -90°  → 矩形垂直（竖着）
angle = -45°  → 矩形倾斜45度
angle = 0°    → 矩形水平（横着）
</code></pre>
<h3>确保height是长边</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

float width = rect.size.width;
float height = rect.size.height;

//  OpenCV不保证height &gt; width！
// 需要手动调整
if (width &gt; height) {
    std::swap(width, height);
    // 如果需要，也可以调整angle
}

// 现在 height 一定是长边
float aspectRatio = height / width;  // 长宽比
</code></pre>
<h3>获取四个顶点坐标</h3>
<pre><code>cv::RotatedRect rect = cv::minAreaRect(contour);

// 获取四个顶点
cv::Point2f vertices[4];
rect.points(vertices);

// vertices[0], vertices[1], vertices[2], vertices[3]
// 按逆时针顺序排列

// 绘制旋转矩形
for (int i = 0; i &lt; 4; i++) {
    cv::line(img, vertices[i], vertices[(i+1)%4], 
             cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<hr />
<h2>6. 灯条特征筛选（核心）</h2>
<h3>灯条的典型特征</h3>
<table>
<thead>
<tr>
<th>特征</th>
<th>合理范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>长宽比</strong></td>
<td>2.0 ~ 10.0</td>
<td>灯条是细长的</td>
</tr>
<tr>
<td><strong>面积</strong></td>
<td>100 ~ 5000像素</td>
<td>根据分辨率调整</td>
</tr>
<tr>
<td><strong>角度</strong></td>
<td>接近垂直</td>
<td>通常在±30°内</td>
</tr>
<tr>
<td><strong>填充度</strong></td>
<td>&gt; 0.5</td>
<td>轮廓面积/外接矩形面积</td>
</tr>
</tbody>
</table>
<h3>完整筛选代码</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    float angle;
};

std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary) {
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::vector&lt;LightBar&gt; lightBars;
    
    for (const auto&amp; contour : contours) {
        // 1. 面积筛选
        double area = cv::contourArea(contour);
        if (area &lt; 100 || area &gt; 5000) continue;
        
        // 2. 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 3. 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // 4. 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0 || aspectRatio &gt; 10.0) continue;
        
        // 5. 角度筛选（可选，根据实际情况）
        // 灯条应该接近垂直
        float angle = std::abs(rect.angle);
        if (angle &gt; 30 &amp;&amp; angle &lt; 60) continue;  // 太斜的排除
        
        // 6. 填充度筛选（可选）
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) continue;  // 太空的不是灯条
        
        // 通过所有筛选，保存
        LightBar bar;
        bar.rect = rect;
        bar.area = area;
        bar.aspectRatio = aspectRatio;
        bar.angle = angle;
        lightBars.push_back(bar);
    }
    
    std::cout &lt;&lt; "找到 " &lt;&lt; lightBars.size() &lt;&lt; " 个灯条" &lt;&lt; std::endl;
    return lightBars;
}
</code></pre>
<h3>筛选效果展示</h3>
<pre><code>// 假设找到20个轮廓：

轮廓1: 面积=50      太小，过滤
轮廓2: 面积=800    通过面积
       长宽比=5.2    通过长宽比
       填充度=0.8  通过填充度
       结果: 灯条候选1 

轮廓3: 面积=1200     通过面积
       长宽比=1.1   太矮，过滤

轮廓4: 面积=900      通过面积
       长宽比=4.8    通过长宽比
       填充度=0.3   太空，过滤

...

最终: 找到4个灯条（2对装甲板）
</code></pre>
<hr />
<h2>7. cv::drawContours() - 绘制轮廓（调试）</h2>
<h3>函数原型</h3>
<pre><code>void cv::drawContours(InputOutputArray image,
                      InputArrayOfArrays contours,
                      int contourIdx, 
                      const Scalar&amp; color,
                      int thickness = 1);
</code></pre>
<h3>基础用法</h3>
<pre><code>cv::Mat display = img.clone();

// 绘制所有轮廓
cv::drawContours(display, contours, -1, cv::Scalar(0, 255, 0), 2);
// -1 表示绘制所有轮廓

// 绘制第i个轮廓
cv::drawContours(display, contours, i, cv::Scalar(255, 0, 0), 2);

// 填充轮廓
cv::drawContours(display, contours, i, cv::Scalar(0, 0, 255), -1);
// thickness=-1 表示填充
</code></pre>
<h3>彩色调试可视化</h3>
<pre><code>void visualizeContours(const cv::Mat&amp; img, 
                       const std::vector&lt;std::vector&lt;cv::Point&gt;&gt;&amp; contours) {
    cv::Mat display = img.clone();
    
    // 为每个轮廓随机颜色
    cv::RNG rng(12345);
    
    for (size_t i = 0; i &lt; contours.size(); i++) {
        cv::Scalar color(rng.uniform(0, 256), 
                        rng.uniform(0, 256), 
                        rng.uniform(0, 256));
        
        // 绘制轮廓
        cv::drawContours(display, contours, i, color, 2);
        
        // 标注序号
        cv::Moments m = cv::moments(contours[i]);
        cv::Point2f center(m.m10/m.m00, m.m01/m.m00);
        cv::putText(display, std::to_string(i), center,
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
    }
    
    cv::imshow("轮廓可视化", display);
}
</code></pre>
<hr />
<h2>8. 绘制旋转矩形</h2>
<h3>标准方法</h3>
<pre><code>void drawRotatedRect(cv::Mat&amp; img, const cv::RotatedRect&amp; rect, 
                     const cv::Scalar&amp; color, int thickness = 2) {
    cv::Point2f vertices[4];
    rect.points(vertices);
    
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], color, thickness);
    }
}

// 使用
for (const auto&amp; bar : lightBars) {
    drawRotatedRect(display, bar.rect, cv::Scalar(0, 255, 0), 2);
}
</code></pre>
<h3>🎨 增强版（带中心点和文字）</h3>
<pre><code>void drawLightBar(cv::Mat&amp; img, const LightBar&amp; bar, int id) {
    // 绘制旋转矩形
    cv::Point2f vertices[4];
    bar.rect.points(vertices);
    for (int i = 0; i &lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制中心点
    cv::circle(img, bar.rect.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 标注信息
    std::string text = "ID:" + std::to_string(id) + 
                       " R:" + std::to_string((int)bar.aspectRatio);
    cv::putText(img, text, 
                cv::Point(bar.rect.center.x + 10, bar.rect.center.y),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 255), 2);
}
</code></pre>
<hr />
<h2>9. cv::boundingRect() - 正矩形包围框</h2>
<h3>函数原型</h3>
<pre><code>Rect cv::boundingRect(InputArray points);
</code></pre>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // 获取正矩形（水平/垂直边）
    cv::Rect bbox = cv::boundingRect(contour);
    
    // 绘制
    cv::rectangle(img, bbox, cv::Scalar(255, 0, 0), 2);
    
    // 裁剪ROI
    cv::Mat roi = img(bbox);
}
</code></pre>
<h3>正矩形 vs 旋转矩形</h3>
<pre><code>cv::Rect bbox = cv::boundingRect(contour);         // 正矩形
cv::RotatedRect rect = cv::minAreaRect(contour);   // 旋转矩形

// 正矩形：边平行于坐标轴，面积可能较大
// 旋转矩形：最小面积，但边可能倾斜

// 用途：
// - 正矩形：裁剪ROI、快速碰撞检测
// - 旋转矩形：精确描述灯条形状和角度
</code></pre>
<hr />
<h2>10. cv::fitEllipse() - 椭圆拟合（能量机关用）</h2>
<h3>函数原型</h3>
<pre><code>RotatedRect cv::fitEllipse(InputArray points);
</code></pre>
<h3>基础用法</h3>
<pre><code>for (const auto&amp; contour : contours) {
    // 至少需要5个点
    if (contour.size() &lt; 5) continue;
    
    // 拟合椭圆
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 绘制椭圆
    cv::ellipse(img, ellipse, cv::Scalar(0, 255, 255), 2);
}
</code></pre>
<h3>能量机关扇叶识别</h3>
<pre><code>// 能量机关的R标是椭圆形
bool isEnergyRune(const std::vector&lt;cv::Point&gt;&amp; contour) {
    if (contour.size() &lt; 5) return false;
    
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 椭圆的长短轴比应该接近1（近似圆形）
    float ratio = ellipse.size.width / ellipse.size.height;
    if (ratio &lt; 0.8 || ratio &gt; 1.2) return false;
    
    // 面积合理
    double area = CV_PI * ellipse.size.width/2 * ellipse.size.height/2;
    if (area &lt; 500 || area &gt; 3000) return false;
    
    return true;
}
</code></pre>
<hr />
<h2>完整实战代码</h2>
<h3>完整的灯条检测系统</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

// 灯条结构体
struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    
    LightBar(const cv::RotatedRect&amp; r, double a, float ar)
        : rect(r), area(a), aspectRatio(ar) {}
};

// 灯条检测函数
std::vector&lt;LightBar&gt; detectLightBars(const cv::Mat&amp; binary, 
                                      const cv::Mat&amp; display) {
    // 1. 查找轮廓
    std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &lt;&lt; "总轮廓数: " &lt;&lt; contours.size() &lt;&lt; std::endl;
    
    std::vector&lt;LightBar&gt; lightBars;
    
    // 2. 遍历筛选
    for (size_t i = 0; i &lt; contours.size(); i++) {
        const auto&amp; contour = contours[i];
        
        // 面积筛选
        double area = cv::contourArea(contour);
        if (area &lt; 100) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 面积=" &lt;&lt; area 
                      &lt;&lt; "  太小" &lt;&lt; std::endl;
            continue;
        }
        if (area &gt; 5000) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 面积=" &lt;&lt; area 
                      &lt;&lt; " 太大" &lt;&lt; std::endl;
            continue;
        }
        
        // 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &gt; height) {
            std::swap(width, height);
        }
        
        // 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &lt; 2.0) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 长宽比=" &lt;&lt; aspectRatio 
                      &lt;&lt; " 太矮" &lt;&lt; std::endl;
            continue;
        }
        if (aspectRatio &gt; 10.0) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 长宽比=" &lt;&lt; aspectRatio 
                      &lt;&lt; "太细" &lt;&lt; std::endl;
            continue;
        }
        
        // 填充度筛选
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &lt; 0.5) {
            std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ": 填充度=" &lt;&lt; fillRatio 
                      &lt;&lt; "  太空" &lt;&lt; std::endl;
            continue;
        }
        
        // 通过筛选！
        std::cout &lt;&lt; "轮廓" &lt;&lt; i &lt;&lt; ":  灯条候选" &lt;&lt; std::endl;
        std::cout &lt;&lt; "    面积=" &lt;&lt; area &lt;&lt; ", 长宽比=" &lt;&lt; aspectRatio 
                  &lt;&lt; ", 填充度=" &lt;&lt; fillRatio &lt;&lt; std::endl;
        
        lightBars.emplace_back(rect, area, aspectRatio);
        
        // 绘制（调试用）
        if (!display.empty()) {
            cv::Point2f vertices[4];
            rect.points(vertices);
            for (int j = 0; j &lt; 4; j++) {
                cv::line(display, vertices[j], vertices[(j+1)%4],
                         cv::Scalar(0, 255, 0), 2);
            }
            cv::circle(display, rect.center, 5, cv::Scalar(0, 0, 255), -1);
        }
    }
    
    std::cout &lt;&lt; "\n最终找到 " &lt;&lt; lightBars.size() &lt;&lt; " 个灯条" &lt;&lt; std::endl;
    return lightBars;
}

int main() {
    // 读取图像
    cv::Mat img = cv::imread("armor.jpg");
    if (img.empty()) {
        std::cerr &lt;&lt; "无法读取图像" &lt;&lt; std::endl;
        return -1;
    }
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学处理（假设已实现）
    binary = morphologyProcess(binary);
    
    // 灯条检测
    cv::Mat display = img.clone();
    std::vector&lt;LightBar&gt; lightBars = detectLightBars(binary, display);
    
    // 显示结果
    cv::imshow("原图", img);
    cv::imshow("二值图", binary);
    cv::imshow("检测结果", display);
    cv::waitKey(0);
    
    return 0;
}
</code></pre>
<hr />
<h2>常见问题排查</h2>
<h3>问题1: 找不到轮廓</h3>
<pre><code>// 检查清单：
// 1. 二值图是否正确？
cv::imshow("binary", binary);  // 应该是黑白的

// 2. 前景是白色吗？
// findContours找的是白色区域！如果反了需要反转
cv::bitwise_not(binary, binary);

// 3. 图像是单通道吗？
std::cout &lt;&lt; "通道数: " &lt;&lt; binary.channels() &lt;&lt; std::endl;  // 应该是1
</code></pre>
<h3>问题2: 找到太多轮廓（都是噪点）</h3>
<pre><code>// 解决方案：
// 1. 加强形态学处理
cv::morphologyEx(binary, binary, cv::MORPH_OPEN, kernel);

// 2. 提高面积阈值
if (area &lt; 200) continue;  // 增大

// 3. 添加填充度筛选
double fillRatio = area / (width * height);
if (fillRatio &lt; 0.6) continue;
</code></pre>
<h3>问题3: 灯条被筛掉了</h3>
<pre><code>// 调试步骤：
// 1. 打印每个轮廓的参数
for (size_t i = 0; i &lt; contours.size(); i++) {
    double area = cv::contourArea(contours[i]);
    cv::RotatedRect rect = cv::minAreaRect(contours[i]);
    float ratio = rect.size.height / rect.size.width;
    std::cout &lt;&lt; i &lt;&lt; ": area=" &lt;&lt; area &lt;&lt; ", ratio=" &lt;&lt; ratio &lt;&lt; std::endl;
}

// 2. 放宽筛选条件
if (aspectRatio &lt; 1.5 || aspectRatio &gt; 15.0) continue;  // 放宽范围

// 3. 可视化被筛掉的轮廓
cv::drawContours(rejected_img, contours, i, cv::Scalar(0,0,255), 2);
</code></pre>
<h3>问题4: 旋转矩形角度不对</h3>
<pre><code>// OpenCV的angle有时不符合预期
// 解决方案：自己计算角度
cv::Point2f vertices[4];
rect.points(vertices);

// 计算长边的角度
cv::Point2f edge = vertices[1] - vertices[0];
float angle = std::atan2(edge.y, edge.x) * 180 / CV_PI;
</code></pre>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>RM装甲板识别 - 01 图像读取与显示</title>
    <link href="https://www.nanye404.top/posts/rm_opencv_01/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/rm_opencv_01/</id>
    <published>2025-10-23T00:00:00.000Z</published>
    <updated>2025-10-23T00:00:00.000Z</updated>
    <summary>无</summary>
    <content type="html"><![CDATA[<h2>本阶段核心API清单</h2>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv::imread()</code></td>
<td>读取图片到内存</td>
</tr>
<tr>
<td><code>cv::imshow()</code></td>
<td>显示图片窗口</td>
</tr>
<tr>
<td><code>cv::waitKey()</code></td>
<td>等待按键</td>
</tr>
<tr>
<td><code>cv::imwrite()</code></td>
<td>保存图片</td>
</tr>
<tr>
<td><code>cv::Mat</code></td>
<td>图像数据类型</td>
</tr>
<tr>
<td><code>cv::VideoCapture</code></td>
<td>打开相机/视频</td>
</tr>
</tbody>
</table>
<hr />
<h2>1. cv::imread() - 读取图片</h2>
<h3>函数原型</h3>
<pre><code>cv::Mat cv::imread(const String&amp; filename, int flags = IMREAD_COLOR);
</code></pre>
<h3>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>filename</code></td>
<td>string</td>
<td>图片路径（相对或绝对路径）</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>int</td>
<td>读取模式（见下表）</td>
</tr>
</tbody>
</table>
<p><strong>flags常用值:</strong></p>
<ul>
<li><code>cv::IMREAD_COLOR</code> (默认) - 读取彩色图，忽略透明度</li>
<li><code>cv::IMREAD_GRAYSCALE</code> - 转为灰度图</li>
<li><code>cv::IMREAD_UNCHANGED</code> - 包含Alpha通道</li>
</ul>
<h3>基础用法</h3>
<pre><code>
    // 读取彩色图（装甲板识别用这个）
    cv::Mat img = cv::imread("armor.jpg", cv::IMREAD_COLOR);
    
    //  必须检查是否读取成功！
    if (img.empty()) {
        std::cout &lt;&lt; " 图片读取失败！" &lt;&lt; std::endl;
        return -1;
    }
    
    // 打印图片信息
    std::cout &lt;&lt; " 图片读取成功" &lt;&lt; std::endl;
    std::cout &lt;&lt; "   尺寸: " &lt;&lt; img.cols &lt;&lt; " x " &lt;&lt; img.rows &lt;&lt; std::endl;
    std::cout &lt;&lt; "   通道数: " &lt;&lt; img.channels() &lt;&lt; std::endl;

</code></pre>
<h3>输出示例</h3>
<pre><code> 图片读取成功
   尺寸: 1280 x 720
   通道数: 3
</code></pre>
<h3>常见错误</h3>
<h4>错误1: 路径写错</h4>
<pre><code>
// 正确写法
cv::Mat img = cv::imread("/home/user/img.jpg");     // 绝对路径
cv::Mat img = cv::imread("img.jpg");       //相对路径

</code></pre>
<h4>错误2: 忘记检查empty()</h4>
<pre><code>// 如果文件不存在，后续操作会崩溃
cv::Mat img = cv::imread("not_exist.jpg");
cv::imshow("Window", img);  // 崩溃

//  正确写法
cv::Mat img = cv::imread("not_exist.jpg");
if (img.empty()) {
    std::cerr &lt;&lt; "文件不存在或格式不支持" &lt;&lt; std::endl;
    return -1;
}
</code></pre>
<blockquote>
<p><strong>OpenCV读取的图片是BGR格式，不是RGB！</strong><br />
这在后续颜色识别时非常重要。如果你要转RGB需要用 <code>cv::cvtColor()</code></p>
</blockquote>
<hr />
<h2>2. cv::imshow() - 显示图片</h2>
<h3>函数原型</h3>
<pre><code>void cv::imshow(const String&amp; winname, InputArray mat);
</code></pre>
<h3>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>winname</code></td>
<td>string</td>
<td>窗口名称（自己起名）</td>
</tr>
<tr>
<td><code>mat</code></td>
<td>Mat</td>
<td>要显示的图像</td>
</tr>
</tbody>
</table>
<h3>基础用法</h3>
<pre><code>cv::Mat img = cv::imread("armor.jpg");

// 显示图片
cv::imshow("原图", img);

//  必须配合waitKey()，否则窗口闪现即消失！
cv::waitKey(0);  // 0表示无限等待，直到按任意键

// 关闭所有窗口
cv::destroyAllWindows();
</code></pre>
<h3>显示多个窗口</h3>
<pre><code>cv::Mat img1 = cv::imread("red_armor.jpg");
cv::Mat img2 = cv::imread("blue_armor.jpg");

cv::imshow("红方装甲板", img1);
cv::imshow("蓝方装甲板", img2);

cv::waitKey(0);
cv::destroyAllWindows();
</code></pre>
<h3>常见错误</h3>
<pre><code>//错误：窗口闪一下就消失
cv::imshow("Window", img);
// 缺少 waitKey()

// 正确写法
cv::imshow("Window", img);
cv::waitKey(0);
</code></pre>
<hr />
<h2>3. cv::waitKey() - 等待按键</h2>
<h3>函数原型</h3>
<pre><code>int cv::waitKey(int delay = 0);
</code></pre>
<h3>参数说明</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delay</code></td>
<td>等待时间（毫秒），0表示无限等待</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>按下的键的ASCII码，超时返回-1</td>
</tr>
</tbody>
</table>
<h3>实用技巧</h3>
<h4>技巧1: 等待任意键</h4>
<pre><code>cv::imshow("Image", img);
cv::waitKey(0);  // 按任意键继续
</code></pre>
<h4>技巧2: 检测特定按键</h4>
<pre><code>cv::imshow("Image", img);
int key = cv::waitKey(0);

if (key == 27) {  // ESC键
    std::cout &lt;&lt; "用户取消" &lt;&lt; std::endl;
} else if (key == 's' || key == 'S') {  // S键
    cv::imwrite("saved.jpg", img);
    std::cout &lt;&lt; "图片已保存" &lt;&lt; std::endl;
}
</code></pre>
<h4>技巧3: 实时视频显示（30fps）</h4>
<pre><code>while (true) {
    cv::Mat frame = getFrame();  // 获取一帧
    cv::imshow("Video", frame);
    
    // 等待33ms（约30fps），按ESC退出
    if (cv::waitKey(33) == 27) break;
}
</code></pre>
<hr />
<h2>4. cv::Mat - 图像数据类型</h2>
<h3>核心概念</h3>
<p><code>cv::Mat</code> 是OpenCV的核心数据结构，可以理解为一个<strong>多维数组</strong>：</p>
<ul>
<li>2D图像 = 二维矩阵</li>
<li>彩色图像 = 三维矩阵（宽×高×通道）</li>
</ul>
<h3>创建Mat对象</h3>
<h4>方法1: 通过imread创建</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");
</code></pre>
<h4>方法2: 创建空白图像</h4>
<pre><code>// 创建640×480的黑色图像
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

// 创建白色图像
cv::Mat white(480, 640, CV_8UC3, cv::Scalar(255, 255, 255));

// 创建红色图像
cv::Mat red(480, 640, CV_8UC3, cv::Scalar(0, 0, 255));  // BGR格式！
</code></pre>
<h3>常用属性</h3>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// 基本信息
int width = img.cols;      // 宽度（列数）
int height = img.rows;     // 高度（行数）
int channels = img.channels();  // 通道数（1=灰度，3=彩色）
bool isEmpty = img.empty();     // 是否为空

// 数据类型
int type = img.type();     // CV_8UC3 等
int depth = img.depth();   // CV_8U 等

// 内存信息
size_t total = img.total();    // 总像素数 = rows × cols
size_t bytes = img.total() * img.elemSize();  // 占用字节数
</code></pre>
<h3>访问像素值</h3>
<h4>方法1: at访问（安全但慢）</h4>
<pre><code>cv::Mat img = cv::imread("image.jpg");

// 访问(100, 200)位置的像素
cv::Vec3b pixel = img.at&lt;cv::Vec3b&gt;(100, 200);
uchar blue = pixel[0];
uchar green = pixel[1];
uchar red = pixel[2];

// 修改像素
img.at&lt;cv::Vec3b&gt;(100, 200) = cv::Vec3b(255, 0, 0);  // 设为蓝色
</code></pre>
<h4>方法2: 指针访问（快但需小心）</h4>
<pre><code>for (int y = 0; y &lt; img.rows; y++) {
    uchar* row = img.ptr&lt;uchar&gt;(y);  // 获取第y行的指针
    for (int x = 0; x &lt; img.cols; x++) {
        uchar b = row[x * 3 + 0];
        uchar g = row[x * 3 + 1];
        uchar r = row[x * 3 + 2];
    }
}
</code></pre>
<h3>Mat类型代码说明</h3>
<pre><code>// CV_&lt;bit-depth&gt;{U|S|F}C&lt;channels&gt;
CV_8UC1   // 8位无符号，1通道（灰度图）
CV_8UC3   // 8位无符号，3通道（BGR彩色图）
CV_32FC1  // 32位浮点，1通道
CV_16SC3  // 16位有符号，3通道
</code></pre>
<hr />
<h2>5. cv::imwrite() - 保存图片</h2>
<h3>函数原型</h3>
<pre><code>bool cv::imwrite(const String&amp; filename, InputArray img);
</code></pre>
<h3>基础用法</h3>
<pre><code>cv::Mat img = cv::imread("input.jpg");

// 处理图像...

// 保存为JPG（有损压缩）
cv::imwrite("output.jpg", img);

// 保存为PNG（无损压缩，推荐保存二值图）
cv::imwrite("binary.png", binaryImg);
</code></pre>
<h3>设置压缩质量</h3>
<pre><code>// JPG质量控制（0-100，默认95）
std::vector&lt;int&gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // 质量90%
cv::imwrite("output.jpg", img, jpg_params);

// PNG压缩级别（0-9，默认3）
std::vector&lt;int&gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // 最大压缩
cv::imwrite("output.png", img, png_params);
</code></pre>
<hr />
<h2>6. cv::VideoCapture - 打开相机/视频</h2>
<h3>函数原型</h3>
<pre><code>cv::VideoCapture cap(int device);         // 打开相机
cv::VideoCapture cap(const String&amp; filename);  // 打开视频文件
</code></pre>
<h3>打开相机</h3>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;

int main() {
    // 打开默认相机（设备ID=0）
    cv::VideoCapture cap(0);
    
    // 检查是否成功打开
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "❌ 相机打开失败" &lt;&lt; std::endl;
        return -1;
    }
    
    // 设置相机参数（可选）
    cap.set(cv::CAP_PROP_FRAME_WIDTH, 1280);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 720);
    cap.set(cv::CAP_PROP_FPS, 60);
    
    cv::Mat frame;
    while (true) {
        // 读取一帧
        cap.read(frame);
        // 或者: cap &gt;&gt; frame;
        
        if (frame.empty()) {
            std::cerr &lt;&lt; "❌ 无法读取帧" &lt;&lt; std::endl;
            break;
        }
        
        // 显示
        cv::imshow("Camera", frame);
        
        // 按ESC退出
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<h3>读取视频文件</h3>
<pre><code>cv::VideoCapture cap("video.mp4");

if (!cap.isOpened()) {
    std::cerr &lt;&lt; "视频文件打开失败" &lt;&lt; std::endl;
    return -1;
}

// 获取视频信息
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &lt;&lt; "视频信息: " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height 
          &lt;&lt; " @ " &lt;&lt; fps &lt;&lt; "fps, 共" &lt;&lt; frame_count &lt;&lt; "帧" &lt;&lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow("Video", frame);
    if (cv::waitKey(1000/fps) == 27) break;  // 按原速播放
}
</code></pre>
<hr />
<h2>本阶段实战练习</h2>
<p>&lt;/details&gt;</p>
<h3>练习: 相机实时预览</h3>
<p>实现一个相机预览程序，显示当前FPS</p>
<p>&lt;details&gt;
&lt;summary&gt; 参考答案&lt;/summary&gt;</p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &lt;&lt; "相机打开失败" &lt;&lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &gt;&gt; frame;
        if (frame.empty()) break;
        
        // 计算FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&lt;double&gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // 在图像上绘制FPS
        std::string fps_text = "FPS: " + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow("Camera Preview", frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
</code></pre>
<p>&lt;/details&gt;</p>
<hr />
<h2>检查清单</h2>
<p>完成本阶段后，你应该能够：</p>
<ul>
<li>[ ] 用 <code>cv::imread()</code> 读取图片并检查是否成功</li>
<li>[ ] 用 <code>cv::imshow()</code> 和 <code>cv::waitKey()</code> 显示图片</li>
<li>[ ] 理解Mat对象的基本属性（rows, cols, channels）</li>
<li>[ ] 用 <code>cv::imwrite()</code> 保存处理结果</li>
<li>[ ] 用 <code>cv::VideoCapture</code> 打开相机并实时显示</li>
</ul>
<hr />
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>更新日志</title>
    <link href="https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>这里是更新日志</summary>
    <content type="html"><![CDATA[<h2>2025-10-22</h2>
<ul>
<li>更新了个人简介</li>
<li>更新了rm笔记</li>
<li>更新了双指针的框架</li>
<li>评论没挂服务器所以不能用</li>
</ul>
<h2>2025-10-23</h2>
<ul>
<li>更新了快慢指针</li>
</ul>
<h2>2025-10-24</h2>
<ul>
<li>更新了两篇opencv入门，ai写的，以后看着能不能精简一下</li>
</ul>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="日志"></category>
  </entry>
  <entry>
    <title>双指针</title>
    <link href="https://www.nanye404.top/posts/twop/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/twop/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>双指针常见技巧</summary>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8">双指针在数组的运用</a>
<ul>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">快慢指针</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2">二分搜索</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li>
<li><a href="#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC">回文/反转</a></li>
<li><a href="#%E6%95%B0%E4%B9%8B%E5%92%8C">数之和</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8">双指针在链表的运用</a>
<ul>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a></li>
<li><a href="#%E5%88%86%E8%A7%A3">分解</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<hr />
<h2>双指针在数组的运用</h2>
<hr />
<h2>快慢指针</h2>
<h3>数组的原地修改</h3>
<ul>
<li>力扣第 26 题「删除有序数组中的重复项」，让你在有序数组去重：
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</li>
</ul>
<hr />
<ul>
<li>给你一个<strong>非严格递增排列</strong>的数组<code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。元素的<strong>相对顺序</strong>应该保持<strong>一致</strong>。然后返回 <code>nums</code> 中唯一元素的个数。</li>
<li>考虑 <code>nums </code>的唯一元素的数量为 <code>k</code>。去重后，返回唯一元素的数量 k。</li>
<li><code>nums</code> 的前 k 个元素应包含 排序后 的唯一数字。下标 <code>k - 1 </code>之后的剩余元素可以忽略。</li>
</ul>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<pre><code>int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案
int k = removeDuplicates(nums); // 调用
assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</code></pre>
<p>如果所有断言都通过，那么您的题解将被<strong>通过</strong>。</p>
<p>示例 1：</p>
<pre><code>输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p>示例 2：</p>
<pre><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的
</code></pre>
<ul>
<li><strong>原地</strong>意味着只能对当前数组进行修改，不能新建一个数组</li>
<li>这里所需要用到的就是<strong>快慢指针</strong></li>
<li>简单来说就是一个快指针去识别，另一个慢指针去操作</li>
<li><strong>注意</strong>  这里指针是广义上的指针，数组的索引也可以是<strong>指针</strong></li>
<li>如果 <code>fast</code> 遇到值为 <code>val </code>的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow </code>前进一步。</li>
</ul>
<p>具体代码如下</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
</code></pre>
<ul>
<li>注意这里需要<strong>先<code>slow++</code>再赋值</strong>，要不然第一个会被吞掉</li>
</ul>
<hr />
<ul>
<li>下面一道题也是快慢指针的思想，如果掌握了前一道题，这题会很简单</li>
<li><strong>力扣283移动0</strong>https://leetcode.cn/problems/move-zeroes/</li>
<li>给定一个数组 <strong>nums</strong>，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li>
<li>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</li>
</ul>
<p>示例 1:</p>
<pre><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:
</code></pre>
<pre><code>输入: nums = [0]
输出: [0]
</code></pre>
<p>这里我就直接上代码了</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int slow = 0;  // 指向下一个非零应放置的位置
        for (int fast = 0; fast &lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow 之后的全部置为 0
        for (int i = slow; i &lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

</code></pre>
<hr />
<h2>二分搜索</h2>
<ul>
<li>
<p>在我们都玩过的猜数字游戏中，用的就是二分搜素的技巧</p>
</li>
<li>
<p>我们先看最笨的顺序查找，我们从1-100遍历全部数字，虽然说运气好可能一下会猜中，但是期望的次数还是很多，复杂度为O(n)</p>
</li>
<li>
<p>如果是凭感觉找，一样还是要看运气</p>
</li>
<li>
<p>如果第一次猜50，然后继续一半一半缩小区间，最坏也能在7次内解决</p>
<ul>
<li>如何数字来到1-1000000，二分搜索最坏20次就能找到答案</li>
</ul>
</li>
<li>
<p>二分搜索的时间复杂度是O(log  N)</p>
</li>
<li>
<p>下面是最基本代码</p>
</li>
</ul>
<pre><code>int binarySearch(vector&lt;int&gt;&amp; nums, int target) {
    // 一左一右两个指针相向而行
    int left = 0, right = nums.size() - 1;
    while(left &lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &lt; target)
            left = mid + 1; 
        else if (nums[mid] &gt; target)
            right = mid - 1;
    }
    return -1;
}
</code></pre>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="算法"></category>
  </entry>
  <entry>
    <title>装甲板自动识别与位姿估计学习</title>
    <link href="https://www.nanye404.top/posts/armor/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/armor/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-10-22T00:00:00.000Z</updated>
    <summary>一些小笔记</summary>
    <content type="html"><![CDATA[<h2>目录</h2>
<ol>
<li><a href="#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88">总览：系统做的事情是什么</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A">关键知识点速通</a></li>
<li><a href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86">端到端流程图（一帧图像如何被处理）</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">模块逐个拆解（含核心代码片段）</a>
<ul>
<li>4.1 数字分类器 <code>NumberClassifier</code></li>
<li>4.2 视觉检测器 <code>Detector</code></li>
<li>4.3 灯条角点精修 <code>LightCornerCorrector</code></li>
<li>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</li>
<li>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></li>
<li>4.6 ROS2 节点 <code>ArmorDetectorNode</code></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97">参数如何影响效果（调参指南）</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96">实战：从源码到运行与可视化</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF">常见问题与定位思路</a></li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA">进阶练习题（带方向提示）</a></li>
<li><a href="#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84">术语与坐标系小抄</a></li>
</ol>
<hr />
<h2>总览：系统做的事情是什么</h2>
<p><strong>目标</strong>：从相机来的彩色图像中，自动找出“<strong>两根灯条组成的装甲板</strong>”，<strong>识别装甲数字</strong>，并估计装甲板在<strong>相机坐标系</strong>下的三维位姿（位置 + 姿态），最后通过 <strong>ROS2</strong> 发布结果与可视化。</p>
<p><strong>关键阶段</strong>：</p>
<ol>
<li>图像预处理 → 二值化轮廓 → <strong>灯条候选</strong>。</li>
<li>灯条几何筛选 &amp; 颜色判定 → <strong>灯条配对成装甲板</strong>。</li>
<li>透视展开中部区域 → <strong>数字分类</strong>（ONNX 模型）。</li>
<li>对灯条上下角点做<strong>几何细化</strong>（提升 PnP 稳定性）。</li>
<li>用 <strong>PnP 求初解</strong> → 条件允许时用 **BA（仅优化 yaw）**做小优化。</li>
<li>封装为 ROS2 节点：<strong>订阅图像/相机内参/TF</strong>，发布调试图像与 <strong>Marker</strong>。</li>
</ol>
<hr />
<h2>关键知识点速通</h2>
<ul>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;图像读取与显示&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_02/"&gt;装甲板颜色提取&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_03/"&gt;形态学处理&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_04/"&gt;轮廓检测&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;我的第一篇文章&lt;/a&gt;</li>
<li>&lt;a href="/posts/rm_opencv_01/"&gt;我的第一篇文章&lt;/a&gt;</li>
</ul>
<h2>端到端流程图（一帧图像如何被处理）</h2>
<pre><code>Image(rgb8)
   └─► 预处理(灰度/阈值)
          └─► 轮廓→灯条(Light)
                 └─► 同色 + 几何关系 → 装甲(Armor)
                        ├─► (可选) 灯条角点精修
                        ├─► 透视展开数字ROI → 二值化 → 分类
                        └─► PnP求位姿 → (可选) BA优化yaw
                               └─► 发布Armors + RViz Marker + 调试图像
</code></pre>
<hr />
<h2>模块逐个拆解（含核心代码片段）</h2>
<h3>4.1 数字分类器 <code>NumberClassifier</code></h3>
<p><strong>职责</strong>：从装甲板两根灯条之间裁出数字图（固定尺寸），二值化后喂给 ONNX 分类网络，得到类别与置信度。</p>
<p><strong>核心：透视展开 + 二值化 + DNN 前向</strong></p>
<pre><code>// 透视展开并裁 ROI（宽度随大小装甲而变）
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp; src, const Armor&amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // 中部 ROI → 灰度&amp;OTSU → 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
</code></pre>
<pre><code>// 前向分类 + 结果解码
void NumberClassifier::classify(const cv::Mat&amp;, Armor&amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;conf, nullptr, &amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format("{}:{:.1f}%", armor.number, armor.confidence * 100.0);
}
</code></pre>
<pre><code>// 过滤：按阈值/忽略列表 + 大小装甲与类别的互斥规则
void NumberClassifier::eraseIgnoreClasses(std::vector&lt;Armor&gt;&amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;a) {
    if (a.confidence &lt; threshold) return true;
    for (auto&amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == "outpost" || a.number == "2" || a.number == "sentry");
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == "1"      || a.number == "base");
    return mismatch;
  }), armors.end());
}
</code></pre>
<p><strong>要点</strong>：ROI 宽度与装甲尺寸匹配；OTSU 让阈值更稳；<code>blobFromImage</code> 封装归一化与 NHWC→NCHW。</p>
<hr />
<h3>4.2 视觉检测器 <code>Detector</code></h3>
<p><strong>职责</strong>：灰度/阈值 → 轮廓 → 灯条（形状 + 倾角）→ 统计颜色 → 左右同色配对 → 装甲。若有分类器与角点修正器，则并行进行数字分类与角点细化。</p>
<p><strong>总体流程</strong></p>
<pre><code>std::vector&lt;Armor&gt; Detector::detect(const cv::Mat&amp; input) noexcept {
  binary_img = preprocessImage(input);               // 灰度+固定阈值
  lights_    = findLights(input, binary_img);        // 轮廓→Light（比例/角度/颜色）
  armors_    = matchLights(lights_);                 // 左右配对 → Armor

  if (!armors_.empty() &amp;&amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;input](Armor&amp; a){
      a.number_img = classifier-&gt;extractNumber(input, a);
      classifier-&gt;classify(input, a);
      if (corner_corrector) corner_corrector-&gt;correctCorners(a, gray_img_);
    });
    classifier-&gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
</code></pre>
<p><strong>关键判定：灯条与配对</strong></p>
<pre><code>// 灯条筛选：短长边比 + 倾角
bool Detector::isLight(const Light&amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &lt; ratio &amp;&amp; ratio &lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &lt; light_params.max_angle;
  return ratio_ok &amp;&amp; angle_ok;
}

// 颜色：在轮廓像素中统计R/B强度差（红/蓝）
for (auto&amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &gt; light_params.color_diff_thresh)
  light.color = (sum_r &gt; sum_b ? RED : BLUE);

// 夹灯检测：两灯条外接矩形内是否还“夹”着别的灯条（且排除数字/红点等干扰）
bool containLight(int i, int j, const std::vector&lt;Light&gt;&amp; lights);

// 配对：同色 + X方向扫描 + 中心距窗口（区分大小装甲）+ 两灯条长度相近 + 夹角限制
std::vector&lt;Armor&gt; Detector::matchLights(const std::vector&lt;Light&gt;&amp; lights) noexcept;
</code></pre>
<hr />
<h3>4.3 灯条角点精修 <code>LightCornerCorrector</code></h3>
<p><strong>职责</strong>：更精确地找到每根灯条的<strong>上下端点</strong>与<strong>中心/轴向</strong>，提升 PnP 的 2D-3D 对应精度（在二值化或噪声环境下尤其有用）。</p>
<p><strong>算法思路</strong>：</p>
<ol>
<li>以灯条外接框为基础做<strong>适度扩展</strong>并检查边界；</li>
<li>对该小区域做<strong>重心与主方向</strong>估计（亮度加权 + PCA/一阶矩），得到<strong>对称轴</strong>；</li>
<li>沿对称轴的上下方向，以多个平行“扫描线”寻找<strong>亮度突变最大</strong>的位置作为端点候选，最后求平均。</li>
</ol>
<p><strong>要点代码</strong></p>
<pre><code>// 角点修正入口：宽度太小则跳过，避免噪声
void LightCornerCorrector::correctCorners(Armor&amp; armor, const cv::Mat&amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
  if (armor.right_light.width &gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp; 角点 */ }
}

// 沿对称轴寻找“亮度突变最大”的点作为角点（多条平行线，取候选平均）
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp; gray, const Light&amp; light,
                                             const SymmetryAxis&amp; axis, std::string order) {
  // ... 扫描 START~END 的小段，累计亮度差最大处 ...
  // 返回均值点；无候选则返回 (-1,-1)
}
</code></pre>
<hr />
<h3>4.4 位姿估计 <code>ArmorPoseEstimator</code>（PnP + BA）</h3>
<p><strong>职责</strong>：把装甲四角的 2D 像素点与已知 3D 模型点（大/小装甲的真实尺寸）对应，解出 R/t。若 roll 小且开启 BA，则进一步仅在 <strong>yaw</strong> 维进行图优化，使投影误差更小。</p>
<p><strong>核心流程</strong></p>
<pre><code>// 1) PnP 初解（solvePnPGeneric 可能返回两组解）
if (pnp_solver_-&gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) 解的选择（误差/roll/灯条倾角→yaw正负）

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;&amp; roll &lt; 15) {
    // 3) BA：仅优化 yaw，小幅修正 R 以减小投影误差
    R = ba_solver_-&gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) 填充消息（位姿 + 文本）
}
</code></pre>
<p><strong>两解选择（直觉）</strong>：</p>
<ul>
<li>先看<strong>重投影误差</strong>与 <strong>roll</strong>（太差的解直接放弃切换）；</li>
<li>再用<strong>灯条在像面上的整体倾斜</strong>来判断当前<strong>yaw 的正负是否“合理”</strong>，必要时对调解。</li>
</ul>
<hr />
<h3>4.5 BA 优化器与图优化算子 <code>BaSolver</code> / <code>GraphOptimizer</code></h3>
<p><strong>思想</strong>：只把<strong>装甲 yaw</strong> 当成优化变量（一个顶点 <code>VertexYaw</code>），装甲的 3D 角点为固定顶点。观测为每个角点在图像里的像素位置，误差就是<strong>观测像素</strong>减去<strong>投影像素</strong>。这样 BA 既轻量又能稳住姿态。</p>
<p><strong>构图与优化</strong></p>
<pre><code>// 填图：一个 yaw 顶点 + 四个固定的 3D 顶点 + 四条投影误差边（带 Huber 鲁棒核）
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&gt;setVertex(0, v_yaw); e-&gt;setVertex(1, vp);
  e-&gt;setMeasurement(pixel_observation);
  e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
</code></pre>
<pre><code>// 自定义顶点增量：在 SO3 上用李代数更新 yaw，避免角度跳变
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
</code></pre>
<pre><code>// 投影边误差：像素观测 - 投影(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&lt;VertexYaw*&gt;(_vertices[0])-&gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&lt;2&gt;();
  _error = obs - proj;
}
</code></pre>
<hr />
<h3>4.6 ROS2 节点 <code>ArmorDetectorNode</code></h3>
<p><strong>职责</strong>：把检测 → 分类 →（可选）角点修正 → PnP/BA → 发布可视化，全流程在 ROS2 中跑起来。负责：参数、订阅/发布、TF、调试。</p>
<p><strong>节点初始化（节选）</strong></p>
<pre><code>// 读取参数，初始化 Detector、NumberClassifier、LightCornerCorrector
int binary_thres = declare_parameter("binary_thres", 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&lt;Detector&gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/lenet.onnx");
auto label_path = utils::URLResolver::getResolvedPath("package://armor_detector/model/label.txt");
double threshold = declare_parameter("classifier_threshold", 0.7);
auto ignores = declare_parameter&lt;std::vector&lt;std::string&gt;&gt;("ignore_classes", {"negative"});
detector_-&gt;classifier = std::make_unique&lt;NumberClassifier&gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter("use_pca", true);
if (use_pca) detector_-&gt;corner_corrector = std::make_unique&lt;LightCornerCorrector&gt;();
</code></pre>
<p><strong>图像回调（节选）</strong></p>
<pre><code>// 1) TF: odom → 相机的旋转矩阵（IMU→Camera）
auto odom_to_cam = tf2_buffer_-&gt;lookupTransform(odom_frame_, img_msg-&gt;header.frame_id, img_msg-&gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) 检测 + 分类 + 角点修正
auto armors = detector_-&gt;detect(cv_bridge::toCvShare(img_msg, "rgb8")-&gt;image);

// 3) PnP/BA 提取位姿
armors_msg_.armors = armor_pose_estimator_-&gt;extractArmorPoses(armors, imu_to_camera);

// 4) 可视化与发布：Marker / 调试图像 / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&gt;publish(armors_msg_);
</code></pre>
<hr />
<h2>参数如何影响效果（调参指南）</h2>
<ul>
<li><code>binary_thres</code>：阈值高→噪点少但灯条可能断；阈值低→连通域粘连。先打开调试图像话题观察再调。</li>
<li><code>light.min_ratio / max_ratio / max_angle</code>：控制灯条的“细长”和“近垂直”程度；误检多就收紧，漏检多就放宽。</li>
<li><code>light.color_diff_thresh</code>：越大越“保守”地判断颜色；太小会把杂散光当成红/蓝。</li>
<li><code>armor.*_center_distance</code>：两灯条中心距窗口；与焦距/距离有关，镜头变化后要重调。</li>
<li><code>classifier_threshold / ignore_classes</code>：分类阈值与忽略类，先松后紧，结合实测混淆再收敛。</li>
<li><code>use_pca</code>：角点修正，噪声环境或分辨率不高时常有帮助。</li>
<li><code>use_ba</code>：轻量的 yaw 优化，能减抖、稳姿态；但在极端视角下可能收益有限。</li>
</ul>
<hr />
<h2>实战：从源码到运行与可视化</h2>
<ol>
<li><strong>准备</strong>：相机话题 <code>image_raw</code>、<code>camera_info</code>，并确认 TF 链路（<code>odom → camera</code>）。</li>
<li><strong>启动节点</strong>：加载参数（上面提到的阈值与窗口）并打开 <code>debug</code>。</li>
<li><strong>RViz</strong>：添加 <code>MarkerArray</code> 订阅 <code>armor_detector/marker</code>；把调试图像话题（<code>binary_img/number_img/result_img</code>）也开出来。</li>
<li><strong>观察与调整</strong>：
<ul>
<li>先让<strong>灯条候选</strong>稳定 → 再看<strong>配对</strong>是否合理 → 最后看<strong>数字分类</strong>与<strong>位姿</strong>是否稳定。</li>
<li>逐项微调参数，记录每项调整对召回/精度的影响。</li>
</ul>
</li>
</ol>
<hr />
<h2>常见问题与定位思路</h2>
<ul>
<li><strong>灯条“夹灯”/误配对</strong>：检查 <code>containLight</code> 规则与数字/红点宽度过滤；适当提高 <code>color_diff_thresh</code>。</li>
<li><strong>分类不稳</strong>：对比 <code>number_img</code> 是否干净；检查 ROI 宽度是否与大/小装甲一致；适当调阈值或忽略类。</li>
<li><strong>位姿“翻面”</strong>：理解 <code>sortPnPResult</code> 的选择逻辑（误差、roll、灯条倾角与 yaw 正负），必要时在近景贴纸纹理上做辅助。</li>
<li><strong>姿态抖动</strong>：开启 <code>use_ba</code>；或在 <code>LightCornerCorrector</code> 中加大候选条数。</li>
</ul>
<hr />
<h2>进阶练习题（带方向提示）</h2>
<ol>
<li><strong>把阈值改成自适应</strong>：尝试 <code>cv::adaptiveThreshold</code> 或根据区域亮度动态调 <code>binary_thres</code>。</li>
<li><strong>加入时序稳定</strong>：在 <code>Detector</code> 输出上做跟踪（Kalman/匈牙利匹配），让数字与姿态在帧间更稳。</li>
<li><strong>数据增强与再训练</strong>：对 <code>number_img</code> 做随机仿射/噪声增强，微调 ONNX 模型，观察混淆类的改善。</li>
<li><strong>多目标选择策略</strong>：当同屏多块装甲时，基于 <code>distance_to_image_center</code>、置信度或历史 ID 选择目标。</li>
</ol>
<hr />
<h2>术语与坐标系小抄</h2>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="RM"></category>
  </entry>
  <entry>
    <title>视频测试</title>
    <link href="https://www.nanye404.top/posts/video/" rel="alternate" type="text/html"/>
    <id>https://www.nanye404.top/posts/video/</id>
    <published>2025-10-21T00:00:00.000Z</published>
    <updated>2025-10-21T00:00:00.000Z</updated>
    <summary>视频测试。</summary>
    <content type="html"><![CDATA[<p>这是视频测试</p>
<h2>YouTube</h2>
<p>&lt;iframe width="100%" height="468" src="https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;</p>
<h2>Bilibili</h2>
<p>&lt;iframe width="100%" height="468" src="//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" &amp;autoplay=0&gt; &lt;/iframe&gt;</p>
]]></content>
    <author>
      <name>南叶酱</name>
    </author>
    <category term="测试"></category>
  </entry>
</feed>