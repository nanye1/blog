<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>南叶の小窝</title><description>欢迎来玩awa</description><link>https://www.nanye404.top/</link><language>zh_CN</language><item><title>RM装甲板识别 - 05灯条配对</title><link>https://www.nanye404.top/posts/armor_detection_part1/</link><guid isPermaLink="true">https://www.nanye404.top/posts/armor_detection_part1/</guid><description>无</description><pubDate>Sun, 26 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;核心API清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::norm()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算两点距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;std::abs()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;绝对值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::line()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;绘制直线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::rectangle()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;绘制矩形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::putText()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;绘制文字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;装甲板的四大判据&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;判据&lt;/th&gt;
&lt;th&gt;物理意义&lt;/th&gt;
&lt;th&gt;合理范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;距离&lt;/td&gt;
&lt;td&gt;两灯条中心间距&lt;/td&gt;
&lt;td&gt;1.5~4倍灯条长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;角度差&lt;/td&gt;
&lt;td&gt;两灯条是否平行&lt;/td&gt;
&lt;td&gt;&amp;lt; 10°&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长度比&lt;/td&gt;
&lt;td&gt;两灯条长度比&lt;/td&gt;
&lt;td&gt;1.0~2.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;高度差&lt;/td&gt;
&lt;td&gt;两灯条y坐标差&lt;/td&gt;
&lt;td&gt;&amp;lt; 0.5倍灯条长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;1️ 距离判断：cv::norm()&lt;/h2&gt;
&lt;h3&gt;计算两点欧氏距离&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Point2f p1(100, 200);
cv::Point2f p2(400, 500);

double distance = cv::norm(p1 - p2);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;应用：计算灯条间距&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 两个灯条的中心点
cv::Point2f center1 = bar1.rect.center;
cv::Point2f center2 = bar2.rect.center;

// 计算距离
float distance = cv::norm(center1 - center2);

// 判断距离是否合理（参数随便给的）
float avgLength = (bar1.rect.size.height + bar2.rect.size.height) / 2;
if (distance &amp;lt; avgLength * 1.5 || distance &amp;gt; avgLength * 4.0) {
    // 距离不合理，不是装甲板
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;2️ 角度差判断&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;float angle1 = bar1.rect.angle;
float angle2 = bar2.rect.angle;

// 计算角度差的绝对值
float angleDiff = std::abs(angle1 - angle2);

// 判断是否平行
if (angleDiff &amp;gt; 10.0) {
    // 角度差太大，不平行
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;角度差的陷阱&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 问题：OpenCV的angle范围是-90°到0°
// 如果一个灯条angle=-5°，另一个是-85°
// 直接相减：|-5 - (-85)| = 80°  实际上它们可能是平行的！

// 解决方案：归一化角度
float normalizeAngle(float angle) {
    // 将angle转换到0-90范围
    angle = std::abs(angle);
    if (angle &amp;gt; 90) angle = 180 - angle;
    return angle;
}

float angle1 = normalizeAngle(bar1.rect.angle);
float angle2 = normalizeAngle(bar2.rect.angle);
float angleDiff = std::abs(angle1 - angle2);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3️ 长度比判断&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;float length1 = bar1.rect.size.height;  // 假设已确保height是长边
float length2 = bar2.rect.size.height;

// 计算长度比（大/小）
float lengthRatio = std::max(length1, length2) / std::min(length1, length2);

// 判断
if (lengthRatio &amp;gt; 2.0) {
    // 长度相差超过2倍，不是装甲板
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4️ 高度差判断&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;float centerY1 = bar1.rect.center.y;
float centerY2 = bar2.rect.center.y;

// 计算y坐标差的绝对值
float heightDiff = std::abs(centerY1 - centerY2);

// 用平均长度作为参考
float avgLength = (bar1.rect.size.height + bar2.rect.size.height) / 2;

// 判断高度差是否合理
if (heightDiff &amp;gt; avgLength * 0.5) {
    // 高度差太大，不在同一水平线
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;数据结构设计&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

// 灯条结构体
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar(const cv::RotatedRect&amp;amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        
        // 确保长边是height
        if (r.size.width &amp;gt; r.size.height) {
            angle += 90;
        }
    }
};

// 装甲板结构体
struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp;amp; left, const LightBar&amp;amp; right) 
        : leftBar(left), rightBar(right) {
        // 计算装甲板中心
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        
        // 计算宽高
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;核心判断函数&lt;/h2&gt;
&lt;h3&gt;归一化角度函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 归一化角度到0-90度范围
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &amp;gt; 90) {
        angle = 180 - angle;
    }
    return angle;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;判断两个灯条能否组成装甲板&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;bool isValidArmorPair(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    // ============ 判据1：距离检查 ============
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 距离应该在1.5~4倍平均长度之间
    if (distance &amp;lt; avgLength * 1.5) {
        std::cout &amp;lt;&amp;lt; &quot; 距离太近: &quot; &amp;lt;&amp;lt; distance 
                  &amp;lt;&amp;lt; &quot; &amp;lt; &quot; &amp;lt;&amp;lt; avgLength * 1.5 &amp;lt;&amp;lt; std::endl;
        return false;
    }
    if (distance &amp;gt; avgLength * 4.0) {
        std::cout &amp;lt;&amp;lt; &quot; 距离太远: &quot; &amp;lt;&amp;lt; distance 
                  &amp;lt;&amp;lt; &quot; &amp;gt; &quot; &amp;lt;&amp;lt; avgLength * 4.0 &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    // ============ 判据2：角度检查 ============
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    
    // 角度差应小于10度
    if (angleDiff &amp;gt; 10.0) {
        std::cout &amp;lt;&amp;lt; &quot; 角度差太大: &quot; &amp;lt;&amp;lt; angleDiff &amp;lt;&amp;lt; &quot;°&quot; &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    // ============ 判据3：长度比检查 ============
    float maxLength = std::max(bar1.length, bar2.length);
    float minLength = std::min(bar1.length, bar2.length);
    float lengthRatio = maxLength / minLength;
    
    // 长度比应小于2.0
    if (lengthRatio &amp;gt; 2.0) {
        std::cout &amp;lt;&amp;lt; &quot; 长度比过大: &quot; &amp;lt;&amp;lt; lengthRatio &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    // ============ 判据4：高度差检查 ============
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    
    // 高度差应小于平均长度的50%
    if (heightDiff &amp;gt; avgLength * 0.5) {
        std::cout &amp;lt;&amp;lt; &quot; 高度差太大: &quot; &amp;lt;&amp;lt; heightDiff 
                  &amp;lt;&amp;lt; &quot; &amp;gt; &quot; &amp;lt;&amp;lt; avgLength * 0.5 &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    // ============ 通过所有判据 ============
    std::cout &amp;lt;&amp;lt; &quot;[通过] 距离:&quot; &amp;lt;&amp;lt; distance 
              &amp;lt;&amp;lt; &quot; 角度差:&quot; &amp;lt;&amp;lt; angleDiff 
              &amp;lt;&amp;lt; &quot; 长度比:&quot; &amp;lt;&amp;lt; lengthRatio 
              &amp;lt;&amp;lt; &quot; 高度差:&quot; &amp;lt;&amp;lt; heightDiff &amp;lt;&amp;lt; std::endl;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;配对主函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// 从灯条列表中配对出所有装甲板
std::vector&amp;lt;ArmorPlate&amp;gt; findArmorPlates(const std::vector&amp;lt;LightBar&amp;gt;&amp;amp; lightBars) {
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates;
    
    std::cout &amp;lt;&amp;lt; &quot;\n========== 开始配对 ==========&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;灯条数量: &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; std::endl;
    
    // 双重循环遍历所有灯条对
    for (size_t i = 0; i &amp;lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &amp;lt; lightBars.size(); j++) {
            const LightBar&amp;amp; bar1 = lightBars[i];
            const LightBar&amp;amp; bar2 = lightBars[j];
            
            std::cout &amp;lt;&amp;lt; &quot;\n测试灯条对 (&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot;):&quot; &amp;lt;&amp;lt; std::endl;
            
            // 判断能否组成装甲板
            if (isValidArmorPair(bar1, bar2)) {
                // 确保左边的灯条在左侧
                if (bar1.center.x &amp;lt; bar2.center.x) {
                    armorPlates.emplace_back(bar1, bar2);
                } else {
                    armorPlates.emplace_back(bar2, bar1);
                }
                std::cout &amp;lt;&amp;lt; &quot; 找到装甲板！&quot; &amp;lt;&amp;lt; std::endl;
            }
        }
    }
    
    std::cout &amp;lt;&amp;lt; &quot;\n========== 配对完成 ==========&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;找到装甲板数量: &quot; &amp;lt;&amp;lt; armorPlates.size() &amp;lt;&amp;lt; std::endl;
    
    return armorPlates;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;可视化绘制函数&lt;/h2&gt;
&lt;h3&gt;绘制单个装甲板&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawArmorPlate(cv::Mat&amp;amp; image, const ArmorPlate&amp;amp; armor, int index) {
    // 1. 绘制左侧灯条（绿色）
    cv::Point2f vertices1[4];
    armor.leftBar.rect.points(vertices1);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(image, vertices1[i], vertices1[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 2. 绘制右侧灯条（绿色）
    cv::Point2f vertices2[4];
    armor.rightBar.rect.points(vertices2);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(image, vertices2[i], vertices2[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 3. 绘制连接线（黄色）
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    
    // 4. 绘制装甲板外框（蓝色）
    cv::Point2f topLeft = vertices1[0];
    cv::Point2f topRight = vertices2[1];
    cv::Point2f bottomRight = vertices2[2];
    cv::Point2f bottomLeft = vertices1[3];
    
    cv::line(image, topLeft, topRight, cv::Scalar(255, 0, 0), 2);
    cv::line(image, topRight, bottomRight, cv::Scalar(255, 0, 0), 2);
    cv::line(image, bottomRight, bottomLeft, cv::Scalar(255, 0, 0), 2);
    cv::line(image, bottomLeft, topLeft, cv::Scalar(255, 0, 0), 2);
    
    // 5. 绘制中心点（红色）
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 6. 显示装甲板信息
    std::string info = &quot;Armor#&quot; + std::to_string(index);
    cv::putText(image, info, 
                cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, 
                cv::Scalar(255, 255, 255), 2);
    
    // 7. 显示宽度信息
    std::string sizeInfo = &quot;W:&quot; + std::to_string((int)armor.width);
    cv::putText(image, sizeInfo, 
                cv::Point(armor.center.x - 25, armor.center.y + 5),
                cv::FONT_HERSHEY_SIMPLEX, 0.4, 
                cv::Scalar(255, 255, 255), 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;绘制所有装甲板&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawAllArmorPlates(cv::Mat&amp;amp; image, const std::vector&amp;lt;ArmorPlate&amp;gt;&amp;amp; armorPlates) {
    for (size_t i = 0; i &amp;lt; armorPlates.size(); i++) {
        drawArmorPlate(image, armorPlates[i], i);
    }
    
    // 在左上角显示统计信息
    std::string stats = &quot;Armors: &quot; + std::to_string(armorPlates.size());
    cv::putText(image, stats, cv::Point(10, 30),
                cv::FONT_HERSHEY_SIMPLEX, 1.0, 
                cv::Scalar(0, 255, 255), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;完整主函数&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int main() {
    // 1. 读取图片
    cv::Mat src = cv::imread(&quot;armor_test.jpg&quot;);
    if (src.empty()) {
        std::cerr &amp;lt;&amp;lt; &quot; 无法读取图片！&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    std::cout &amp;lt;&amp;lt; &quot; 图片读取成功: &quot; &amp;lt;&amp;lt; src.cols &amp;lt;&amp;lt; &quot;x&quot; &amp;lt;&amp;lt; src.rows &amp;lt;&amp;lt; std::endl;
    
    // 2. 预处理（这里假设你已经有灯条检测函数）
    std::vector&amp;lt;LightBar&amp;gt; lightBars = detectLightBars(src);
    
    std::cout &amp;lt;&amp;lt; &quot; 检测到 &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; &quot; 个灯条&quot; &amp;lt;&amp;lt; std::endl;
    
    // 3. 装甲板配对
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates = findArmorPlates(lightBars);
    
    // 4. 绘制结果
    cv::Mat result = src.clone();
    drawAllArmorPlates(result, armorPlates);
    
    // 5. 显示和保存
    cv::imshow(&quot;原图&quot;, src);
    cv::imshow(&quot;装甲板检测结果&quot;, result);
    cv::imwrite(&quot;armor_result.jpg&quot;, result);
    
    std::cout &amp;lt;&amp;lt; &quot;\n========== 最终结果 ==========&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot; 成功检测到 &quot; &amp;lt;&amp;lt; armorPlates.size() &amp;lt;&amp;lt; &quot; 个装甲板&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;结果已保存到 armor_result.jpg&quot; &amp;lt;&amp;lt; std::endl;
    
    cv::waitKey(0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;完整可运行示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

// ========== 数据结构 ==========
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar() : length(0), angle(0) {}
    
    LightBar(const cv::RotatedRect&amp;amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        if (r.size.width &amp;gt; r.size.height) {
            angle += 90;
        }
    }
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp;amp; left, const LightBar&amp;amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};

// ========== 核心函数 ==========
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &amp;gt; 90) angle = 180 - angle;
    return angle;
}

bool isValidArmorPair(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    if (distance &amp;lt; avgLength * 1.5 || distance &amp;gt; avgLength * 4.0) return false;
    
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    if (angleDiff &amp;gt; 10.0) return false;
    
    float lengthRatio = std::max(bar1.length, bar2.length) / 
                        std::min(bar1.length, bar2.length);
    if (lengthRatio &amp;gt; 2.0) return false;
    
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    if (heightDiff &amp;gt; avgLength * 0.5) return false;
    
    return true;
}

std::vector&amp;lt;ArmorPlate&amp;gt; findArmorPlates(const std::vector&amp;lt;LightBar&amp;gt;&amp;amp; lightBars) {
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates;
    
    for (size_t i = 0; i &amp;lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &amp;lt; lightBars.size(); j++) {
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &amp;lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}

void drawArmorPlate(cv::Mat&amp;amp; image, const ArmorPlate&amp;amp; armor, int index) {
    cv::Point2f v1[4], v2[4];
    armor.leftBar.rect.points(v1);
    armor.rightBar.rect.points(v2);
    
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(image, v1[i], v1[(i+1)%4], cv::Scalar(0, 255, 0), 2);
        cv::line(image, v2[i], v2[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    std::string info = &quot;Armor#&quot; + std::to_string(index);
    cv::putText(image, info, cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 2);
}

// ========== 主函数 ==========
int main() {
    cv::Mat src = cv::imread(&quot;armor_test.jpg&quot;);
    if (src.empty()) {
        std::cerr &amp;lt;&amp;lt; &quot;无法读取图片！&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // 假设已有灯条检测函数
    // std::vector&amp;lt;LightBar&amp;gt; lightBars = detectLightBars(src);
    std::vector&amp;lt;LightBar&amp;gt; lightBars;  // 示例数据
    
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates = findArmorPlates(lightBars);
    
    cv::Mat result = src.clone();
    for (size_t i = 0; i &amp;lt; armorPlates.size(); i++) {
        drawArmorPlate(result, armorPlates[i], i);
    }
    
    std::cout &amp;lt;&amp;lt; &quot;检测到 &quot; &amp;lt;&amp;lt; armorPlates.size() &amp;lt;&amp;lt; &quot; 个装甲板&quot; &amp;lt;&amp;lt; std::endl;
    cv::imshow(&quot;结果&quot;, result);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;性能优化&lt;/h2&gt;
&lt;h3&gt;优化1：提前剔除明显不合理的灯条对&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 快速预判（避免不必要的计算）
bool quickReject(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    // 如果x坐标差太小，肯定不是装甲板（两灯条重叠）
    float xDiff = std::abs(bar1.center.x - bar2.center.x);
    if (xDiff &amp;lt; 10) return true;
    
    // 如果x坐标差太大，距离肯定超标
    float maxLength = std::max(bar1.length, bar2.length);
    if (xDiff &amp;gt; maxLength * 5) return true;
    
    return false;
}

std::vector&amp;lt;ArmorPlate&amp;gt; findArmorPlatesOptimized(const std::vector&amp;lt;LightBar&amp;gt;&amp;amp; lightBars) {
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates;
    
    for (size_t i = 0; i &amp;lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &amp;lt; lightBars.size(); j++) {
            // 快速预判
            if (quickReject(lightBars[i], lightBars[j])) {
                continue;
            }
            
            // 详细判断
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &amp;lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;优化2：按x坐标排序（减少比较次数）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;ArmorPlate&amp;gt; findArmorPlatesSorted(std::vector&amp;lt;LightBar&amp;gt; lightBars) {
    // 按x坐标排序
    std::sort(lightBars.begin(), lightBars.end(), 
              [](const LightBar&amp;amp; a, const LightBar&amp;amp; b) {
                  return a.center.x &amp;lt; b.center.x;
              });
    
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates;
    
    for (size_t i = 0; i &amp;lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &amp;lt; lightBars.size(); j++) {
            // 如果j灯条的x坐标已经太远，后面的更远，直接break
            float xDiff = lightBars[j].center.x - lightBars[i].center.x;
            if (xDiff &amp;gt; lightBars[i].length * 5) {
                break;
            }
            
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                armorPlates.emplace_back(lightBars[i], lightBars[j]);
            }
        }
    }
    
    return armorPlates;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;进阶功能&lt;/h2&gt;
&lt;h3&gt;处理倾斜装甲板&lt;/h3&gt;
&lt;p&gt;当装甲板整体倾斜时，需要调整高度差判据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 计算两灯条连线与水平线的夹角
float calculateTiltAngle(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    float dx = bar2.center.x - bar1.center.x;
    float dy = bar2.center.y - bar1.center.y;
    return std::atan2(dy, dx) * 180.0 / CV_PI;
}

// 改进的高度差判据
bool isValidArmorPair_Advanced(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    // ... 前面的判据 ...
    
    // 计算倾斜角度
    float tiltAngle = std::abs(calculateTiltAngle(bar1, bar2));
    
    // 如果倾斜角度大，放宽高度差要求
    float heightThreshold = avgLength * 0.5;
    if (tiltAngle &amp;gt; 15.0) {
        heightThreshold = avgLength * 0.8;  // 放宽到0.8倍
    }
    
    if (heightDiff &amp;gt; heightThreshold) {
        return false;
    }
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区分大小装甲板&lt;/h3&gt;
&lt;p&gt;根据宽高比区分大小装甲板：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum ArmorType {
    SMALL_ARMOR,  // 小装甲板
    LARGE_ARMOR   // 大装甲板
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    ArmorType type;  // 新增：装甲板类型
    
    ArmorPlate(const LightBar&amp;amp; left, const LightBar&amp;amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
        
        // 根据宽高比判断类型
        float aspectRatio = width / height;
        if (aspectRatio &amp;gt; 3.0) {
            type = LARGE_ARMOR;  // 宽高比大，大装甲板
        } else {
            type = SMALL_ARMOR;  // 宽高比小，小装甲板
        }
    }
    
    std::string getTypeName() const {
        return (type == SMALL_ARMOR) ? &quot;Small&quot; : &quot;Large&quot;;
    }
};

// 绘制时显示类型
void drawArmorPlate(cv::Mat&amp;amp; image, const ArmorPlate&amp;amp; armor, int index) {
    // ... 原来的绘制代码 ...
    
    // 显示类型
    std::string typeInfo = armor.getTypeName();
    cv::Scalar color = (armor.type == SMALL_ARMOR) ? 
                       cv::Scalar(0, 255, 0) : cv::Scalar(255, 0, 255);
    cv::putText(image, typeInfo, 
                cv::Point(armor.center.x - 30, armor.center.y + 20),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;置信度评分系统&lt;/h3&gt;
&lt;p&gt;给每个装甲板打分，选出最佳目标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    float confidence;  // 置信度 0-100
    
    ArmorPlate(const LightBar&amp;amp; left, const LightBar&amp;amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
        
        // 计算置信度
        confidence = calculateConfidence(left, right);
    }
    
private:
    float calculateConfidence(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
        float score = 100.0;
        
        // 1. 角度差越小越好（满分20）
        float angle1 = normalizeAngle(bar1.angle);
        float angle2 = normalizeAngle(bar2.angle);
        float angleDiff = std::abs(angle1 - angle2);
        float angleScore = std::max(0.0f, 20.0f - angleDiff * 2.0f);
        
        // 2. 长度比越接近1越好（满分20）
        float lengthRatio = std::max(bar1.length, bar2.length) / 
                           std::min(bar1.length, bar2.length);
        float lengthScore = std::max(0.0f, 20.0f - (lengthRatio - 1.0f) * 10.0f);
        
        // 3. 高度差越小越好（满分20）
        float avgLength = (bar1.length + bar2.length) / 2;
        float heightDiff = std::abs(bar1.center.y - bar2.center.y);
        float heightScore = std::max(0.0f, 20.0f - heightDiff / avgLength * 40.0f);
        
        // 4. 距离合理性（满分20）
        float distance = cv::norm(bar1.center - bar2.center);
        float idealDist = avgLength * 2.5;  // 理想距离
        float distDiff = std::abs(distance - idealDist);
        float distScore = std::max(0.0f, 20.0f - distDiff / avgLength * 10.0f);
        
        // 5. 面积大小（满分20）- 面积越大越好
        float area = width * height;
        float areaScore = std::min(20.0f, area / 10000.0f * 20.0f);
        
        score = angleScore + lengthScore + heightScore + distScore + areaScore;
        return std::min(100.0f, score);
    }
};

// 选择最佳装甲板
ArmorPlate selectBestArmor(const std::vector&amp;lt;ArmorPlate&amp;gt;&amp;amp; armorPlates) {
    if (armorPlates.empty()) {
        throw std::runtime_error(&quot;没有装甲板可选择！&quot;);
    }
    
    // 找出置信度最高的装甲板
    auto bestArmor = std::max_element(armorPlates.begin(), armorPlates.end(),
        [](const ArmorPlate&amp;amp; a, const ArmorPlate&amp;amp; b) {
            return a.confidence &amp;lt; b.confidence;
        });
    
    std::cout &amp;lt;&amp;lt; &quot;最佳装甲板置信度: &quot; &amp;lt;&amp;lt; bestArmor-&amp;gt;confidence &amp;lt;&amp;lt; std::endl;
    return *bestArmor;
}

// 绘制时显示置信度
void drawArmorPlateWithConfidence(cv::Mat&amp;amp; image, const ArmorPlate&amp;amp; armor, int index) {
    // ... 原来的绘制代码 ...
    
    // 显示置信度
    std::string confInfo = &quot;Conf:&quot; + std::to_string((int)armor.confidence);
    cv::putText(image, confInfo, 
                cv::Point(armor.center.x - 30, armor.center.y + 20),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 0), 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;实战技巧&lt;/h2&gt;
&lt;h3&gt;动态参数调整&lt;/h3&gt;
&lt;p&gt;根据距离动态调整判据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bool isValidArmorPair_Dynamic(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2, 
                               float cameraDistance) {
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 根据相机距离调整参数
    float distanceMin, distanceMax, angleDiffMax;
    
    if (cameraDistance &amp;lt; 3.0) {  // 近距离（3米内）
        distanceMin = avgLength * 2.0;
        distanceMax = avgLength * 3.5;
        angleDiffMax = 5.0;
    } else {  // 远距离（3米外）
        distanceMin = avgLength * 1.5;
        distanceMax = avgLength * 4.5;
        angleDiffMax = 12.0;
    }
    
    float distance = cv::norm(bar1.center - bar2.center);
    if (distance &amp;lt; distanceMin || distance &amp;gt; distanceMax) {
        return false;
    }
    
    // ... 其他判据 ...
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;处理边界情况&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;bool isValidArmorPair_Robust(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    // 检查输入有效性
    if (bar1.length &amp;lt;= 0 || bar2.length &amp;lt;= 0) {
        std::cerr &amp;lt;&amp;lt; &quot;警告：灯条长度无效！&quot; &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    if (bar1.center == bar2.center) {
        std::cerr &amp;lt;&amp;lt; &quot;警告：两灯条中心重合！&quot; &amp;lt;&amp;lt; std::endl;
        return false;
    }
    
    // 避免除零错误
    float minLength = std::min(bar1.length, bar2.length);
    if (minLength &amp;lt; 1e-6) {
        return false;
    }
    
    // 正常判断流程...
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;帧稳定性检测&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class ArmorTracker {
private:
    std::vector&amp;lt;ArmorPlate&amp;gt; historyArmors;  // 历史帧的装甲板
    const int HISTORY_SIZE = 5;  // 保持最近5帧
    
public:
    // 添加新帧的装甲板
    void addFrame(const std::vector&amp;lt;ArmorPlate&amp;gt;&amp;amp; armors) {
        if (historyArmors.size() &amp;gt;= HISTORY_SIZE) {
            historyArmors.erase(historyArmors.begin());
        }
        historyArmors.insert(historyArmors.end(), armors.begin(), armors.end());
    }
    
    // 获取稳定的装甲板（连续出现多帧）
    std::vector&amp;lt;ArmorPlate&amp;gt; getStableArmors() {
        // 统计每个位置出现的次数
        std::vector&amp;lt;ArmorPlate&amp;gt; stableArmors;
        
        // 实际应该实现位置聚类和计数
        // 这里简化处理
        
        return stableArmors;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参数调优助手&lt;/h3&gt;
&lt;p&gt;创建滑动条实时调整参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 全局参数
int g_distanceMin = 15;  // 1.5 * 10
int g_distanceMax = 40;  // 4.0 * 10
int g_angleDiffMax = 10;
int g_lengthRatioMax = 20;  // 2.0 * 10
int g_heightDiffMax = 5;  // 0.5 * 10

void createParamWindow() {
    cv::namedWindow(&quot;参数调整&quot;);
    
    cv::createTrackbar(&quot;距离最小(x0.1)&quot;, &quot;参数调整&quot;, &amp;amp;g_distanceMin, 50);
    cv::createTrackbar(&quot;距离最大(x0.1)&quot;, &quot;参数调整&quot;, &amp;amp;g_distanceMax, 100);
    cv::createTrackbar(&quot;角度差最大&quot;, &quot;参数调整&quot;, &amp;amp;g_angleDiffMax, 30);
    cv::createTrackbar(&quot;长度比最大(x0.1)&quot;, &quot;参数调整&quot;, &amp;amp;g_lengthRatioMax, 50);
    cv::createTrackbar(&quot;高度差最大(x0.1)&quot;, &quot;参数调整&quot;, &amp;amp;g_heightDiffMax, 20);
}

bool isValidArmorPair_Tunable(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    
    // 使用全局参数
    float distanceMin = g_distanceMin / 10.0f * avgLength;
    float distanceMax = g_distanceMax / 10.0f * avgLength;
    
    if (distance &amp;lt; distanceMin || distance &amp;gt; distanceMax) {
        return false;
    }
    
    // ... 其他判据使用全局参数 ...
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;完整代码示例（可直接运行）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

// ========== 数据结构 ==========
struct LightBar {
    cv::RotatedRect rect;
    cv::Point2f center;
    float length;
    float angle;
    
    LightBar() : length(0), angle(0) {}
    
    LightBar(const cv::RotatedRect&amp;amp; r) : rect(r) {
        center = r.center;
        length = std::max(r.size.width, r.size.height);
        angle = r.angle;
        if (r.size.width &amp;gt; r.size.height) {
            angle += 90;
        }
    }
};

struct ArmorPlate {
    LightBar leftBar;
    LightBar rightBar;
    cv::Point2f center;
    float width;
    float height;
    
    ArmorPlate(const LightBar&amp;amp; left, const LightBar&amp;amp; right) 
        : leftBar(left), rightBar(right) {
        center.x = (left.center.x + right.center.x) / 2;
        center.y = (left.center.y + right.center.y) / 2;
        width = cv::norm(left.center - right.center);
        height = (left.length + right.length) / 2;
    }
};

// ========== 工具函数 ==========
float normalizeAngle(float angle) {
    angle = std::abs(angle);
    if (angle &amp;gt; 90) {
        angle = 180 - angle;
    }
    return angle;
}

// ========== 核心判断 ==========
bool isValidArmorPair(const LightBar&amp;amp; bar1, const LightBar&amp;amp; bar2) {
    // 判据1：距离
    float distance = cv::norm(bar1.center - bar2.center);
    float avgLength = (bar1.length + bar2.length) / 2;
    if (distance &amp;lt; avgLength * 1.5 || distance &amp;gt; avgLength * 4.0) {
        return false;
    }
    
    // 判据2：角度
    float angle1 = normalizeAngle(bar1.angle);
    float angle2 = normalizeAngle(bar2.angle);
    float angleDiff = std::abs(angle1 - angle2);
    if (angleDiff &amp;gt; 10.0) {
        return false;
    }
    
    // 判据3：长度比
    float lengthRatio = std::max(bar1.length, bar2.length) / 
                        std::min(bar1.length, bar2.length);
    if (lengthRatio &amp;gt; 2.0) {
        return false;
    }
    
    // 判据4：高度差
    float heightDiff = std::abs(bar1.center.y - bar2.center.y);
    if (heightDiff &amp;gt; avgLength * 0.5) {
        return false;
    }
    
    return true;
}

// ========== 配对函数 ==========
std::vector&amp;lt;ArmorPlate&amp;gt; findArmorPlates(const std::vector&amp;lt;LightBar&amp;gt;&amp;amp; lightBars) {
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates;
    
    for (size_t i = 0; i &amp;lt; lightBars.size(); i++) {
        for (size_t j = i + 1; j &amp;lt; lightBars.size(); j++) {
            if (isValidArmorPair(lightBars[i], lightBars[j])) {
                if (lightBars[i].center.x &amp;lt; lightBars[j].center.x) {
                    armorPlates.emplace_back(lightBars[i], lightBars[j]);
                } else {
                    armorPlates.emplace_back(lightBars[j], lightBars[i]);
                }
            }
        }
    }
    
    return armorPlates;
}

// ========== 可视化 ==========
void drawArmorPlate(cv::Mat&amp;amp; image, const ArmorPlate&amp;amp; armor, int index) {
    // 绘制左侧灯条
    cv::Point2f v1[4];
    armor.leftBar.rect.points(v1);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(image, v1[i], v1[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制右侧灯条
    cv::Point2f v2[4];
    armor.rightBar.rect.points(v2);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(image, v2[i], v2[(i+1)%4], cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制连接线
    cv::line(image, armor.leftBar.center, armor.rightBar.center, 
             cv::Scalar(0, 255, 255), 2);
    
    // 绘制中心点
    cv::circle(image, armor.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 显示信息
    std::string info = &quot;Armor#&quot; + std::to_string(index);
    cv::putText(image, info, 
                cv::Point(armor.center.x - 30, armor.center.y - 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.6, 
                cv::Scalar(255, 255, 255), 2);
}

// ========== 主函数 ==========
int main() {
    // 读取图片
    cv::Mat src = cv::imread(&quot;armor_test.jpg&quot;);
    if (src.empty()) {
        std::cerr &amp;lt;&amp;lt; &quot;无法读取图片！&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // 这里需要调用之前的灯条检测函数
    // std::vector&amp;lt;LightBar&amp;gt; lightBars = detectLightBars(src);
    
    // 示例：手动创建测试数据
    std::vector&amp;lt;LightBar&amp;gt; lightBars;
    // TODO: 添加测试灯条
    
    // 装甲板配对
    std::vector&amp;lt;ArmorPlate&amp;gt; armorPlates = findArmorPlates(lightBars);
    
    // 绘制结果
    cv::Mat result = src.clone();
    for (size_t i = 0; i &amp;lt; armorPlates.size(); i++) {
        drawArmorPlate(result, armorPlates[i], i);
    }
    
    // 显示
    std::cout &amp;lt;&amp;lt; &quot;检测到 &quot; &amp;lt;&amp;lt; armorPlates.size() &amp;lt;&amp;lt; &quot; 个装甲板&quot; &amp;lt;&amp;lt; std::endl;
    cv::imshow(&quot;结果&quot;, result);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>RM装甲板识别 - 03 形态学处理</title><link>https://www.nanye404.top/posts/rm_opencv_03/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_03/</guid><description>无</description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;本阶段核心API清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::getStructuringElement()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建形态学核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::dilate()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;膨胀（变胖）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::erode()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;腐蚀（变瘦）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::morphologyEx()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高级形态学&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;核心思路&lt;/h2&gt;
&lt;p&gt;颜色提取后的二值图有两个主要问题：&lt;/p&gt;
&lt;h3&gt;问题1: 噪点（小白点到处都是）&lt;/h3&gt;
&lt;h3&gt;问题2: 断裂（灯条中间有缝隙）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;形态学操作就是解决这些问题的工具！&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;形态学四种处理方式&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;比喻&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;膨胀 dilate&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;白色区域变大&lt;/td&gt;
&lt;td&gt;涂胖笔&lt;/td&gt;
&lt;td&gt;连接断裂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;腐蚀 erode&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;白色区域变小&lt;/td&gt;
&lt;td&gt;橡皮擦&lt;/td&gt;
&lt;td&gt;去除噪点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;开运算 open&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;先腐蚀后膨胀&lt;/td&gt;
&lt;td&gt;先擦后涂&lt;/td&gt;
&lt;td&gt;去噪保形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;闭运算 close&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;先膨胀后腐蚀&lt;/td&gt;
&lt;td&gt;先涂后擦&lt;/td&gt;
&lt;td&gt;填缝保形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::getStructuringElement() - 创建形态学核&lt;/h2&gt;
&lt;h3&gt;核形状类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shape&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_RECT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;矩形（最常用）&lt;/td&gt;
&lt;td&gt;各方向均匀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_ELLIPSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;椭圆形&lt;/td&gt;
&lt;td&gt;边缘更圆滑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_CROSS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;十字形&lt;/td&gt;
&lt;td&gt;只作用于上下左右&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 创建3×3矩形核
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
// 创建5×5椭圆核
cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
// 创建7×7十字核
cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(7, 7));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;核大小如何选择？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;尺寸&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3×3&lt;/td&gt;
&lt;td&gt;轻微处理&lt;/td&gt;
&lt;td&gt;小噪点、细微缝隙&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5×5&lt;/td&gt;
&lt;td&gt;中等效果&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;推荐&lt;/strong&gt;，平衡效果和性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7×7&lt;/td&gt;
&lt;td&gt;强力效果&lt;/td&gt;
&lt;td&gt;大噪点、大缝隙（可能破坏灯条形状）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9×9+&lt;/td&gt;
&lt;td&gt;极强效果&lt;/td&gt;
&lt;td&gt;慎用！容易把灯条变形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;2. cv::dilate() - 膨胀操作&lt;/h2&gt;
&lt;h3&gt;函数原型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::dilate(InputArray src, OutputArray dst, InputArray kernel,
                Point anchor = Point(-1,-1), int iterations = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;  输入二值图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dst&lt;/code&gt;  输出结果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kernel&lt;/code&gt;  形态学核&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anchor&lt;/code&gt;  锚点位置（-1,-1表示中心）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterations&lt;/code&gt;  迭代次数（重复膨胀几次）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 腐蚀一次
cv::Mat eroded;
cv::erode(binary, eroded, kernel);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;去除小噪点&lt;/li&gt;
&lt;li&gt;分离粘连物体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;腐蚀的副作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;灯条也会变细&lt;/li&gt;
&lt;li&gt;解决方案：腐蚀后再膨胀回来（开运算）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::morphologyEx() - 高级形态学操作&lt;/h2&gt;
&lt;h3&gt;操作类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;op&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;公式&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_OPEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开运算&lt;/td&gt;
&lt;td&gt;erode → dilate&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;去噪保形&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_CLOSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;闭运算&lt;/td&gt;
&lt;td&gt;dilate → erode&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;填缝保形&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_GRADIENT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;形态学梯度&lt;/td&gt;
&lt;td&gt;dilate - erode&lt;/td&gt;
&lt;td&gt;提取边缘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_TOPHAT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;顶帽&lt;/td&gt;
&lt;td&gt;src - open&lt;/td&gt;
&lt;td&gt;提取小亮点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_BLACKHAT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;黑帽&lt;/td&gt;
&lt;td&gt;close - src&lt;/td&gt;
&lt;td&gt;提取小暗点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;5. 闭运算 (MORPH_CLOSE)&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
// 闭运算
cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连接灯条的细微断裂&lt;/li&gt;
&lt;li&gt;填补灯条内部的小黑洞&lt;/li&gt;
&lt;li&gt;保持灯条的整体形状&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 核太大会让两个灯条粘在一起！
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
//  可能导致左右灯条合并

// 推荐使用5×5或7×7
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. 开运算 (MORPH_OPEN) - 去噪利器&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// 开运算
cv::Mat opened;
cv::morphologyEx(binary, opened, cv::MORPH_OPEN, kernel);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;去除小噪点&lt;/li&gt;
&lt;li&gt;分离轻微粘连的物体&lt;/li&gt;
&lt;li&gt;平滑物体边缘&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;7. RM装甲板识别推荐流程&lt;/h2&gt;
&lt;h3&gt;标准流程（两步法）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat processArmor(const cv::Mat&amp;amp; img) {
    // 1. 颜色提取
    cv::Mat binary = extractColor(img); 
    // 2. 形态学处理
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    // 第一步：闭运算（填补灯条缝隙）
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    // 第二步：开运算（去除噪点）
    cv::Mat result;
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;8. 形态学梯度 (MORPH_GRADIENT)&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat gradient;
cv::morphologyEx(binary, gradient, cv::MORPH_GRADIENT, kernel);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;效果&lt;/h3&gt;
&lt;p&gt;提取物体的&lt;strong&gt;外轮廓线&lt;/strong&gt;，类似边缘检测&lt;/p&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;能量机关扇叶边缘检测&lt;/li&gt;
&lt;li&gt;装甲板外框提取（不常用）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;完整实战代码&lt;/h2&gt;
&lt;h3&gt;方案1: 快速版（单次操作）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学核
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 闭运算（最常用）
    cv::Mat result;
    cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
    
    // 显示对比
    cv::imshow(&quot;原始二值图&quot;, binary);
    cv::imshow(&quot;形态学处理后&quot;, result);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方案2: 标准版（两步法）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat morphologyProcess(const cv::Mat&amp;amp; binary) {
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // 第一步：闭运算填缝
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // 第二步：开运算去噪
    cv::Mat opened;
    cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
    
    return opened;
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    cv::Mat binary = extractColor(img);
    
    cv::Mat result = morphologyProcess(binary);
    
    // 显示三步对比
    cv::imshow(&quot;1-原始&quot;, binary);
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, 
                     cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5)));
    cv::imshow(&quot;2-闭运算&quot;, closed);
    cv::imshow(&quot;3-最终结果&quot;, result);
    
    cv::waitKey(0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方案3: 自适应版（根据图像大小调整核）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat adaptiveMorphology(const cv::Mat&amp;amp; binary) {
    // 根据图像大小自适应核尺寸
    int kernelSize = std::max(3, (int)(binary.cols * 0.005));
    if (kernelSize % 2 == 0) kernelSize++;  // 确保是奇数
    
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                               cv::Size(kernelSize, kernelSize));
    
    cv::Mat closed, result;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    std::cout &amp;lt;&amp;lt; &quot;使用核尺寸: &quot; &amp;lt;&amp;lt; kernelSize &amp;lt;&amp;lt; &quot;×&quot; &amp;lt;&amp;lt; kernelSize &amp;lt;&amp;lt; std::endl;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RM装甲板识别 - 02 装甲板颜色提取</title><link>https://www.nanye404.top/posts/rm_opencv_02/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_02/</guid><description>无</description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;本阶段核心API清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::split()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;分离BGR通道&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::cvtColor()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;颜色空间转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::inRange()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;颜色范围筛选&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::threshold()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单阈值二值化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::subtract()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通道相减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::bitwise_or/and()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;位运算组合mask&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;核心思路&lt;/h2&gt;
&lt;p&gt;装甲板的灯条有两个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;特定颜色&lt;/strong&gt;（红色或蓝色）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高亮度&lt;/strong&gt;（灯条是发光的）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;通道相减法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;: BGR图像中，红色区域R通道值高、B通道值低，相减后红色凸显&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;: 速度极快（1-2ms），实时性好&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;: 易受环境光干扰，需要后续强筛选&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用&lt;/strong&gt;: 比赛实战、光照稳定环境&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HSV筛选法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;: HSV分离了颜色和亮度，可精确筛选颜色范围&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;: 抗干扰能力强，准确度高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;: 速度较慢（5-10ms），参数需调优&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用&lt;/strong&gt;: 复杂光照、高精度需求&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::split() - 分离BGR通道&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    // 分离通道
    std::vector&amp;lt;cv::Mat&amp;gt; channels;
    cv::split(img, channels);    
    // 现在：
    // channels[0] = B通道（蓝色分量）
    // channels[1] = G通道（绿色分量）
    // channels[2] = R通道（红色分量）  
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;2. 通道相减法&lt;/h2&gt;
&lt;h3&gt;提取红色&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);
// 分离通道
std::vector&amp;lt;cv::Mat&amp;gt; channels;
cv::split(img, channels);
// 红色 = R通道 - B通道
cv::Mat red;
cv::subtract(channels[2], channels[0], red);
// 二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// 查看效果

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;提取蓝色&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 蓝色 = B通道 - R通道
cv::Mat blue;
cv::subtract(channels[0], channels[2], blue);

cv::Mat binary_blue;
cv::threshold(blue, binary_blue, 100, 255, cv::THRESH_BINARY);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::cvtColor() - 颜色空间转换&lt;/h2&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;常用转换代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COLOR_BGR2GRAY&lt;/code&gt;  BGR转灰度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COLOR_BGR2HSV&lt;/code&gt;  BGR转HSV&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COLOR_BGR2RGB&lt;/code&gt; BGR转RGB&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COLOR_HSV2BGR&lt;/code&gt;  HSV转回BGR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HSV颜色空间详解&lt;/h3&gt;
&lt;p&gt;HSV把颜色分解为3个维度：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;H (色调 Hue): 0-180
├─ 0-10:    红色(第一段)
├─ 100-124: 蓝色  装甲板蓝色
└─ 170-180: 红色(第二段) 装甲板红色

S (饱和度 Saturation): 0-255
└─ 100-255: 鲜艳色 灯条在这里

V (明度 Value): 0-255
└─ 100-255: 明亮 灯条在这里
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BGR转HSV&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::inRange() - 颜色范围筛选&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;  输入图像（通常是HSV）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lowerb&lt;/code&gt;  下界（Scalar(H_min, S_min, V_min)）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;upperb&lt;/code&gt;  上界（Scalar(H_max, S_max, V_max)）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dst&lt;/code&gt;  输出二值图（在范围内=255，否则=0）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;提取红色（完整版）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// 红色的H值跨越了0-180的边界！需要分两段
// 第一段: H=0-10
cv::Scalar lower_red1(0, 100, 100);    // (H, S, V)
cv::Scalar upper_red1(10, 255, 255);

// 第二段: H=170-180
cv::Scalar lower_red2(170, 100, 100);
cv::Scalar upper_red2(180, 255, 255);

// 分别提取两段
cv::Mat mask1, mask2, red_mask;
cv::inRange(hsv, lower_red1, upper_red1, mask1);
cv::inRange(hsv, lower_red2, upper_red2, mask2);

// 合并两段（位运算：或）
cv::bitwise_or(mask1, mask2, red_mask);

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;提取蓝色&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 蓝色只需要一段
cv::Scalar lower_blue(100, 100, 100);  // H=100-130
cv::Scalar upper_blue(130, 255, 255);

cv::Mat blue_mask;
cv::inRange(hsv, lower_blue, upper_blue, blue_mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;参数调优技巧&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建滑块实时调参&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

// 全局变量
int h_min = 0, h_max = 10;
int s_min = 100, s_max = 255;
int v_min = 100, v_max = 255;

void on_trackbar(int, void*) {
    // 回调函数，每次滑块变化时调用
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 创建窗口
    cv::namedWindow(&quot;调参&quot;);
    
    // 创建滑块
    cv::createTrackbar(&quot;H min&quot;, &quot;调参&quot;, &amp;amp;h_min, 180, on_trackbar);
    cv::createTrackbar(&quot;H max&quot;, &quot;调参&quot;, &amp;amp;h_max, 180, on_trackbar);
    cv::createTrackbar(&quot;S min&quot;, &quot;调参&quot;, &amp;amp;s_min, 255, on_trackbar);
    cv::createTrackbar(&quot;S max&quot;, &quot;调参&quot;, &amp;amp;s_max, 255, on_trackbar);
    cv::createTrackbar(&quot;V min&quot;, &quot;调参&quot;, &amp;amp;v_min, 255, on_trackbar);
    cv::createTrackbar(&quot;V max&quot;, &quot;调参&quot;, &amp;amp;v_max, 255, on_trackbar);
    
    while (true) {
        cv::Scalar lower(h_min, s_min, v_min);
        cv::Scalar upper(h_max, s_max, v_max);
        
        cv::Mat mask;
        cv::inRange(hsv, lower, upper, mask);
        
        cv::imshow(&quot;原图&quot;, img);
        cv::imshow(&quot;mask&quot;, mask);
        
        if (cv::waitKey(30) == 27) break;
    }
    
    // 打印最终参数
    std::cout &amp;lt;&amp;lt; &quot;最优参数:&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;lower: (&quot; &amp;lt;&amp;lt; h_min &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; s_min &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; v_min &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;upper: (&quot; &amp;lt;&amp;lt; h_max &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; s_max &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; v_max &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::threshold() - 简单阈值二值化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;THRESH_BINARY&lt;/code&gt; | 标准二值化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;THRESH_BINARY_INV&lt;/code&gt; | 反向二值化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;THRESH_TRUNC&lt;/code&gt; | 截断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;THRESH_TOZERO&lt;/code&gt; | 低于阈值归零&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;配合通道相减使用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 提取红色
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// 阈值二值化
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// 像素 &amp;gt; 100 → 255(白)
// 像素 &amp;lt;= 100 → 0(黑)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自适应阈值（应对光照不均）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

cv::Mat adaptive;
cv::adaptiveThreshold(gray, adaptive, 255,
                      cv::ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv::THRESH_BINARY, 11, 2);
// blockSize=11: 邻域大小
// C=2: 常数调整值
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. cv::bitwise 位运算&lt;/h2&gt;
&lt;h3&gt;常用函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_not(InputArray src, OutputArray dst);
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并多个mask&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 红色有两段，需要合并
cv::Mat red_mask1, red_mask2, red_final;
cv::inRange(hsv, lower_red1, upper_red1, red_mask1);
cv::inRange(hsv, lower_red2, upper_red2, red_mask2);
cv::bitwise_or(red_mask1, red_mask2, red_final);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;提取同时满足多个条件的区域&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 同时是红色 且 亮度很高
cv::Mat color_mask, brightness_mask, final_mask;
cv::inRange(hsv, lower_red, upper_red, color_mask);
cv::threshold(hsv_channels[2], brightness_mask, 200, 255, cv::THRESH_BINARY);
cv::bitwise_and(color_mask, brightness_mask, final_mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;反转mask&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat mask, inverted;
cv::inRange(hsv, lower, upper, mask);
cv::bitwise_not(mask, inverted);  // 黑白反转
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;完整实战代码&lt;/h2&gt;
&lt;h3&gt;方案1: 通道相减法（快速）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat extractRedFast(const cv::Mat&amp;amp; img) {
    std::vector&amp;lt;cv::Mat&amp;gt; channels;
    cv::split(img, channels);
    
    // R - B
    cv::Mat red;
    cv::subtract(channels[2], channels[0], red);
    
    // 二值化
    cv::Mat binary;
    cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
    
    return binary;
}

int main() {
    cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);
    cv::Mat binary = extractRedFast(img);
    
    cv::imshow(&quot;原图&quot;, img);
    cv::imshow(&quot;红色提取&quot;, binary);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方案2: HSV筛选法（精确）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat extractRedAccurate(const cv::Mat&amp;amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // 红色两段
    cv::Scalar lower1(0, 100, 100);
    cv::Scalar upper1(10, 255, 255);
    cv::Scalar lower2(170, 100, 100);
    cv::Scalar upper2(180, 255, 255);
    
    cv::Mat mask1, mask2, mask;
    cv::inRange(hsv, lower1, upper1, mask1);
    cv::inRange(hsv, lower2, upper2, mask2);
    cv::bitwise_or(mask1, mask2, mask);
    
    return mask;
}

cv::Mat extractBlue(const cv::Mat&amp;amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    cv::Scalar lower(100, 100, 100);
    cv::Scalar upper(130, 255, 255);
    
    cv::Mat mask;
    cv::inRange(hsv, lower, upper, mask);
    
    return mask;
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    cv::Mat red_mask = extractRedAccurate(img);
    cv::Mat blue_mask = extractBlue(img);
    
    cv::imshow(&quot;原图&quot;, img);
    cv::imshow(&quot;红色mask&quot;, red_mask);
    cv::imshow(&quot;蓝色mask&quot;, blue_mask);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RM装甲板识别 - 04 轮廓检测</title><link>https://www.nanye404.top/posts/rm_opencv_04/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_04/</guid><description>无</description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;本阶段核心API清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::findContours()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找轮廓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::contourArea()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算轮廓面积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::minAreaRect()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最小旋转矩形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::RotatedRect&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;旋转矩形类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::drawContours()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;绘制轮廓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::boundingRect()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正矩形包围框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::fitEllipse()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;椭圆拟合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;核心思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;经过形态学处理后，二值图已经很干净：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在要做的是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;找轮廓&lt;/strong&gt; - 把每个白色区域的边界找出来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拟合矩形&lt;/strong&gt; - 用旋转矩形描述每个轮廓&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;筛选灯条&lt;/strong&gt; - 根据长宽比、面积、角度等特征过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::findContours() - 查找轮廓&lt;/h2&gt;
&lt;h3&gt;参数详解&lt;/h3&gt;
&lt;h4&gt;mode - 轮廓检索模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;mode&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_EXTERNAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只检测最外层轮廓&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RM推荐&lt;/strong&gt;，忽略内部孔洞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;检测所有轮廓，不建立层级&lt;/td&gt;
&lt;td&gt;当需要所有轮廓时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_TREE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;检测所有并建立完整层级树&lt;/td&gt;
&lt;td&gt;复杂嵌套结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_CCOMP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;两层层级（外轮廓和孔）&lt;/td&gt;
&lt;td&gt;较少使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;method - 轮廓近似方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;优缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CHAIN_APPROX_NONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存所有轮廓点&lt;/td&gt;
&lt;td&gt;精确但占内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CHAIN_APPROX_SIMPLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;压缩轮廓，只保留关键点&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RM推荐&lt;/strong&gt;，节省内存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    // 获取二值图（假设已实现）
    cv::Mat binary = processImage(img);
    
    // 查找轮廓
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, 
                     cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &amp;lt;&amp;lt; &quot;找到 &quot; &amp;lt;&amp;lt; contours.size() &amp;lt;&amp;lt; &quot; 个轮廓&quot; &amp;lt;&amp;lt; std::endl;
    
    // 遍历所有轮廓
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        std::cout &amp;lt;&amp;lt; &quot;轮廓 &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; 有 &quot; &amp;lt;&amp;lt; contours[i].size() 
                  &amp;lt;&amp;lt; &quot; 个点&quot; &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重要注意事项&lt;/h3&gt;
&lt;h4&gt;注意1: findContours会修改输入图像！&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
//  正确：传入副本
cv::Mat binary_copy = binary.clone();
cv::findContours(binary_copy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 或者直接在临时对象上调用
cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注意2: 输入必须是二值图&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//  错误：彩色图不行
cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
cv::findContours(img, contours, ...);  //  结果不对

//  正确：必须是二值图（0或255）
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
cv::findContours(binary, contours, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;2. 轮廓数据结构理解&lt;/h2&gt;
&lt;h3&gt;轮廓的本质&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 轮廓 = 点的集合
std::vector&amp;lt;cv::Point&amp;gt; contour = contours[0];

// 每个点是(x, y)坐标
cv::Point p = contour[0];
std::cout &amp;lt;&amp;lt; &quot;第一个点: (&quot; &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;轮廓操作示例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 轮廓数量
int num = contours.size();

// 第i个轮廓的点数
int pointCount = contours[i].size();

// 访问第i个轮廓的第j个点
cv::Point p = contours[i][j];
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::contourArea() - 计算轮廓面积&lt;/h2&gt;
&lt;h3&gt;函数原型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;double cv::contourArea(InputArray contour, bool oriented = false);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    std::cout &amp;lt;&amp;lt; &quot;轮廓面积: &quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot; 像素&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;用于过滤噪点&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; validContours;

for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    
    // 过滤太小的轮廓（噪点）
    if (area &amp;lt; 100) continue;
    
    // 过滤太大的轮廓（可能是整个装甲板或背景）
    if (area &amp;gt; 10000) continue;
    
    // 保留合理大小的轮廓
    validContours.push_back(contour);
}

std::cout &amp;lt;&amp;lt; &quot;过滤后剩余 &quot; &amp;lt;&amp;lt; validContours.size() &amp;lt;&amp;lt; &quot; 个轮廓&quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;面积阈值如何选择？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;推荐方法&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据图像大小自适应
int imageArea = binary.rows * binary.cols;
double minArea = imageArea * 0.0001;  // 0.01%
double maxArea = imageArea * 0.05;    // 5%

for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    if (area &amp;gt; minArea &amp;amp;&amp;amp; area &amp;lt; maxArea) {
        // 合理范围
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::minAreaRect() - 最小旋转矩形&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    // 拟合最小旋转矩形
    cv::RotatedRect rect = cv::minAreaRect(contour);
    
    // 获取矩形信息
    cv::Point2f center = rect.center;      // 中心点
    cv::Size2f size = rect.size;           // 尺寸(width, height)
    float angle = rect.angle;              // 旋转角度(-90到0)
    
    std::cout &amp;lt;&amp;lt; &quot;中心: (&quot; &amp;lt;&amp;lt; center.x &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; center.y &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;尺寸: &quot; &amp;lt;&amp;lt; size.width &amp;lt;&amp;lt; &quot; × &quot; &amp;lt;&amp;lt; size.height &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;角度: &quot; &amp;lt;&amp;lt; angle &amp;lt;&amp;lt; &quot;°&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::RotatedRect 类详解&lt;/h2&gt;
&lt;h3&gt;核心属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

// 中心点
cv::Point2f center = rect.center;  // 矩形中心的(x,y)坐标

// 尺寸
cv::Size2f size = rect.size;       // width × height
float width = size.width;
float height = size.height;

// 旋转角度
float angle = rect.angle;          // 范围: -90° ~ 0°
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;angle的陷阱&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OpenCV的angle定义很反直觉！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// angle的含义：
// 从水平方向逆时针旋转到矩形长边的角度
// 范围：-90° 到 0°
// 例子：
angle = -90°  → 矩形垂直（竖着）
angle = -45°  → 矩形倾斜45度
angle = 0°    → 矩形水平（横着）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;确保height是长边&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

float width = rect.size.width;
float height = rect.size.height;

//  OpenCV不保证height &amp;gt; width！
// 需要手动调整
if (width &amp;gt; height) {
    std::swap(width, height);
    // 如果需要，也可以调整angle
}

// 现在 height 一定是长边
float aspectRatio = height / width;  // 长宽比
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取四个顶点坐标&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

// 获取四个顶点
cv::Point2f vertices[4];
rect.points(vertices);

// vertices[0], vertices[1], vertices[2], vertices[3]
// 按逆时针顺序排列

// 绘制旋转矩形
for (int i = 0; i &amp;lt; 4; i++) {
    cv::line(img, vertices[i], vertices[(i+1)%4], 
             cv::Scalar(0, 255, 0), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. 灯条特征筛选（核心）&lt;/h2&gt;
&lt;h3&gt;灯条的典型特征&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;合理范围&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;长宽比&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2.0 ~ 10.0&lt;/td&gt;
&lt;td&gt;灯条是细长的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;面积&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;100 ~ 5000像素&lt;/td&gt;
&lt;td&gt;根据分辨率调整&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;角度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;接近垂直&lt;/td&gt;
&lt;td&gt;通常在±30°内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;填充度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;gt; 0.5&lt;/td&gt;
&lt;td&gt;轮廓面积/外接矩形面积&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;完整筛选代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    float angle;
};

std::vector&amp;lt;LightBar&amp;gt; detectLightBars(const cv::Mat&amp;amp; binary) {
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::vector&amp;lt;LightBar&amp;gt; lightBars;
    
    for (const auto&amp;amp; contour : contours) {
        // 1. 面积筛选
        double area = cv::contourArea(contour);
        if (area &amp;lt; 100 || area &amp;gt; 5000) continue;
        
        // 2. 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 3. 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &amp;gt; height) {
            std::swap(width, height);
        }
        
        // 4. 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &amp;lt; 2.0 || aspectRatio &amp;gt; 10.0) continue;
        
        // 5. 角度筛选（可选，根据实际情况）
        // 灯条应该接近垂直
        float angle = std::abs(rect.angle);
        if (angle &amp;gt; 30 &amp;amp;&amp;amp; angle &amp;lt; 60) continue;  // 太斜的排除
        
        // 6. 填充度筛选（可选）
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &amp;lt; 0.5) continue;  // 太空的不是灯条
        
        // 通过所有筛选，保存
        LightBar bar;
        bar.rect = rect;
        bar.area = area;
        bar.aspectRatio = aspectRatio;
        bar.angle = angle;
        lightBars.push_back(bar);
    }
    
    std::cout &amp;lt;&amp;lt; &quot;找到 &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; &quot; 个灯条&quot; &amp;lt;&amp;lt; std::endl;
    return lightBars;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;7. cv::drawContours() - 绘制轮廓（调试）&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat display = img.clone();

// 绘制所有轮廓
cv::drawContours(display, contours, -1, cv::Scalar(0, 255, 0), 2);
// -1 表示绘制所有轮廓

// 绘制第i个轮廓
cv::drawContours(display, contours, i, cv::Scalar(255, 0, 0), 2);

// 填充轮廓
cv::drawContours(display, contours, i, cv::Scalar(0, 0, 255), -1);
// thickness=-1 表示填充
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;彩色调试可视化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void visualizeContours(const cv::Mat&amp;amp; img, 
                       const std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt;&amp;amp; contours) {
    cv::Mat display = img.clone();
    
    // 为每个轮廓随机颜色
    cv::RNG rng(12345);
    
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        cv::Scalar color(rng.uniform(0, 256), 
                        rng.uniform(0, 256), 
                        rng.uniform(0, 256));
        
        // 绘制轮廓
        cv::drawContours(display, contours, i, color, 2);
        
        // 标注序号
        cv::Moments m = cv::moments(contours[i]);
        cv::Point2f center(m.m10/m.m00, m.m01/m.m00);
        cv::putText(display, std::to_string(i), center,
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
    }
    
    cv::imshow(&quot;轮廓可视化&quot;, display);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;8. 绘制旋转矩形&lt;/h2&gt;
&lt;h3&gt;标准方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawRotatedRect(cv::Mat&amp;amp; img, const cv::RotatedRect&amp;amp; rect, 
                     const cv::Scalar&amp;amp; color, int thickness = 2) {
    cv::Point2f vertices[4];
    rect.points(vertices);
    
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], color, thickness);
    }
}

// 使用
for (const auto&amp;amp; bar : lightBars) {
    drawRotatedRect(display, bar.rect, cv::Scalar(0, 255, 0), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;增强版（带中心点和文字）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawLightBar(cv::Mat&amp;amp; img, const LightBar&amp;amp; bar, int id) {
    // 绘制旋转矩形
    cv::Point2f vertices[4];
    bar.rect.points(vertices);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // 绘制中心点
    cv::circle(img, bar.rect.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // 标注信息
    std::string text = &quot;ID:&quot; + std::to_string(id) + 
                       &quot; R:&quot; + std::to_string((int)bar.aspectRatio);
    cv::putText(img, text, 
                cv::Point(bar.rect.center.x + 10, bar.rect.center.y),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 255), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;10. cv::fitEllipse() - 椭圆拟合（能量机关用）&lt;/h2&gt;
&lt;h3&gt;函数原型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RotatedRect cv::fitEllipse(InputArray points);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    // 至少需要5个点
    if (contour.size() &amp;lt; 5) continue;
    
    // 拟合椭圆
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 绘制椭圆
    cv::ellipse(img, ellipse, cv::Scalar(0, 255, 255), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;能量机关扇叶识别&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 能量机关的R标是椭圆形
bool isEnergyRune(const std::vector&amp;lt;cv::Point&amp;gt;&amp;amp; contour) {
    if (contour.size() &amp;lt; 5) return false;
    
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // 椭圆的长短轴比应该接近1（近似圆形）
    float ratio = ellipse.size.width / ellipse.size.height;
    if (ratio &amp;lt; 0.8 || ratio &amp;gt; 1.2) return false;
    
    // 面积合理
    double area = CV_PI * ellipse.size.width/2 * ellipse.size.height/2;
    if (area &amp;lt; 500 || area &amp;gt; 3000) return false;
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;完整实战代码&lt;/h2&gt;
&lt;h3&gt;完整的灯条检测系统&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

// 灯条结构体
struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    
    LightBar(const cv::RotatedRect&amp;amp; r, double a, float ar)
        : rect(r), area(a), aspectRatio(ar) {}
};

// 灯条检测函数
std::vector&amp;lt;LightBar&amp;gt; detectLightBars(const cv::Mat&amp;amp; binary, 
                                      const cv::Mat&amp;amp; display) {
    // 1. 查找轮廓
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &amp;lt;&amp;lt; &quot;总轮廓数: &quot; &amp;lt;&amp;lt; contours.size() &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;LightBar&amp;gt; lightBars;
    
    // 2. 遍历筛选
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        const auto&amp;amp; contour = contours[i];
        
        // 面积筛选
        double area = cv::contourArea(contour);
        if (area &amp;lt; 100) {
            std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: 面积=&quot; &amp;lt;&amp;lt; area 
                      &amp;lt;&amp;lt; &quot;  太小&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        if (area &amp;gt; 5000) {
            std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: 面积=&quot; &amp;lt;&amp;lt; area 
                      &amp;lt;&amp;lt; &quot; 太大&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // 拟合旋转矩形
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 确保height是长边
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &amp;gt; height) {
            std::swap(width, height);
        }
        
        // 长宽比筛选
        float aspectRatio = height / width;
        if (aspectRatio &amp;lt; 2.0) {
            std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: 长宽比=&quot; &amp;lt;&amp;lt; aspectRatio 
                      &amp;lt;&amp;lt; &quot; 太矮&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        if (aspectRatio &amp;gt; 10.0) {
            std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: 长宽比=&quot; &amp;lt;&amp;lt; aspectRatio 
                      &amp;lt;&amp;lt; &quot;太细&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // 填充度筛选
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &amp;lt; 0.5) {
            std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: 填充度=&quot; &amp;lt;&amp;lt; fillRatio 
                      &amp;lt;&amp;lt; &quot;  太空&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // 通过筛选！
        std::cout &amp;lt;&amp;lt; &quot;轮廓&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;:  灯条候选&quot; &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; &quot;    面积=&quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot;, 长宽比=&quot; &amp;lt;&amp;lt; aspectRatio 
                  &amp;lt;&amp;lt; &quot;, 填充度=&quot; &amp;lt;&amp;lt; fillRatio &amp;lt;&amp;lt; std::endl;
        
        lightBars.emplace_back(rect, area, aspectRatio);
        
        // 绘制（调试用）
        if (!display.empty()) {
            cv::Point2f vertices[4];
            rect.points(vertices);
            for (int j = 0; j &amp;lt; 4; j++) {
                cv::line(display, vertices[j], vertices[(j+1)%4],
                         cv::Scalar(0, 255, 0), 2);
            }
            cv::circle(display, rect.center, 5, cv::Scalar(0, 0, 255), -1);
        }
    }
    
    std::cout &amp;lt;&amp;lt; &quot;\n最终找到 &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; &quot; 个灯条&quot; &amp;lt;&amp;lt; std::endl;
    return lightBars;
}

int main() {
    // 读取图像
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    if (img.empty()) {
        std::cerr &amp;lt;&amp;lt; &quot;无法读取图像&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // 颜色提取（假设已实现）
    cv::Mat binary = extractRedColor(img);
    
    // 形态学处理（假设已实现）
    binary = morphologyProcess(binary);
    
    // 灯条检测
    cv::Mat display = img.clone();
    std::vector&amp;lt;LightBar&amp;gt; lightBars = detectLightBars(binary, display);
    
    // 显示结果
    cv::imshow(&quot;原图&quot;, img);
    cv::imshow(&quot;二值图&quot;, binary);
    cv::imshow(&quot;检测结果&quot;, display);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;常见问题排查&lt;/h2&gt;
&lt;h3&gt;问题1: 找不到轮廓&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 检查清单：
// 1. 二值图是否正确？
cv::imshow(&quot;binary&quot;, binary);  // 应该是黑白的

// 2. 前景是白色吗？
// findContours找的是白色区域！如果反了需要反转
cv::bitwise_not(binary, binary);

// 3. 图像是单通道吗？
std::cout &amp;lt;&amp;lt; &quot;通道数: &quot; &amp;lt;&amp;lt; binary.channels() &amp;lt;&amp;lt; std::endl;  // 应该是1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;问题2: 找到太多轮廓（都是噪点）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 解决方案：
// 1. 加强形态学处理
cv::morphologyEx(binary, binary, cv::MORPH_OPEN, kernel);

// 2. 提高面积阈值
if (area &amp;lt; 200) continue;  // 增大

// 3. 添加填充度筛选
double fillRatio = area / (width * height);
if (fillRatio &amp;lt; 0.6) continue;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;问题3: 灯条被筛掉了&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// 调试步骤：
// 1. 打印每个轮廓的参数
for (size_t i = 0; i &amp;lt; contours.size(); i++) {
    double area = cv::contourArea(contours[i]);
    cv::RotatedRect rect = cv::minAreaRect(contours[i]);
    float ratio = rect.size.height / rect.size.width;
    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: area=&quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot;, ratio=&quot; &amp;lt;&amp;lt; ratio &amp;lt;&amp;lt; std::endl;
}

// 2. 放宽筛选条件
if (aspectRatio &amp;lt; 1.5 || aspectRatio &amp;gt; 15.0) continue;  // 放宽范围

// 3. 可视化被筛掉的轮廓
cv::drawContours(rejected_img, contours, i, cv::Scalar(0,0,255), 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;问题4: 旋转矩形角度不对&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// OpenCV的angle有时不符合预期
// 解决方案：自己计算角度
cv::Point2f vertices[4];
rect.points(vertices);

// 计算长边的角度
cv::Point2f edge = vertices[1] - vertices[0];
float angle = std::atan2(edge.y, edge.x) * 180 / CV_PI;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RM装甲板识别 - 01 图像读取与显示</title><link>https://www.nanye404.top/posts/rm_opencv_01/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_01/</guid><description>无</description><pubDate>Thu, 23 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;本阶段核心API清单&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imread()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取图片到内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imshow()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示图片窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::waitKey()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等待按键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imwrite()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;保存图片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::Mat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;图像数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::VideoCapture&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开相机/视频&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::imread() - 读取图片&lt;/h2&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt;    图片路径（相对或绝对路径）
-&lt;code&gt;flags&lt;/code&gt; 读取模式（见下表）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;flags常用值:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_COLOR&lt;/code&gt; (默认) - 读取彩色图，忽略透明度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_GRAYSCALE&lt;/code&gt; - 转为灰度图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_UNCHANGED&lt;/code&gt; - 包含Alpha通道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
    // 读取彩色图（装甲板识别用这个）
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;, cv::IMREAD_COLOR);
    
    //  必须检查是否读取成功，不检查后续操作会崩溃
    if (img.empty()) {
        std::cout &amp;lt;&amp;lt; &quot; 图片读取失败！&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // 打印图片信息
    std::cout &amp;lt;&amp;lt; &quot; 图片读取成功&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;   尺寸: &quot; &amp;lt;&amp;lt; img.cols &amp;lt;&amp;lt; &quot; x &quot; &amp;lt;&amp;lt; img.rows &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;   通道数: &quot; &amp;lt;&amp;lt; img.channels() &amp;lt;&amp;lt; std::endl;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;输出示例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; 图片读取成功
   尺寸: 1280 x 720
   通道数: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;注意路径的写法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;/home/user/img.jpg&quot;);     // 绝对路径
cv::Mat img = cv::imread(&quot;img.jpg&quot;);       //相对路径

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OpenCV读取的图片是BGR格式，不是RGB！&lt;/strong&gt;&lt;br /&gt;
这在后续颜色识别时非常重要。如果你要转RGB需要用 &lt;code&gt;cv::cvtColor()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;2. cv::imshow() - 显示图片&lt;/h2&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;winname&lt;/code&gt;（自己起名）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mat&lt;/code&gt; 要显示的图像&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;armor.jpg&quot;);

// 显示图片
cv::imshow(&quot;原图&quot;, img);

//  必须配合waitKey()，否则窗口闪现即消失
cv::waitKey(0);  // 0表示无限等待，直到按任意键

// 关闭所有窗口
cv::destroyAllWindows();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;显示多个窗口&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img1 = cv::imread(&quot;red_armor.jpg&quot;);
cv::Mat img2 = cv::imread(&quot;blue_armor.jpg&quot;);

cv::imshow(&quot;红方装甲板&quot;, img1);
cv::imshow(&quot;蓝方装甲板&quot;, img2);

cv::waitKey(0);
cv::destroyAllWindows();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::waitKey() - 等待按键&lt;/h2&gt;
&lt;h3&gt;等待任意键&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::imshow(&quot;Image&quot;, img);
cv::waitKey(0);  // 按任意键继续
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检测特定按键&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::imshow(&quot;Image&quot;, img);
int key = cv::waitKey(0);

if (key == 27) {  // ESC键
    std::cout &amp;lt;&amp;lt; &quot;用户取消&quot; &amp;lt;&amp;lt; std::endl;
} else if (key == &apos;s&apos; || key == &apos;S&apos;) {  // S键
    cv::imwrite(&quot;saved.jpg&quot;, img);
    std::cout &amp;lt;&amp;lt; &quot;图片已保存&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;实时视频显示（30fps）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;while (true) {
    cv::Mat frame = getFrame();  // 获取一帧
    cv::imshow(&quot;Video&quot;, frame);
    
    // 等待33ms（约30fps），按ESC退出
    if (cv::waitKey(33) == 27) break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::Mat - 图像数据类型&lt;/h2&gt;
&lt;h3&gt;核心概念&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cv::Mat&lt;/code&gt; 是OpenCV的核心数据结构，可以理解为一个&lt;strong&gt;多维数组&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2D图像 = 二维矩阵&lt;/li&gt;
&lt;li&gt;彩色图像 = 三维矩阵（宽×高×通道）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;创建Mat对象&lt;/h3&gt;
&lt;h4&gt;方法1: 通过imread创建&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;image.jpg&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;方法2: 创建空白图像&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// 创建640×480的黑色图像
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常用属性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;image.jpg&quot;);

// 基本信息
int width = img.cols;      // 宽度（列数）
int height = img.rows;     // 高度（行数）
int channels = img.channels();  // 通道数（1=灰度，3=彩色）
bool isEmpty = img.empty();     // 是否为空

// 数据类型
int type = img.type();     // CV_8UC3 等
int depth = img.depth();   // CV_8U 等

// 内存信息
size_t total = img.total();    // 总像素数 = rows × cols
size_t bytes = img.total() * img.elemSize();  // 占用字节数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Mat类型代码说明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// CV_&amp;lt;bit-depth&amp;gt;{U|S|F}C&amp;lt;channels&amp;gt;
CV_8UC1   // 8位无符号，1通道（灰度图）
CV_8UC3   // 8位无符号，3通道（BGR彩色图）
CV_32FC1  // 32位浮点，1通道
CV_16SC3  // 16位有符号，3通道
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::imwrite() - 保存图片&lt;/h2&gt;
&lt;h3&gt;基础用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;input.jpg&quot;);

// 处理图像...

// 保存为JPG（有损压缩）
cv::imwrite(&quot;output.jpg&quot;, img);

// 保存为PNG（无损压缩，推荐保存二值图）
cv::imwrite(&quot;binary.png&quot;, binaryImg);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;设置压缩质量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// JPG质量控制（0-100，默认95）
std::vector&amp;lt;int&amp;gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // 质量90%
cv::imwrite(&quot;output.jpg&quot;, img, jpg_params);

// PNG压缩级别（0-9，默认3）
std::vector&amp;lt;int&amp;gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // 最大压缩
cv::imwrite(&quot;output.png&quot;, img, png_params);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. cv::VideoCapture - 打开相机/视频&lt;/h2&gt;
&lt;h3&gt;打开相机&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

int main() {
    // 打开默认相机（设备ID=0）
    cv::VideoCapture cap(0);
    
    // 检查是否成功打开
    if (!cap.isOpened()) {
        std::cerr &amp;lt;&amp;lt; &quot; 相机打开失败&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
  
    cv::Mat frame;
    while (true) {
        // 读取一帧
        cap.read(frame);
        // 或者: cap &amp;gt;&amp;gt; frame;
        
        if (frame.empty()) {
            std::cerr &amp;lt;&amp;lt; &quot; 无法读取帧&quot; &amp;lt;&amp;lt; std::endl;
            break;
        }
        
        // 显示
        cv::imshow(&quot;Camera&quot;, frame);
        
        // 按ESC退出
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;读取视频文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::VideoCapture cap(&quot;video.mp4&quot;);

if (!cap.isOpened()) {
    std::cerr &amp;lt;&amp;lt; &quot;视频文件打开失败&quot; &amp;lt;&amp;lt; std::endl;
    return -1;
}

// 获取视频信息
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &amp;lt;&amp;lt; &quot;视频信息: &quot; &amp;lt;&amp;lt; width &amp;lt;&amp;lt; &quot;x&quot; &amp;lt;&amp;lt; height 
          &amp;lt;&amp;lt; &quot; @ &quot; &amp;lt;&amp;lt; fps &amp;lt;&amp;lt; &quot;fps, 共&quot; &amp;lt;&amp;lt; frame_count &amp;lt;&amp;lt; &quot;帧&quot; &amp;lt;&amp;lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow(&quot;Video&quot;, frame);
    if (cv::waitKey(1000/fps) == 27) break;  // 按原速播放
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;本阶段实战练习&lt;/h2&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h3&gt;练习: 相机实时预览&lt;/h3&gt;
&lt;p&gt;实现一个相机预览程序，显示当前FPS&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt; 参考答案&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &amp;lt;&amp;lt; &quot;相机打开失败&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &amp;gt;&amp;gt; frame;
        if (frame.empty()) break;
        
        // 计算FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&amp;lt;double&amp;gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // 在图像上绘制FPS
        std::string fps_text = &quot;FPS: &quot; + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow(&quot;Camera Preview&quot;, frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>更新日志</title><link>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</link><guid isPermaLink="true">https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</guid><description>这里是更新日志</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;2025-10-22&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;更新了个人简介&lt;/li&gt;
&lt;li&gt;更新了rm笔记&lt;/li&gt;
&lt;li&gt;更新了双指针的框架&lt;/li&gt;
&lt;li&gt;评论没挂服务器所以不能用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2025-10-23&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;更新了快慢指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2025-10-24&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;更新了两篇opencv入门，ai写的，以后看着能不能精简一下&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2025-10-26&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;装甲板识别基本更完&lt;/li&gt;
&lt;li&gt;双指针更完&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>装甲板自动识别与位姿估计学习</title><link>https://www.nanye404.top/posts/armor/</link><guid isPermaLink="true">https://www.nanye404.top/posts/armor/</guid><description>一些小笔记</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;总览：系统做的事情是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A&quot;&gt;关键知识点速通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86&quot;&gt;端到端流程图（一帧图像如何被处理）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5&quot;&gt;模块逐个拆解（含核心代码片段）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;4.1 数字分类器 &lt;code&gt;NumberClassifier&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.2 视觉检测器 &lt;code&gt;Detector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.3 灯条角点精修 &lt;code&gt;LightCornerCorrector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.4 位姿估计 &lt;code&gt;ArmorPoseEstimator&lt;/code&gt;（PnP + BA）&lt;/li&gt;
&lt;li&gt;4.5 BA 优化器与图优化算子 &lt;code&gt;BaSolver&lt;/code&gt; / &lt;code&gt;GraphOptimizer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.6 ROS2 节点 &lt;code&gt;ArmorDetectorNode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97&quot;&gt;参数如何影响效果（调参指南）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96&quot;&gt;实战：从源码到运行与可视化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF&quot;&gt;常见问题与定位思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA&quot;&gt;进阶练习题（带方向提示）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84&quot;&gt;术语与坐标系小抄&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;总览：系统做的事情是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：从相机来的彩色图像中，自动找出“&lt;strong&gt;两根灯条组成的装甲板&lt;/strong&gt;”，&lt;strong&gt;识别装甲数字&lt;/strong&gt;，并估计装甲板在&lt;strong&gt;相机坐标系&lt;/strong&gt;下的三维位姿（位置 + 姿态），最后通过 &lt;strong&gt;ROS2&lt;/strong&gt; 发布结果与可视化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键阶段&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图像预处理 → 二值化轮廓 → &lt;strong&gt;灯条候选&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;灯条几何筛选 &amp;amp; 颜色判定 → &lt;strong&gt;灯条配对成装甲板&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;透视展开中部区域 → &lt;strong&gt;数字分类&lt;/strong&gt;（ONNX 模型）。&lt;/li&gt;
&lt;li&gt;对灯条上下角点做&lt;strong&gt;几何细化&lt;/strong&gt;（提升 PnP 稳定性）。&lt;/li&gt;
&lt;li&gt;用 &lt;strong&gt;PnP 求初解&lt;/strong&gt; → 条件允许时用 **BA（仅优化 yaw）**做小优化。&lt;/li&gt;
&lt;li&gt;封装为 ROS2 节点：&lt;strong&gt;订阅图像/相机内参/TF&lt;/strong&gt;，发布调试图像与 &lt;strong&gt;Marker&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;关键知识点速通&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;图像读取与显示&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_02/&quot;&amp;gt;装甲板颜色提取&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_03/&quot;&amp;gt;形态学处理&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_04/&quot;&amp;gt;轮廓检测&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;我的第一篇文章&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;我的第一篇文章&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;端到端流程图（一帧图像如何被处理）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Image(rgb8)
   └─► 预处理(灰度/阈值)
          └─► 轮廓→灯条(Light)
                 └─► 同色 + 几何关系 → 装甲(Armor)
                        ├─► (可选) 灯条角点精修
                        ├─► 透视展开数字ROI → 二值化 → 分类
                        └─► PnP求位姿 → (可选) BA优化yaw
                               └─► 发布Armors + RViz Marker + 调试图像
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;模块逐个拆解（含核心代码片段）&lt;/h2&gt;
&lt;h3&gt;4.1 数字分类器 &lt;code&gt;NumberClassifier&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;职责&lt;/strong&gt;：从装甲板两根灯条之间裁出数字图（固定尺寸），二值化后喂给 ONNX 分类网络，得到类别与置信度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心：透视展开 + 二值化 + DNN 前向&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 透视展开并裁 ROI（宽度随大小装甲而变）
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp;amp; src, const Armor&amp;amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // 中部 ROI → 灰度&amp;amp;OTSU → 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 前向分类 + 结果解码
void NumberClassifier::classify(const cv::Mat&amp;amp;, Armor&amp;amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;amp;conf, nullptr, &amp;amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format(&quot;{}:{:.1f}%&quot;, armor.number, armor.confidence * 100.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 过滤：按阈值/忽略列表 + 大小装甲与类别的互斥规则
void NumberClassifier::eraseIgnoreClasses(std::vector&amp;lt;Armor&amp;gt;&amp;amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;amp;a) {
    if (a.confidence &amp;lt; threshold) return true;
    for (auto&amp;amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == &quot;outpost&quot; || a.number == &quot;2&quot; || a.number == &quot;sentry&quot;);
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == &quot;1&quot;      || a.number == &quot;base&quot;);
    return mismatch;
  }), armors.end());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要点&lt;/strong&gt;：ROI 宽度与装甲尺寸匹配；OTSU 让阈值更稳；&lt;code&gt;blobFromImage&lt;/code&gt; 封装归一化与 NHWC→NCHW。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;4.2 视觉检测器 &lt;code&gt;Detector&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;职责&lt;/strong&gt;：灰度/阈值 → 轮廓 → 灯条（形状 + 倾角）→ 统计颜色 → 左右同色配对 → 装甲。若有分类器与角点修正器，则并行进行数字分类与角点细化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总体流程&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;Armor&amp;gt; Detector::detect(const cv::Mat&amp;amp; input) noexcept {
  binary_img = preprocessImage(input);               // 灰度+固定阈值
  lights_    = findLights(input, binary_img);        // 轮廓→Light（比例/角度/颜色）
  armors_    = matchLights(lights_);                 // 左右配对 → Armor

  if (!armors_.empty() &amp;amp;&amp;amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;amp;input](Armor&amp;amp; a){
      a.number_img = classifier-&amp;gt;extractNumber(input, a);
      classifier-&amp;gt;classify(input, a);
      if (corner_corrector) corner_corrector-&amp;gt;correctCorners(a, gray_img_);
    });
    classifier-&amp;gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关键判定：灯条与配对&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 灯条筛选：短长边比 + 倾角
bool Detector::isLight(const Light&amp;amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &amp;lt; ratio &amp;amp;&amp;amp; ratio &amp;lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &amp;lt; light_params.max_angle;
  return ratio_ok &amp;amp;&amp;amp; angle_ok;
}

// 颜色：在轮廓像素中统计R/B强度差（红/蓝）
for (auto&amp;amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &amp;gt; light_params.color_diff_thresh)
  light.color = (sum_r &amp;gt; sum_b ? RED : BLUE);

// 夹灯检测：两灯条外接矩形内是否还“夹”着别的灯条（且排除数字/红点等干扰）
bool containLight(int i, int j, const std::vector&amp;lt;Light&amp;gt;&amp;amp; lights);

// 配对：同色 + X方向扫描 + 中心距窗口（区分大小装甲）+ 两灯条长度相近 + 夹角限制
std::vector&amp;lt;Armor&amp;gt; Detector::matchLights(const std::vector&amp;lt;Light&amp;gt;&amp;amp; lights) noexcept;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.3 灯条角点精修 &lt;code&gt;LightCornerCorrector&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;职责&lt;/strong&gt;：更精确地找到每根灯条的&lt;strong&gt;上下端点&lt;/strong&gt;与&lt;strong&gt;中心/轴向&lt;/strong&gt;，提升 PnP 的 2D-3D 对应精度（在二值化或噪声环境下尤其有用）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法思路&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以灯条外接框为基础做&lt;strong&gt;适度扩展&lt;/strong&gt;并检查边界；&lt;/li&gt;
&lt;li&gt;对该小区域做&lt;strong&gt;重心与主方向&lt;/strong&gt;估计（亮度加权 + PCA/一阶矩），得到&lt;strong&gt;对称轴&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;沿对称轴的上下方向，以多个平行“扫描线”寻找&lt;strong&gt;亮度突变最大&lt;/strong&gt;的位置作为端点候选，最后求平均。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;要点代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 角点修正入口：宽度太小则跳过，避免噪声
void LightCornerCorrector::correctCorners(Armor&amp;amp; armor, const cv::Mat&amp;amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &amp;gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp;amp; 角点 */ }
  if (armor.right_light.width &amp;gt; PASS_OPTIMIZE_WIDTH) { /* 求 axis &amp;amp; 角点 */ }
}

// 沿对称轴寻找“亮度突变最大”的点作为角点（多条平行线，取候选平均）
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp;amp; gray, const Light&amp;amp; light,
                                             const SymmetryAxis&amp;amp; axis, std::string order) {
  // ... 扫描 START~END 的小段，累计亮度差最大处 ...
  // 返回均值点；无候选则返回 (-1,-1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.4 位姿估计 &lt;code&gt;ArmorPoseEstimator&lt;/code&gt;（PnP + BA）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;职责&lt;/strong&gt;：把装甲四角的 2D 像素点与已知 3D 模型点（大/小装甲的真实尺寸）对应，解出 R/t。若 roll 小且开启 BA，则进一步仅在 &lt;strong&gt;yaw&lt;/strong&gt; 维进行图优化，使投影误差更小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心流程&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1) PnP 初解（solvePnPGeneric 可能返回两组解）
if (pnp_solver_-&amp;gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) 解的选择（误差/roll/灯条倾角→yaw正负）

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;amp;&amp;amp; roll &amp;lt; 15) {
    // 3) BA：仅优化 yaw，小幅修正 R 以减小投影误差
    R = ba_solver_-&amp;gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) 填充消息（位姿 + 文本）
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;两解选择（直觉）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先看&lt;strong&gt;重投影误差&lt;/strong&gt;与 &lt;strong&gt;roll&lt;/strong&gt;（太差的解直接放弃切换）；&lt;/li&gt;
&lt;li&gt;再用&lt;strong&gt;灯条在像面上的整体倾斜&lt;/strong&gt;来判断当前&lt;strong&gt;yaw 的正负是否“合理”&lt;/strong&gt;，必要时对调解。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;4.5 BA 优化器与图优化算子 &lt;code&gt;BaSolver&lt;/code&gt; / &lt;code&gt;GraphOptimizer&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;：只把&lt;strong&gt;装甲 yaw&lt;/strong&gt; 当成优化变量（一个顶点 &lt;code&gt;VertexYaw&lt;/code&gt;），装甲的 3D 角点为固定顶点。观测为每个角点在图像里的像素位置，误差就是&lt;strong&gt;观测像素&lt;/strong&gt;减去&lt;strong&gt;投影像素&lt;/strong&gt;。这样 BA 既轻量又能稳住姿态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构图与优化&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 填图：一个 yaw 顶点 + 四个固定的 3D 顶点 + 四条投影误差边（带 Huber 鲁棒核）
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&amp;gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&amp;gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&amp;gt;setVertex(0, v_yaw); e-&amp;gt;setVertex(1, vp);
  e-&amp;gt;setMeasurement(pixel_observation);
  e-&amp;gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 自定义顶点增量：在 SO3 上用李代数更新 yaw，避免角度跳变
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 投影边误差：像素观测 - 投影(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&amp;lt;VertexYaw*&amp;gt;(_vertices[0])-&amp;gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&amp;lt;2&amp;gt;();
  _error = obs - proj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.6 ROS2 节点 &lt;code&gt;ArmorDetectorNode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;职责&lt;/strong&gt;：把检测 → 分类 →（可选）角点修正 → PnP/BA → 发布可视化，全流程在 ROS2 中跑起来。负责：参数、订阅/发布、TF、调试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点初始化（节选）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 读取参数，初始化 Detector、NumberClassifier、LightCornerCorrector
int binary_thres = declare_parameter(&quot;binary_thres&quot;, 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&amp;lt;Detector&amp;gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath(&quot;package://armor_detector/model/lenet.onnx&quot;);
auto label_path = utils::URLResolver::getResolvedPath(&quot;package://armor_detector/model/label.txt&quot;);
double threshold = declare_parameter(&quot;classifier_threshold&quot;, 0.7);
auto ignores = declare_parameter&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&quot;ignore_classes&quot;, {&quot;negative&quot;});
detector_-&amp;gt;classifier = std::make_unique&amp;lt;NumberClassifier&amp;gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter(&quot;use_pca&quot;, true);
if (use_pca) detector_-&amp;gt;corner_corrector = std::make_unique&amp;lt;LightCornerCorrector&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图像回调（节选）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1) TF: odom → 相机的旋转矩阵（IMU→Camera）
auto odom_to_cam = tf2_buffer_-&amp;gt;lookupTransform(odom_frame_, img_msg-&amp;gt;header.frame_id, img_msg-&amp;gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) 检测 + 分类 + 角点修正
auto armors = detector_-&amp;gt;detect(cv_bridge::toCvShare(img_msg, &quot;rgb8&quot;)-&amp;gt;image);

// 3) PnP/BA 提取位姿
armors_msg_.armors = armor_pose_estimator_-&amp;gt;extractArmorPoses(armors, imu_to_camera);

// 4) 可视化与发布：Marker / 调试图像 / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&amp;gt;publish(armors_msg_);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;参数如何影响效果（调参指南）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binary_thres&lt;/code&gt;：阈值高→噪点少但灯条可能断；阈值低→连通域粘连。先打开调试图像话题观察再调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;light.min_ratio / max_ratio / max_angle&lt;/code&gt;：控制灯条的“细长”和“近垂直”程度；误检多就收紧，漏检多就放宽。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;light.color_diff_thresh&lt;/code&gt;：越大越“保守”地判断颜色；太小会把杂散光当成红/蓝。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;armor.*_center_distance&lt;/code&gt;：两灯条中心距窗口；与焦距/距离有关，镜头变化后要重调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;classifier_threshold / ignore_classes&lt;/code&gt;：分类阈值与忽略类，先松后紧，结合实测混淆再收敛。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use_pca&lt;/code&gt;：角点修正，噪声环境或分辨率不高时常有帮助。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use_ba&lt;/code&gt;：轻量的 yaw 优化，能减抖、稳姿态；但在极端视角下可能收益有限。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;实战：从源码到运行与可视化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;准备&lt;/strong&gt;：相机话题 &lt;code&gt;image_raw&lt;/code&gt;、&lt;code&gt;camera_info&lt;/code&gt;，并确认 TF 链路（&lt;code&gt;odom → camera&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动节点&lt;/strong&gt;：加载参数（上面提到的阈值与窗口）并打开 &lt;code&gt;debug&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RViz&lt;/strong&gt;：添加 &lt;code&gt;MarkerArray&lt;/code&gt; 订阅 &lt;code&gt;armor_detector/marker&lt;/code&gt;；把调试图像话题（&lt;code&gt;binary_img/number_img/result_img&lt;/code&gt;）也开出来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;观察与调整&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;先让&lt;strong&gt;灯条候选&lt;/strong&gt;稳定 → 再看&lt;strong&gt;配对&lt;/strong&gt;是否合理 → 最后看&lt;strong&gt;数字分类&lt;/strong&gt;与&lt;strong&gt;位姿&lt;/strong&gt;是否稳定。&lt;/li&gt;
&lt;li&gt;逐项微调参数，记录每项调整对召回/精度的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;常见问题与定位思路&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;灯条“夹灯”/误配对&lt;/strong&gt;：检查 &lt;code&gt;containLight&lt;/code&gt; 规则与数字/红点宽度过滤；适当提高 &lt;code&gt;color_diff_thresh&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类不稳&lt;/strong&gt;：对比 &lt;code&gt;number_img&lt;/code&gt; 是否干净；检查 ROI 宽度是否与大/小装甲一致；适当调阈值或忽略类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位姿“翻面”&lt;/strong&gt;：理解 &lt;code&gt;sortPnPResult&lt;/code&gt; 的选择逻辑（误差、roll、灯条倾角与 yaw 正负），必要时在近景贴纸纹理上做辅助。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;姿态抖动&lt;/strong&gt;：开启 &lt;code&gt;use_ba&lt;/code&gt;；或在 &lt;code&gt;LightCornerCorrector&lt;/code&gt; 中加大候选条数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;进阶练习题（带方向提示）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;把阈值改成自适应&lt;/strong&gt;：尝试 &lt;code&gt;cv::adaptiveThreshold&lt;/code&gt; 或根据区域亮度动态调 &lt;code&gt;binary_thres&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加入时序稳定&lt;/strong&gt;：在 &lt;code&gt;Detector&lt;/code&gt; 输出上做跟踪（Kalman/匈牙利匹配），让数字与姿态在帧间更稳。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据增强与再训练&lt;/strong&gt;：对 &lt;code&gt;number_img&lt;/code&gt; 做随机仿射/噪声增强，微调 ONNX 模型，观察混淆类的改善。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多目标选择策略&lt;/strong&gt;：当同屏多块装甲时，基于 &lt;code&gt;distance_to_image_center&lt;/code&gt;、置信度或历史 ID 选择目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;术语与坐标系小抄&lt;/h2&gt;
</content:encoded></item><item><title>双指针</title><link>https://www.nanye404.top/posts/twop/</link><guid isPermaLink="true">https://www.nanye404.top/posts/twop/</guid><description>双指针常见技巧</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;本篇参考labuladong的算法笔记编写&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8&quot;&gt;双指针在数组的运用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88&quot;&gt;快慢指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2&quot;&gt;二分搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E4%B9%8B%E5%92%8C&quot;&gt;数之和&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC&quot;&gt;回文/反转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3&quot;&gt;滑动窗口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8&quot;&gt;双指针在链表的运用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8&quot;&gt;合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E8%A7%A3&quot;&gt;分解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B6%E4%BB%96&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;双指针在数组的运用&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;快慢指针&lt;/h2&gt;
&lt;h3&gt;数组的原地修改&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;力扣第 26 题「删除有序数组中的重复项」，让你在有序数组去重：
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;给你一个&lt;strong&gt;非严格递增排列&lt;/strong&gt;的数组&lt;code&gt;nums&lt;/code&gt; ，请你&lt;strong&gt;原地&lt;/strong&gt;删除重复出现的元素，使每个元素&lt;strong&gt;只出现一次&lt;/strong&gt;，返回删除后数组的新长度。元素的&lt;strong&gt;相对顺序&lt;/strong&gt;应该保持&lt;strong&gt;一致&lt;/strong&gt;。然后返回 &lt;code&gt;nums&lt;/code&gt; 中唯一元素的个数。&lt;/li&gt;
&lt;li&gt;考虑 &lt;code&gt;nums &lt;/code&gt;的唯一元素的数量为 &lt;code&gt;k&lt;/code&gt;。去重后，返回唯一元素的数量 k。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 的前 k 个元素应包含 排序后 的唯一数字。下标 &lt;code&gt;k - 1 &lt;/code&gt;之后的剩余元素可以忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判题标准:&lt;/p&gt;
&lt;p&gt;系统会用下面的代码来测试你的题解:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案
int k = removeDuplicates(nums); // 调用
assert k == expectedNums.length;
for (int i = 0; i &amp;lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果所有断言都通过，那么您的题解将被&lt;strong&gt;通过&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原地&lt;/strong&gt;意味着只能对当前数组进行修改，不能新建一个数组&lt;/li&gt;
&lt;li&gt;这里所需要用到的就是&lt;strong&gt;快慢指针&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;简单来说就是一个快指针去识别，另一个慢指针去操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;  这里指针是广义上的指针，数组的索引也可以是&lt;strong&gt;指针&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;fast&lt;/code&gt; 遇到值为 &lt;code&gt;val &lt;/code&gt;的元素，则直接跳过，否则就赋值给 &lt;code&gt;slow&lt;/code&gt; 指针，并让 &lt;code&gt;slow &lt;/code&gt;前进一步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &amp;lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;注意这里需要&lt;strong&gt;先&lt;code&gt;slow++&lt;/code&gt;再赋值&lt;/strong&gt;，要不然第一个会被吞掉&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;下面一道题也是快慢指针的思想，如果掌握了前一道题，这题会很简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;力扣283移动0&lt;/strong&gt;https://leetcode.cn/problems/move-zeroes/&lt;/li&gt;
&lt;li&gt;给定一个数组 &lt;strong&gt;nums&lt;/strong&gt;，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/li&gt;
&lt;li&gt;请注意 ，必须在不复制数组的情况下原地对数组进行操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
示例 2:
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [0]
输出: [0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我就直接上代码了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int slow = 0;  // 指向下一个非零应放置的位置
        for (int fast = 0; fast &amp;lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow 之后的全部置为 0
        for (int i = slow; i &amp;lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;二分搜索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在我们都玩过的猜数字游戏中，用的就是二分搜素的技巧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们先看最笨的顺序查找，我们从1-100遍历全部数字，虽然说运气好可能一下会猜中，但是期望的次数还是很多，复杂度为O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是凭感觉找，一样还是要看运气&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果第一次猜50，然后继续一半一半缩小区间，最坏也能在7次内解决&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何数字来到1-1000000，二分搜索最坏20次就能找到答案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二分搜索的时间复杂度是O(log  N)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面是最基本代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
    // 一左一右两个指针相向而行
    int left = 0, right = nums.size() - 1;
    while(left &amp;lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &amp;lt; target)
            left = mid + 1; 
        else if (nums[mid] &amp;gt; target)
            right = mid - 1;
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数之和&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作为力扣的第一道题，很多人上来直接就是两个for循环暴力枚举，但实际上有更聪明的枚举方式，这个题就是一个典型的双指针问题&lt;/li&gt;
&lt;li&gt;https://leetcode.cn/problems/two-sum/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;给定一个整数数组&lt;code&gt; num&lt;/code&gt;s 和一个整数目标值&lt;code&gt; target&lt;/code&gt;，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt;&lt;code&gt; target&lt;/code&gt;  的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [3,2,4], target = 6
输出：[1,2]

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这题的思路和二分搜索很相似，而且这种问题显然让数组有序会更好做&lt;/li&gt;
&lt;li&gt;当数组有序之后，&lt;code&gt;首项+尾项/2&lt;/code&gt;很接近所有数的平均数，因此也最可能接近&lt;code&gt;target&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我们让&lt;code&gt;left&lt;/code&gt;指向最小&lt;code&gt;right&lt;/code&gt;指向最大,如果小了就让left++，大了就让right--
--- 下面是代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
        vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; vec;//这里为了保留原数组的索引
        for (int i = 0; i &amp;lt; nums.size(); ++i)
            vec.push_back({nums[i], i});

        sort(vec.begin(), vec.end());

        int left = 0, right = vec.size() - 1;
        while (left &amp;lt; right) {
            int sum = vec[left].first + vec[right].first;
            if (sum == target) {
                return {vec[left].second, vec[right].second};
            } else if (sum &amp;lt; target) {
                left++;
            } else {
                right--;
            }
        }
        
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;其实这题的最优解是哈希表，但是现在讲的是双指针，后面再说&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;回文/反转&lt;/h2&gt;
&lt;h3&gt;反转字符串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode.cn/problems/reverse-string/description/&lt;/li&gt;
&lt;li&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。&lt;/li&gt;
&lt;li&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
示例 1：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这题很简单，我就直接给代码了&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void reverseString(vector&amp;lt;char&amp;gt;&amp;amp; s) {
        int n = s.size();
        for (int left = 0, right = n - 1; left &amp;lt; right; ++left, --right) {
            swap(s[left], s[right]);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;最长回文子串&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到&lt;code&gt;s&lt;/code&gt;中最长的 &lt;strong&gt;回文&lt;/strong&gt; 子串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;babad&quot;
输出：&quot;bab&quot;
解释：&quot;aba&quot; 同样是符合题意的答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &quot;cbbd&quot;
输出：&quot;bb&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;像这种回文/对称，应该想到用双指针&lt;/li&gt;
&lt;li&gt;但是需要先判断一下回文序列的奇偶，奇偶需要不同的处理方式
&lt;ul&gt;
&lt;li&gt;如果是奇数，那么两个指针应该重合，再向两侧寻找&lt;/li&gt;
&lt;li&gt;如果是偶数，两个指针停留在相同的字符上，再向两侧寻找&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;lass Solution {
public:
    string longestPalindrome(string s) {
        string res = &quot;&quot;;
        for (int i = 0; i &amp;lt; s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            string s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            string s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() &amp;gt; s1.length() ? res : s1;
            res = res.length() &amp;gt; s2.length() ? res : s2;
        }
        return res;
    }

private:
    string palindrome(string s, int l, int r) {
        // 防止索引越界
        while (l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; s.length() &amp;amp;&amp;amp; s[l] == s[r]) {
            // 向两边展开
            l--;
            r++;
        }
        // 此时 s[l+1..r-1] 就是最长回文串
        return s.substr(l + 1, r - l - 1);
    }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;滑动窗口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;滑动窗口框架&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void slidingWindow(string s) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    auto window = ...

    int left = 0, right = 0;
    while (right &amp;lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        window.add(c);
        // 增大窗口
        right++;

        // 进行窗口内数据的一系列更新
        ...

        // *** debug 输出的位置 ***
        printf(&quot;window: [%d, %d)\n&quot;, left, right);
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            window.remove(d);
            // 缩小窗口
            left++;

            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;字符串的排列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给你两个字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; ，写一个函数来判断 &lt;code&gt;s2&lt;/code&gt; 是否包含 &lt;code&gt;s1&lt;/code&gt; 的 排列。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;换句话说，&lt;code&gt;s1&lt;/code&gt; 的排列之一是 &lt;code&gt;s2&lt;/code&gt; 的 子串 。
示例 1：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;
输出：true
解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;
输出：false
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;窗口大小固定为 s1.size()
&lt;ul&gt;
&lt;li&gt;因为 s2 中可能存在的子串长度必须等于 s1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;维护一个频次数组
&lt;ul&gt;
&lt;li&gt;用 cnt1[26] 保存 s1 中每个字母出现的次数。&lt;/li&gt;
&lt;li&gt;遍历 s2 时，维护一个窗口 [l, r]，每次加入一个字符，尝试匹配 cnt1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匹配条件
&lt;ul&gt;
&lt;li&gt;定义 count = k = s1.size()，表示还差多少个字符能匹配成功。&lt;/li&gt;
&lt;li&gt;每次加入新字符 s2[r]：
&lt;ul&gt;
&lt;li&gt;让 cnt1[s2[r]]--。&lt;/li&gt;
&lt;li&gt;如果 cnt1[s2[r]] 还大于 0，说明这个字符是需要的 → count--。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当窗口长度等于 k 时：
&lt;ul&gt;
&lt;li&gt;如果 count == 0，说明窗口里的字符正好是一个排列 → 返回 true。&lt;/li&gt;
&lt;li&gt;窗口右移时，把 s2[l] 移出：
&lt;ul&gt;
&lt;li&gt;如果 ++cnt1[s2[l]] &amp;gt; 0，说明移出了一个必须的字符 → count++。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下一步窗口大小 &amp;gt;k 了，需要l++  → 维持窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    // 判断 s 中是否存在 t 的排列
    bool checkInclusion(string t, string s) {
        unordered_map&amp;lt;char, int&amp;gt; need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        while (right &amp;lt; s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // 判断左侧窗口是否要收缩
            while (right - left &amp;gt;= t.size()) {
                // 在这里判断是否找到了合法的子串
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;双指针在链表的运用&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;合并两个有序列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://leetcode.cn/problems/merge-two-sorted-lists/description/&lt;/li&gt;
&lt;li&gt;将两个升序链表合并为一个新的 &lt;code&gt;升序&lt;/code&gt; 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例 1:
&amp;lt;img src=&quot;/img/merge_ex1.jpg&quot;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [], l2 = []
输出：[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [], l2 = [0]
输出：[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;比较简单，下面是代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 虚拟头结点
        ListNode dummy(-1), *p = &amp;amp;dummy;
        ListNode *p1 = l1, *p2 = l2;
        
        while (p1 != nullptr &amp;amp;&amp;amp; p2 != nullptr) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1-&amp;gt;val &amp;gt; p2-&amp;gt;val) {
                p-&amp;gt;next = p2;
                p2 = p2-&amp;gt;next;
            } else {
                p-&amp;gt;next = p1;
                p1 = p1-&amp;gt;next;
            }
            // p 指针不断前进
            p = p-&amp;gt;next;
        }
        
        if (p1 != nullptr) {
            p-&amp;gt;next = p1;
        }
        
        if (p2 != nullptr) {
            p-&amp;gt;next = p2;
        }
        
        return dummy.next;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;单链表的分解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https://leetcode.cn/problems/partition-list/description/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个特定值 &lt;code&gt;x&lt;/code&gt; ，请你对链表进行分隔，使得所有 小于 &lt;code&gt;x&lt;/code&gt; &lt;strong&gt;的节点都出现在&lt;/strong&gt; 大于或等于 &lt;code&gt;x&lt;/code&gt; 的节点之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你应当 保留 两个分区中每个节点的初始相对位置。
实例 1：
&amp;lt;img src=&quot;/img/partition.jpg&quot;&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：head = [2,1], x = 2
输出：[1,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;是不是很像之前讲过的移动0？&lt;/li&gt;
&lt;li&gt;思路其实都差不多，快慢指针的思想，一个查找，一个处理&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>视频测试</title><link>https://www.nanye404.top/posts/video/</link><guid isPermaLink="true">https://www.nanye404.top/posts/video/</guid><description>视频测试。</description><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这是视频测试&lt;/p&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&amp;amp;autoplay=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; &amp;amp;autoplay=0&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item></channel></rss>