<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>å—å¶ã®å°çª</title><description>æ¬¢è¿æ¥ç©awa</description><link>https://www.nanye404.top/</link><language>zh_CN</language><item><title>RMè£…ç”²æ¿è¯†åˆ« - 03 å½¢æ€å­¦å¤„ç†</title><link>https://www.nanye404.top/posts/rm_opencv_03/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_03/</guid><description>æ— </description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;ä½œç”¨&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::getStructuringElement()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;åˆ›å»ºå½¢æ€å­¦æ ¸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::dilate()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è†¨èƒ€ï¼ˆå˜èƒ–ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::erode()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è…èš€ï¼ˆå˜ç˜¦ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::morphologyEx()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é«˜çº§å½¢æ€å­¦&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;æ ¸å¿ƒæ€è·¯&lt;/h2&gt;
&lt;p&gt;é¢œè‰²æå–åçš„äºŒå€¼å›¾æœ‰ä¸¤ä¸ªä¸»è¦é—®é¢˜ï¼š&lt;/p&gt;
&lt;h3&gt;é—®é¢˜1: å™ªç‚¹ï¼ˆå°ç™½ç‚¹åˆ°å¤„éƒ½æ˜¯ï¼‰&lt;/h3&gt;
&lt;h3&gt;é—®é¢˜2: æ–­è£‚ï¼ˆç¯æ¡ä¸­é—´æœ‰ç¼éš™ï¼‰&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;å½¢æ€å­¦æ“ä½œå°±æ˜¯è§£å†³è¿™äº›é—®é¢˜çš„å·¥å…·ï¼&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;å½¢æ€å­¦å››ç§å¤„ç†æ–¹å¼&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;æ“ä½œ&lt;/th&gt;
&lt;th&gt;æ•ˆæœ&lt;/th&gt;
&lt;th&gt;æ¯”å–»&lt;/th&gt;
&lt;th&gt;ç”¨é€”&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;è†¨èƒ€ dilate&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ç™½è‰²åŒºåŸŸå˜å¤§&lt;/td&gt;
&lt;td&gt;æ¶‚èƒ–ç¬”&lt;/td&gt;
&lt;td&gt;è¿æ¥æ–­è£‚&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;è…èš€ erode&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ç™½è‰²åŒºåŸŸå˜å°&lt;/td&gt;
&lt;td&gt;æ©¡çš®æ“¦&lt;/td&gt;
&lt;td&gt;å»é™¤å™ªç‚¹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;å¼€è¿ç®— open&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;å…ˆè…èš€åè†¨èƒ€&lt;/td&gt;
&lt;td&gt;å…ˆæ“¦åæ¶‚&lt;/td&gt;
&lt;td&gt;å»å™ªä¿å½¢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;é—­è¿ç®— close&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;å…ˆè†¨èƒ€åè…èš€&lt;/td&gt;
&lt;td&gt;å…ˆæ¶‚åæ“¦&lt;/td&gt;
&lt;td&gt;å¡«ç¼ä¿å½¢&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::getStructuringElement() - åˆ›å»ºå½¢æ€å­¦æ ¸&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Mat cv::getStructuringElement(int shape, Size ksize, 
                               Point anchor = Point(-1,-1));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ ¸å½¢çŠ¶ç±»å‹&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;shape&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;th&gt;æ•ˆæœ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_RECT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;çŸ©å½¢ï¼ˆæœ€å¸¸ç”¨ï¼‰&lt;/td&gt;
&lt;td&gt;å„æ–¹å‘å‡åŒ€&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_ELLIPSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ¤­åœ†å½¢&lt;/td&gt;
&lt;td&gt;è¾¹ç¼˜æ›´åœ†æ»‘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_CROSS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;åå­—å½¢&lt;/td&gt;
&lt;td&gt;åªä½œç”¨äºä¸Šä¸‹å·¦å³&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åˆ›å»º3Ã—3çŸ©å½¢æ ¸
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// åˆ›å»º5Ã—5æ¤­åœ†æ ¸
cv::Mat kernel2 = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));

// åˆ›å»º7Ã—7åå­—æ ¸
cv::Mat kernel3 = cv::getStructuringElement(cv::MORPH_CROSS, cv::Size(7, 7));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ ¸å¤§å°å¦‚ä½•é€‰æ‹©ï¼Ÿ&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å°ºå¯¸&lt;/th&gt;
&lt;th&gt;æ•ˆæœ&lt;/th&gt;
&lt;th&gt;é€‚ç”¨åœºæ™¯&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3Ã—3&lt;/td&gt;
&lt;td&gt;è½»å¾®å¤„ç†&lt;/td&gt;
&lt;td&gt;å°å™ªç‚¹ã€ç»†å¾®ç¼éš™&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5Ã—5&lt;/td&gt;
&lt;td&gt;ä¸­ç­‰æ•ˆæœ&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;æ¨è&lt;/strong&gt;ï¼Œå¹³è¡¡æ•ˆæœå’Œæ€§èƒ½&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7Ã—7&lt;/td&gt;
&lt;td&gt;å¼ºåŠ›æ•ˆæœ&lt;/td&gt;
&lt;td&gt;å¤§å™ªç‚¹ã€å¤§ç¼éš™ï¼ˆå¯èƒ½ç ´åç¯æ¡å½¢çŠ¶ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9Ã—9+&lt;/td&gt;
&lt;td&gt;æå¼ºæ•ˆæœ&lt;/td&gt;
&lt;td&gt;æ…ç”¨ï¼å®¹æ˜“æŠŠç¯æ¡å˜å½¢&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;2. cv::dilate() - è†¨èƒ€æ“ä½œ&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::dilate(InputArray src, OutputArray dst, InputArray kernel,
                Point anchor = Point(-1,-1), int iterations = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ğŸ“‹ å‚æ•°è¯´æ˜&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;src&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¾“å…¥äºŒå€¼å›¾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dst&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¾“å‡ºç»“æœ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;å½¢æ€å­¦æ ¸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;anchor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é”šç‚¹ä½ç½®ï¼ˆ-1,-1è¡¨ç¤ºä¸­å¿ƒï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;iterations&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¿­ä»£æ¬¡æ•°ï¼ˆé‡å¤è†¨èƒ€å‡ æ¬¡ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è…èš€ä¸€æ¬¡
cv::Mat eroded;
cv::erode(binary, eroded, kernel);

cv::imshow(&quot;åŸå§‹äºŒå€¼å›¾&quot;, binary);
cv::imshow(&quot;è…èš€å&quot;, eroded);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åº”ç”¨åœºæ™¯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;å»é™¤å°å™ªç‚¹&lt;/li&gt;
&lt;li&gt;åˆ†ç¦»ç²˜è¿ç‰©ä½“&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;è…èš€çš„å‰¯ä½œç”¨&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ç¯æ¡ä¹Ÿä¼šå˜ç»†&lt;/li&gt;
&lt;li&gt;è§£å†³æ–¹æ¡ˆï¼šè…èš€åå†è†¨èƒ€å›æ¥ï¼ˆå¼€è¿ç®—ï¼‰&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::morphologyEx() - é«˜çº§å½¢æ€å­¦æ“ä½œ&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::morphologyEx(InputArray src, OutputArray dst, int op,
                      InputArray kernel, Point anchor = Point(-1,-1),
                      int iterations = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ“ä½œç±»å‹&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;op&lt;/th&gt;
&lt;th&gt;æ“ä½œ&lt;/th&gt;
&lt;th&gt;å…¬å¼&lt;/th&gt;
&lt;th&gt;æ•ˆæœ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_OPEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;å¼€è¿ç®—&lt;/td&gt;
&lt;td&gt;erode â†’ dilate&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;å»å™ªä¿å½¢&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_CLOSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é—­è¿ç®—&lt;/td&gt;
&lt;td&gt;dilate â†’ erode&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;å¡«ç¼ä¿å½¢&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_GRADIENT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;å½¢æ€å­¦æ¢¯åº¦&lt;/td&gt;
&lt;td&gt;dilate - erode&lt;/td&gt;
&lt;td&gt;æå–è¾¹ç¼˜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_TOPHAT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é¡¶å¸½&lt;/td&gt;
&lt;td&gt;src - open&lt;/td&gt;
&lt;td&gt;æå–å°äº®ç‚¹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MORPH_BLACKHAT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é»‘å¸½&lt;/td&gt;
&lt;td&gt;close - src&lt;/td&gt;
&lt;td&gt;æå–å°æš—ç‚¹&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;5. é—­è¿ç®— (MORPH_CLOSE)&lt;/h2&gt;
&lt;h3&gt;å·¥ä½œåŸç†&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;é—­è¿ç®— = å…ˆè†¨èƒ€ â†’ å†è…èš€&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat binary = extractColor(img);
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// é—­è¿ç®—
cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);

cv::imshow(&quot;åŸå§‹&quot;, binary);
cv::imshow(&quot;é—­è¿ç®—å&quot;, closed);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åº”ç”¨åœºæ™¯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;è¿æ¥ç¯æ¡çš„ç»†å¾®æ–­è£‚&lt;/li&gt;
&lt;li&gt;å¡«è¡¥ç¯æ¡å†…éƒ¨çš„å°é»‘æ´&lt;/li&gt;
&lt;li&gt;ä¿æŒç¯æ¡çš„æ•´ä½“å½¢çŠ¶&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;æ³¨æ„äº‹é¡¹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// æ ¸å¤ªå¤§ä¼šè®©ä¸¤ä¸ªç¯æ¡ç²˜åœ¨ä¸€èµ·ï¼
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
//  å¯èƒ½å¯¼è‡´å·¦å³ç¯æ¡åˆå¹¶

// æ¨èä½¿ç”¨5Ã—5æˆ–7Ã—7
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. å¼€è¿ç®— (MORPH_OPEN) - å»å™ªåˆ©å™¨&lt;/h2&gt;
&lt;h3&gt;å·¥ä½œåŸç†&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;å¼€è¿ç®— = å…ˆè…èš€ â†’ å†è†¨èƒ€&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// å¼€è¿ç®—
cv::Mat opened;
cv::morphologyEx(binary, opened, cv::MORPH_OPEN, kernel);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åº”ç”¨åœºæ™¯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;å»é™¤å°å™ªç‚¹&lt;/li&gt;
&lt;li&gt;åˆ†ç¦»è½»å¾®ç²˜è¿çš„ç‰©ä½“&lt;/li&gt;
&lt;li&gt;å¹³æ»‘ç‰©ä½“è¾¹ç¼˜&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;7. RMè£…ç”²æ¿è¯†åˆ«æ¨èæµç¨‹&lt;/h2&gt;
&lt;h3&gt;æ ‡å‡†æµç¨‹ï¼ˆä¸¤æ­¥æ³•ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat processArmor(const cv::Mat&amp;amp; img) {
    // 1. é¢œè‰²æå–
    cv::Mat binary = extractColor(img);  // ä»ç¬¬02ç« è·å¾—
    
    // 2. å½¢æ€å­¦å¤„ç†
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // ç¬¬ä¸€æ­¥ï¼šé—­è¿ç®—ï¼ˆå¡«è¡¥ç¯æ¡ç¼éš™ï¼‰
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // ç¬¬äºŒæ­¥ï¼šå¼€è¿ç®—ï¼ˆå»é™¤å™ªç‚¹ï¼‰
    cv::Mat result;
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;8. å½¢æ€å­¦æ¢¯åº¦ (MORPH_GRADIENT)&lt;/h2&gt;
&lt;h3&gt;å·¥ä½œåŸç†&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;æ¢¯åº¦ = è†¨èƒ€ - è…èš€
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat gradient;
cv::morphologyEx(binary, gradient, cv::MORPH_GRADIENT, kernel);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ•ˆæœ&lt;/h3&gt;
&lt;p&gt;æå–ç‰©ä½“çš„&lt;strong&gt;å¤–è½®å»“çº¿&lt;/strong&gt;ï¼Œç±»ä¼¼è¾¹ç¼˜æ£€æµ‹&lt;/p&gt;
&lt;h3&gt;åº”ç”¨åœºæ™¯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;èƒ½é‡æœºå…³æ‰‡å¶è¾¹ç¼˜æ£€æµ‹&lt;/li&gt;
&lt;li&gt;è£…ç”²æ¿å¤–æ¡†æå–ï¼ˆä¸å¸¸ç”¨ï¼‰&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;å®Œæ•´å®æˆ˜ä»£ç &lt;/h2&gt;
&lt;h3&gt;æ–¹æ¡ˆ1: å¿«é€Ÿç‰ˆï¼ˆå•æ¬¡æ“ä½œï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    // é¢œè‰²æå–ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = extractRedColor(img);
    
    // å½¢æ€å­¦æ ¸
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // é—­è¿ç®—ï¼ˆæœ€å¸¸ç”¨ï¼‰
    cv::Mat result;
    cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
    
    // æ˜¾ç¤ºå¯¹æ¯”
    cv::imshow(&quot;åŸå§‹äºŒå€¼å›¾&quot;, binary);
    cv::imshow(&quot;å½¢æ€å­¦å¤„ç†å&quot;, result);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ–¹æ¡ˆ2: æ ‡å‡†ç‰ˆï¼ˆä¸¤æ­¥æ³•ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat morphologyProcess(const cv::Mat&amp;amp; binary) {
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    
    // ç¬¬ä¸€æ­¥ï¼šé—­è¿ç®—å¡«ç¼
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    
    // ç¬¬äºŒæ­¥ï¼šå¼€è¿ç®—å»å™ª
    cv::Mat opened;
    cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
    
    return opened;
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    cv::Mat binary = extractColor(img);
    
    cv::Mat result = morphologyProcess(binary);
    
    // æ˜¾ç¤ºä¸‰æ­¥å¯¹æ¯”
    cv::imshow(&quot;1-åŸå§‹&quot;, binary);
    cv::Mat closed;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, 
                     cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5,5)));
    cv::imshow(&quot;2-é—­è¿ç®—&quot;, closed);
    cv::imshow(&quot;3-æœ€ç»ˆç»“æœ&quot;, result);
    
    cv::waitKey(0);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ–¹æ¡ˆ3: è‡ªé€‚åº”ç‰ˆï¼ˆæ ¹æ®å›¾åƒå¤§å°è°ƒæ•´æ ¸ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat adaptiveMorphology(const cv::Mat&amp;amp; binary) {
    // æ ¹æ®å›¾åƒå¤§å°è‡ªé€‚åº”æ ¸å°ºå¯¸
    int kernelSize = std::max(3, (int)(binary.cols * 0.005));
    if (kernelSize % 2 == 0) kernelSize++;  // ç¡®ä¿æ˜¯å¥‡æ•°
    
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                               cv::Size(kernelSize, kernelSize));
    
    cv::Mat closed, result;
    cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
    cv::morphologyEx(closed, result, cv::MORPH_OPEN, kernel);
    
    std::cout &amp;lt;&amp;lt; &quot;ä½¿ç”¨æ ¸å°ºå¯¸: &quot; &amp;lt;&amp;lt; kernelSize &amp;lt;&amp;lt; &quot;Ã—&quot; &amp;lt;&amp;lt; kernelSize &amp;lt;&amp;lt; std::endl;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å¸¸è§é—®é¢˜æ’æŸ¥&lt;/h2&gt;
&lt;h3&gt;é—®é¢˜1: å¤„ç†åç¯æ¡æ¶ˆå¤±äº†&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åŸå› ï¼šæ ¸å¤ªå¤§ï¼ŒæŠŠç¯æ¡ä¹Ÿè…èš€æ‰äº†
cv::Mat kernel_bad = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));

// è§£å†³ï¼šå‡å°æ ¸å°ºå¯¸
cv::Mat kernel_good = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜2: ä¸¤ä¸ªç¯æ¡ç²˜åœ¨ä¸€èµ·äº†&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åŸå› ï¼šé—­è¿ç®—è†¨èƒ€å¤ªå¼º
// è§£å†³1ï¼šå‡å°æ ¸å°ºå¯¸
cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è§£å†³2ï¼šå‡å°‘è¿­ä»£æ¬¡æ•°
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel, cv::Point(-1,-1), 1);

// è§£å†³3ï¼šä¸ç”¨é—­è¿ç®—ï¼Œåªç”¨è½»å¾®è†¨èƒ€
cv::dilate(binary, result, kernel, cv::Point(-1,-1), 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜3: å™ªç‚¹è¿˜æ˜¯å¾ˆå¤š&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åŸå› ï¼šæ ¸å¤ªå°
cv::Mat kernel_small = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));

// è§£å†³ï¼šå¢å¤§æ ¸æˆ–å¢åŠ è¿­ä»£æ¬¡æ•°
cv::Mat kernel_big = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(7, 7));
// æˆ–è€…
cv::morphologyEx(binary, result, cv::MORPH_OPEN, kernel, cv::Point(-1,-1), 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜4: ä¸çŸ¥é“ç”¨å“ªä¸ªæ“ä½œ&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// å†³ç­–æ ‘ï¼š
if (ç¯æ¡æœ‰æ–­è£‚/ç¼éš™) {
    ä½¿ç”¨é—­è¿ç®— MORPH_CLOSE
}
if (æœ‰å¾ˆå¤šå°å™ªç‚¹) {
    ä½¿ç”¨å¼€è¿ç®— MORPH_OPEN
}
if (æ—¢æœ‰æ–­è£‚åˆæœ‰å™ªç‚¹) {
    å…ˆé—­è¿ç®—ï¼Œå†å¼€è¿ç®—  // â† RMæ ‡å‡†æµç¨‹
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;è°ƒè¯•æŠ€å·§&lt;/h2&gt;
&lt;h3&gt;æŠ€å·§1: å¯è§†åŒ–æ¯ä¸€æ­¥&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat binary = extractColor(img);

cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));

// ä¿å­˜æ¯ä¸€æ­¥
cv::imshow(&quot;1-åŸå§‹&quot;, binary);

cv::Mat closed;
cv::morphologyEx(binary, closed, cv::MORPH_CLOSE, kernel);
cv::imshow(&quot;2-é—­è¿ç®—&quot;, closed);

cv::Mat opened;
cv::morphologyEx(closed, opened, cv::MORPH_OPEN, kernel);
cv::imshow(&quot;3-å¼€è¿ç®—&quot;, opened);

cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æŠ€å·§2: åˆ›å»ºæ»‘å—è°ƒå‚&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int kernelSize = 5;

void on_trackbar(int, void*) {}

int main() {
    cv::namedWindow(&quot;è°ƒå‚&quot;);
    cv::createTrackbar(&quot;æ ¸å°ºå¯¸&quot;, &quot;è°ƒå‚&quot;, &amp;amp;kernelSize, 15, on_trackbar);
    
    while (true) {
        if (kernelSize % 2 == 0) kernelSize++;  // ç¡®ä¿å¥‡æ•°
        if (kernelSize &amp;lt; 3) kernelSize = 3;
        
        cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, 
                                                   cv::Size(kernelSize, kernelSize));
        
        cv::Mat result;
        cv::morphologyEx(binary, result, cv::MORPH_CLOSE, kernel);
        
        cv::imshow(&quot;ç»“æœ&quot;, result);
        if (cv::waitKey(30) == 27) break;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RMè£…ç”²æ¿è¯†åˆ« - 02 è£…ç”²æ¿é¢œè‰²æå–</title><link>https://www.nanye404.top/posts/rm_opencv_02/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_02/</guid><description>æ— </description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;ä½œç”¨&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::split()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;åˆ†ç¦»BGRé€šé“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::cvtColor()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é¢œè‰²ç©ºé—´è½¬æ¢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::inRange()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é¢œè‰²èŒƒå›´ç­›é€‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::threshold()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ç®€å•é˜ˆå€¼äºŒå€¼åŒ–&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::subtract()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;é€šé“ç›¸å‡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::bitwise_or/and()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä½è¿ç®—ç»„åˆmask&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;æ ¸å¿ƒæ€è·¯&lt;/h2&gt;
&lt;p&gt;è£…ç”²æ¿çš„ç¯æ¡æœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ç‰¹å®šé¢œè‰²&lt;/strong&gt;ï¼ˆçº¢è‰²æˆ–è“è‰²ï¼‰&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;é«˜äº®åº¦&lt;/strong&gt;ï¼ˆç¯æ¡æ˜¯å‘å…‰çš„ï¼‰&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RMè§†è§‰ä¸­æœ‰&lt;strong&gt;ä¸¤æ¡ä¸»æµè·¯çº¿&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;h3&gt;è·¯çº¿1: é€šé“ç›¸å‡æ³•&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;åŸç†&lt;/strong&gt;: BGRå›¾åƒä¸­ï¼Œçº¢è‰²åŒºåŸŸRé€šé“å€¼é«˜ã€Bé€šé“å€¼ä½ï¼Œç›¸å‡åçº¢è‰²å‡¸æ˜¾&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ä¼˜ç‚¹&lt;/strong&gt;: é€Ÿåº¦æå¿«ï¼ˆ1-2msï¼‰ï¼Œå®æ—¶æ€§å¥½&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ç¼ºç‚¹&lt;/strong&gt;: æ˜“å—ç¯å¢ƒå…‰å¹²æ‰°ï¼Œéœ€è¦åç»­å¼ºç­›é€‰&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;é€‚ç”¨&lt;/strong&gt;: æ¯”èµ›å®æˆ˜ã€å…‰ç…§ç¨³å®šç¯å¢ƒ&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;è·¯çº¿2: HSVç­›é€‰æ³•&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;åŸç†&lt;/strong&gt;: HSVåˆ†ç¦»äº†é¢œè‰²å’Œäº®åº¦ï¼Œå¯ç²¾ç¡®ç­›é€‰é¢œè‰²èŒƒå›´&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ä¼˜ç‚¹&lt;/strong&gt;: æŠ—å¹²æ‰°èƒ½åŠ›å¼ºï¼Œå‡†ç¡®åº¦é«˜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ç¼ºç‚¹&lt;/strong&gt;: é€Ÿåº¦è¾ƒæ…¢ï¼ˆ5-10msï¼‰ï¼Œå‚æ•°éœ€è°ƒä¼˜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;é€‚ç”¨&lt;/strong&gt;: å¤æ‚å…‰ç…§ã€é«˜ç²¾åº¦éœ€æ±‚&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::split() - åˆ†ç¦»BGRé€šé“&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::split(const Mat&amp;amp; src, Mat* mvbegin);
void cv::split(InputArray src, OutputArrayOfArrays mvs);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ ¸å¿ƒæ¦‚å¿µ&lt;/h3&gt;
&lt;p&gt;OpenCVçš„å½©è‰²å›¾æ˜¯&lt;strong&gt;BGRä¸‰é€šé“&lt;/strong&gt;ï¼ˆä¸æ˜¯RGBï¼ï¼‰ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bé€šé“ (channels[0])&lt;/strong&gt;: è“è‰²åˆ†é‡ (0-255)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gé€šé“ (channels[1])&lt;/strong&gt;: ç»¿è‰²åˆ†é‡ (0-255)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ré€šé“ (channels[2])&lt;/strong&gt;: çº¢è‰²åˆ†é‡ (0-255)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    // åˆ†ç¦»é€šé“
    std::vector&amp;lt;cv::Mat&amp;gt; channels;
    cv::split(img, channels);
    
    // ç°åœ¨ï¼š
    // channels[0] = Bé€šé“ï¼ˆè“è‰²åˆ†é‡ï¼‰
    // channels[1] = Gé€šé“ï¼ˆç»¿è‰²åˆ†é‡ï¼‰
    // channels[2] = Ré€šé“ï¼ˆçº¢è‰²åˆ†é‡ï¼‰
    
    // å¯è§†åŒ–å„é€šé“
    cv::imshow(&quot;Bé€šé“&quot;, channels[0]);
    cv::imshow(&quot;Gé€šé“&quot;, channels[1]);
    cv::imshow(&quot;Ré€šé“&quot;, channels[2]);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é€šé“å«ä¹‰ç†è§£&lt;/h3&gt;
&lt;p&gt;å‡è®¾æœ‰ä¸€ä¸ªåƒç´ çš„BGRå€¼æ˜¯ &lt;code&gt;(50, 100, 200)&lt;/code&gt;ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cv::Vec3b pixel(50, 100, 200);  // (B, G, R)
// B=50:  è“è‰²åˆ†é‡å¾ˆä½
// G=100: ç»¿è‰²åˆ†é‡ä¸­ç­‰
// R=200: çº¢è‰²åˆ†é‡å¾ˆé«˜
// æ‰€ä»¥è¿™ä¸ªåƒç´ æ˜¯ï¼šçº¢è‰²åå¤šçš„æ©™çº¢è‰²
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;è§‚å¯Ÿè§„å¾‹&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;çº¢è‰²ç¯æ¡ï¼šRé€šé“å¾ˆäº®ï¼ŒBé€šé“å¾ˆæš—&lt;/li&gt;
&lt;li&gt;è“è‰²ç¯æ¡ï¼šBé€šé“å¾ˆäº®ï¼ŒRé€šé“å¾ˆæš—&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;2. é€šé“ç›¸å‡æ³•ï¼ˆRMç»å…¸ï¼‰&lt;/h2&gt;
&lt;h3&gt;æå–çº¢è‰²&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);

// åˆ†ç¦»é€šé“
std::vector&amp;lt;cv::Mat&amp;gt; channels;
cv::split(img, channels);

// çº¢è‰² = Ré€šé“ - Bé€šé“
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// äºŒå€¼åŒ–
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);

// æŸ¥çœ‹æ•ˆæœ
cv::imshow(&quot;åŸå›¾&quot;, img);
cv::imshow(&quot;Ré€šé“&quot;, channels[2]);
cv::imshow(&quot;Bé€šé“&quot;, channels[0]);
cv::imshow(&quot;ç›¸å‡ç»“æœ&quot;, red);
cv::imshow(&quot;äºŒå€¼åŒ–&quot;, binary);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æå–è“è‰²&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è“è‰² = Bé€šé“ - Ré€šé“
cv::Mat blue;
cv::subtract(channels[0], channels[2], blue);

cv::Mat binary_blue;
cv::threshold(blue, binary_blue, 100, 255, cv::THRESH_BINARY);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ä¸ºä»€ä¹ˆé€šé“ç›¸å‡æœ‰æ•ˆï¼Ÿ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;åŸç†åˆ†æ&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;åŒºåŸŸç±»å‹&lt;/th&gt;
&lt;th&gt;Rå€¼&lt;/th&gt;
&lt;th&gt;Bå€¼&lt;/th&gt;
&lt;th&gt;R-Bç»“æœ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;çº¢è‰²ç¯æ¡&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;200&lt;/strong&gt; (å¾ˆäº®)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;è“è‰²ç¯æ¡&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;0 (é¥±å’Œåˆ°0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ç™½è‰²åŒºåŸŸ&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;0 (ç›¸äº’æŠµæ¶ˆ)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;é»‘è‰²åŒºåŸŸ&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;0 (éƒ½å¾ˆæš—)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;é€šé“ç›¸å‡åï¼Œ&lt;strong&gt;åªæœ‰çº¢è‰²ç¯æ¡ä¼šä¿ç•™é«˜äº®å€¼&lt;/strong&gt;ï¼&lt;/p&gt;
&lt;h3&gt;é€šé“ç›¸å‡çš„å±€é™æ€§&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// é—®é¢˜1: ç¯å¢ƒä¸­çš„çº¢è‰²ç‰©ä½“ä¹Ÿä¼šè¢«æå–
// æ¯”å¦‚ï¼šçº¢è‰²è¡£æœã€çº¢è‰²æµ·æŠ¥ã€çº¢è‰²ç¯å…‰

// é—®é¢˜2: å…‰ç…§ä¸å‡ä¼šå¯¼è‡´æ¼æ£€
// æš—å¤„çš„çº¢è‰²ç¯æ¡å¯èƒ½ R-B &amp;lt; é˜ˆå€¼

// è§£å†³æ–¹æ¡ˆï¼šéœ€è¦åç»­ç”¨å½¢æ€å­¦+è½®å»“ç­›é€‰æ¥è¿‡æ»¤
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::cvtColor() - é¢œè‰²ç©ºé—´è½¬æ¢&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::cvtColor(InputArray src, OutputArray dst, int code);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å¸¸ç”¨è½¬æ¢ä»£ç &lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;code&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;th&gt;ç”¨é€”&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;COLOR_BGR2GRAY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BGRè½¬ç°åº¦&lt;/td&gt;
&lt;td&gt;ç®€åŒ–å›¾åƒå¤„ç†&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;COLOR_BGR2HSV&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BGRè½¬HSV&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;è£…ç”²æ¿è¯†åˆ«æ ¸å¿ƒ&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;COLOR_BGR2RGB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;BGRè½¬RGB&lt;/td&gt;
&lt;td&gt;ä¸å…¶ä»–åº“å¯¹æ¥&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;COLOR_HSV2BGR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HSVè½¬å›BGR&lt;/td&gt;
&lt;td&gt;è°ƒè¯•å¯è§†åŒ–&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;HSVé¢œè‰²ç©ºé—´è¯¦è§£&lt;/h3&gt;
&lt;p&gt;HSVæŠŠé¢œè‰²åˆ†è§£ä¸º3ä¸ªç»´åº¦ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;H (è‰²è°ƒ Hue): 0-180
â”œâ”€ 0-10:    çº¢è‰²(ç¬¬ä¸€æ®µ)
â”œâ”€ 11-25:   æ©™è‰²
â”œâ”€ 26-34:   é»„è‰²
â”œâ”€ 35-77:   ç»¿è‰²
â”œâ”€ 78-99:   é’è‰²
â”œâ”€ 100-124: è“è‰²  è£…ç”²æ¿è“è‰²
â”œâ”€ 125-155: ç´«è‰²
â””â”€ 170-180: çº¢è‰²(ç¬¬äºŒæ®µ) è£…ç”²æ¿çº¢è‰²

S (é¥±å’Œåº¦ Saturation): 0-255
â”œâ”€ 0-50:   ç°ç™½è‰²ï¼ˆé¢œè‰²ä¸çº¯ï¼‰
â”œâ”€ 50-100: æ·¡è‰²
â””â”€ 100-255: é²œè‰³è‰² ç¯æ¡åœ¨è¿™é‡Œ

V (æ˜åº¦ Value): 0-255
â”œâ”€ 0-50:   é»‘æš—
â”œâ”€ 50-100: æš—æ·¡
â””â”€ 100-255: æ˜äº® ç¯æ¡åœ¨è¿™é‡Œ
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;BGRè½¬HSV&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// æŸ¥çœ‹HSVå„é€šé“
std::vector&amp;lt;cv::Mat&amp;gt; hsv_channels;
cv::split(hsv, hsv_channels);

cv::imshow(&quot;Hé€šé“(è‰²è°ƒ)&quot;, hsv_channels[0]);
cv::imshow(&quot;Sé€šé“(é¥±å’Œåº¦)&quot;, hsv_channels[1]);
cv::imshow(&quot;Vé€šé“(æ˜åº¦)&quot;, hsv_channels[2]);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ä¸ºä»€ä¹ˆHSVæ›´é€‚åˆé¢œè‰²è¯†åˆ«ï¼Ÿ&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;BGRçš„é—®é¢˜&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// äº®çº¢è‰² vs æš—çº¢è‰²ï¼ŒBGRå€¼å·®å¼‚å¤§
äº®çº¢è‰²: (0, 0, 255)
æš—çº¢è‰²: (0, 0, 100)
// ç”¨BGRå¾ˆéš¾ç”¨ä¸€ä¸ªèŒƒå›´åŒæ—¶åŒ…å«å®ƒä»¬

// ä½†åœ¨HSVä¸­ï¼š
äº®çº¢è‰²: (0, 255, 255)  // H=0, S=255, V=255
æš—çº¢è‰²: (0, 255, 100)  // H=0, S=255, V=100
// Hå’ŒSç›¸åŒï¼åªæ˜¯Vä¸åŒï¼Œå¯ä»¥ç”¨ H in [0,10] ç»Ÿä¸€è¯†åˆ«
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::inRange() - é¢œè‰²èŒƒå›´ç­›é€‰&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::inRange(InputArray src, InputArray lowerb, 
                 InputArray upperb, OutputArray dst);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è¯´æ˜&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;src&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¾“å…¥å›¾åƒï¼ˆé€šå¸¸æ˜¯HSVï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lowerb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä¸‹ç•Œï¼ˆScalar(H_min, S_min, V_min)ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;upperb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä¸Šç•Œï¼ˆScalar(H_max, S_max, V_max)ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dst&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¾“å‡ºäºŒå€¼å›¾ï¼ˆåœ¨èŒƒå›´å†…=255ï¼Œå¦åˆ™=0ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;æå–çº¢è‰²ï¼ˆå®Œæ•´ç‰ˆï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);
cv::Mat hsv;
cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);

// çº¢è‰²çš„Hå€¼è·¨è¶Šäº†0-180çš„è¾¹ç•Œï¼éœ€è¦åˆ†ä¸¤æ®µ
// ç¬¬ä¸€æ®µ: H=0-10
cv::Scalar lower_red1(0, 100, 100);    // (H, S, V)
cv::Scalar upper_red1(10, 255, 255);

// ç¬¬äºŒæ®µ: H=170-180
cv::Scalar lower_red2(170, 100, 100);
cv::Scalar upper_red2(180, 255, 255);

// åˆ†åˆ«æå–ä¸¤æ®µ
cv::Mat mask1, mask2, red_mask;
cv::inRange(hsv, lower_red1, upper_red1, mask1);
cv::inRange(hsv, lower_red2, upper_red2, mask2);

// åˆå¹¶ä¸¤æ®µï¼ˆä½è¿ç®—ï¼šæˆ–ï¼‰
cv::bitwise_or(mask1, mask2, red_mask);

// æŸ¥çœ‹æ•ˆæœ
cv::imshow(&quot;åŸå›¾&quot;, img);
cv::imshow(&quot;mask1 (H=0-10)&quot;, mask1);
cv::imshow(&quot;mask2 (H=170-180)&quot;, mask2);
cv::imshow(&quot;æœ€ç»ˆçº¢è‰²mask&quot;, red_mask);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æå–è“è‰²&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è“è‰²åªéœ€è¦ä¸€æ®µ
cv::Scalar lower_blue(100, 100, 100);  // H=100-130
cv::Scalar upper_blue(130, 255, 255);

cv::Mat blue_mask;
cv::inRange(hsv, lower_blue, upper_blue, blue_mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è°ƒä¼˜æŠ€å·§&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;åˆ›å»ºæ»‘å—å®æ—¶è°ƒå‚&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

// å…¨å±€å˜é‡
int h_min = 0, h_max = 10;
int s_min = 100, s_max = 255;
int v_min = 100, v_max = 255;

void on_trackbar(int, void*) {
    // å›è°ƒå‡½æ•°ï¼Œæ¯æ¬¡æ»‘å—å˜åŒ–æ—¶è°ƒç”¨
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // åˆ›å»ºçª—å£
    cv::namedWindow(&quot;è°ƒå‚&quot;);
    
    // åˆ›å»ºæ»‘å—
    cv::createTrackbar(&quot;H min&quot;, &quot;è°ƒå‚&quot;, &amp;amp;h_min, 180, on_trackbar);
    cv::createTrackbar(&quot;H max&quot;, &quot;è°ƒå‚&quot;, &amp;amp;h_max, 180, on_trackbar);
    cv::createTrackbar(&quot;S min&quot;, &quot;è°ƒå‚&quot;, &amp;amp;s_min, 255, on_trackbar);
    cv::createTrackbar(&quot;S max&quot;, &quot;è°ƒå‚&quot;, &amp;amp;s_max, 255, on_trackbar);
    cv::createTrackbar(&quot;V min&quot;, &quot;è°ƒå‚&quot;, &amp;amp;v_min, 255, on_trackbar);
    cv::createTrackbar(&quot;V max&quot;, &quot;è°ƒå‚&quot;, &amp;amp;v_max, 255, on_trackbar);
    
    while (true) {
        cv::Scalar lower(h_min, s_min, v_min);
        cv::Scalar upper(h_max, s_max, v_max);
        
        cv::Mat mask;
        cv::inRange(hsv, lower, upper, mask);
        
        cv::imshow(&quot;åŸå›¾&quot;, img);
        cv::imshow(&quot;mask&quot;, mask);
        
        if (cv::waitKey(30) == 27) break;
    }
    
    // æ‰“å°æœ€ç»ˆå‚æ•°
    std::cout &amp;lt;&amp;lt; &quot;æœ€ä¼˜å‚æ•°:&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;lower: (&quot; &amp;lt;&amp;lt; h_min &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; s_min &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; v_min &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;upper: (&quot; &amp;lt;&amp;lt; h_max &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; s_max &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; v_max &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ¨èå‚æ•°èŒƒå›´&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;é¢œè‰²&lt;/th&gt;
&lt;th&gt;HèŒƒå›´&lt;/th&gt;
&lt;th&gt;SèŒƒå›´&lt;/th&gt;
&lt;th&gt;VèŒƒå›´&lt;/th&gt;
&lt;th&gt;å¤‡æ³¨&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;çº¢è‰²&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0-10, 170-180&lt;/td&gt;
&lt;td&gt;100-255&lt;/td&gt;
&lt;td&gt;100-255&lt;/td&gt;
&lt;td&gt;ä¸¤æ®µåˆå¹¶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;è“è‰²&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;100-130&lt;/td&gt;
&lt;td&gt;100-255&lt;/td&gt;
&lt;td&gt;100-255&lt;/td&gt;
&lt;td&gt;å•æ®µå³å¯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ç™½è‰²&lt;/td&gt;
&lt;td&gt;ä»»æ„&lt;/td&gt;
&lt;td&gt;0-30&lt;/td&gt;
&lt;td&gt;200-255&lt;/td&gt;
&lt;td&gt;ä½é¥±å’Œåº¦+é«˜äº®åº¦&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;é»‘è‰²&lt;/td&gt;
&lt;td&gt;ä»»æ„&lt;/td&gt;
&lt;td&gt;ä»»æ„&lt;/td&gt;
&lt;td&gt;0-50&lt;/td&gt;
&lt;td&gt;åªçœ‹äº®åº¦&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;è¿™äº›å‚æ•°ä¸æ˜¯å›ºå®šçš„ï¼&lt;/strong&gt; éœ€è¦æ ¹æ®ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ç›¸æœºå‹å·&lt;/li&gt;
&lt;li&gt;å…‰ç…§æ¡ä»¶&lt;/li&gt;
&lt;li&gt;ç¯æ¡äº®åº¦
å®é™…è°ƒæ•´ï¼&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::threshold() - ç®€å•é˜ˆå€¼äºŒå€¼åŒ–&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;double cv::threshold(InputArray src, OutputArray dst, 
                     double thresh, double maxval, int type);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å¸¸ç”¨ç±»å‹&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;th&gt;å…¬å¼&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;THRESH_BINARY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ ‡å‡†äºŒå€¼åŒ–&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pixel &amp;gt; thresh ? maxval : 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;THRESH_BINARY_INV&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;åå‘äºŒå€¼åŒ–&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pixel &amp;gt; thresh ? 0 : maxval&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;THRESH_TRUNC&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æˆªæ–­&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pixel &amp;gt; thresh ? thresh : pixel&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;THRESH_TOZERO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä½äºé˜ˆå€¼å½’é›¶&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pixel &amp;gt; thresh ? pixel : 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;é…åˆé€šé“ç›¸å‡ä½¿ç”¨&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// æå–çº¢è‰²
cv::Mat red;
cv::subtract(channels[2], channels[0], red);

// é˜ˆå€¼äºŒå€¼åŒ–
cv::Mat binary;
cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
// åƒç´  &amp;gt; 100 â†’ 255(ç™½)
// åƒç´  &amp;lt;= 100 â†’ 0(é»‘)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ğŸ’» è‡ªé€‚åº”é˜ˆå€¼ï¼ˆåº”å¯¹å…‰ç…§ä¸å‡ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

cv::Mat adaptive;
cv::adaptiveThreshold(gray, adaptive, 255,
                      cv::ADAPTIVE_THRESH_GAUSSIAN_C,
                      cv::THRESH_BINARY, 11, 2);
// blockSize=11: é‚»åŸŸå¤§å°
// C=2: å¸¸æ•°è°ƒæ•´å€¼
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. cv::bitwise ä½è¿ç®—&lt;/h2&gt;
&lt;h3&gt;å¸¸ç”¨å‡½æ•°&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::bitwise_or(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_and(InputArray src1, InputArray src2, OutputArray dst);
void cv::bitwise_not(InputArray src, OutputArray dst);
void cv::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åˆå¹¶å¤šä¸ªmask&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// çº¢è‰²æœ‰ä¸¤æ®µï¼Œéœ€è¦åˆå¹¶
cv::Mat red_mask1, red_mask2, red_final;
cv::inRange(hsv, lower_red1, upper_red1, red_mask1);
cv::inRange(hsv, lower_red2, upper_red2, red_mask2);
cv::bitwise_or(red_mask1, red_mask2, red_final);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æå–åŒæ—¶æ»¡è¶³å¤šä¸ªæ¡ä»¶çš„åŒºåŸŸ&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åŒæ—¶æ˜¯çº¢è‰² ä¸” äº®åº¦å¾ˆé«˜
cv::Mat color_mask, brightness_mask, final_mask;
cv::inRange(hsv, lower_red, upper_red, color_mask);
cv::threshold(hsv_channels[2], brightness_mask, 200, 255, cv::THRESH_BINARY);
cv::bitwise_and(color_mask, brightness_mask, final_mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åè½¬mask&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat mask, inverted;
cv::inRange(hsv, lower, upper, mask);
cv::bitwise_not(mask, inverted);  // é»‘ç™½åè½¬
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å®Œæ•´å®æˆ˜ä»£ç &lt;/h2&gt;
&lt;h3&gt;æ–¹æ¡ˆ1: é€šé“ç›¸å‡æ³•ï¼ˆå¿«é€Ÿï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat extractRedFast(const cv::Mat&amp;amp; img) {
    std::vector&amp;lt;cv::Mat&amp;gt; channels;
    cv::split(img, channels);
    
    // R - B
    cv::Mat red;
    cv::subtract(channels[2], channels[0], red);
    
    // äºŒå€¼åŒ–
    cv::Mat binary;
    cv::threshold(red, binary, 100, 255, cv::THRESH_BINARY);
    
    return binary;
}

int main() {
    cv::Mat img = cv::imread(&quot;red_armor.jpg&quot;);
    cv::Mat binary = extractRedFast(img);
    
    cv::imshow(&quot;åŸå›¾&quot;, img);
    cv::imshow(&quot;çº¢è‰²æå–&quot;, binary);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ–¹æ¡ˆ2: HSVç­›é€‰æ³•ï¼ˆç²¾ç¡®ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

cv::Mat extractRedAccurate(const cv::Mat&amp;amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // çº¢è‰²ä¸¤æ®µ
    cv::Scalar lower1(0, 100, 100);
    cv::Scalar upper1(10, 255, 255);
    cv::Scalar lower2(170, 100, 100);
    cv::Scalar upper2(180, 255, 255);
    
    cv::Mat mask1, mask2, mask;
    cv::inRange(hsv, lower1, upper1, mask1);
    cv::inRange(hsv, lower2, upper2, mask2);
    cv::bitwise_or(mask1, mask2, mask);
    
    return mask;
}

cv::Mat extractBlue(const cv::Mat&amp;amp; img) {
    cv::Mat hsv;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    cv::Scalar lower(100, 100, 100);
    cv::Scalar upper(130, 255, 255);
    
    cv::Mat mask;
    cv::inRange(hsv, lower, upper, mask);
    
    return mask;
}

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    cv::Mat red_mask = extractRedAccurate(img);
    cv::Mat blue_mask = extractBlue(img);
    
    cv::imshow(&quot;åŸå›¾&quot;, img);
    cv::imshow(&quot;çº¢è‰²mask&quot;, red_mask);
    cv::imshow(&quot;è“è‰²mask&quot;, blue_mask);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å¸¸è§é—®é¢˜æ’æŸ¥&lt;/h2&gt;
&lt;h3&gt;é—®é¢˜1: æå–ä¸å‡ºé¢œè‰²&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// æ£€æŸ¥æ¸…å•ï¼š
// 1. ç¡®è®¤å›¾åƒä¸æ˜¯ç©ºçš„
if (img.empty()) return;

// 2. æ‰“å°HSVå€¼çœ‹çœ‹èŒƒå›´å¯¹ä¸å¯¹
cv::Vec3b pixel = hsv.at&amp;lt;cv::Vec3b&amp;gt;(y, x);  // ç‚¹å‡»ç¯æ¡ä½ç½®
std::cout &amp;lt;&amp;lt; &quot;H=&quot; &amp;lt;&amp;lt; (int)pixel[0] 
          &amp;lt;&amp;lt; &quot; S=&quot; &amp;lt;&amp;lt; (int)pixel[1] 
          &amp;lt;&amp;lt; &quot; V=&quot; &amp;lt;&amp;lt; (int)pixel[2] &amp;lt;&amp;lt; std::endl;

// 3. ç”¨æ»‘å—è°ƒå‚
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜2: æå–å‡ºå¤ªå¤šæ‚è‰²&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è§£å†³æ–¹æ¡ˆï¼š
// 1. æé«˜Så’ŒVçš„ä¸‹é™ï¼ˆåªè¦é²œè‰³+æ˜äº®çš„ï¼‰
cv::Scalar lower(0, 150, 150);  // æé«˜S_minå’ŒV_min

// 2. åç»­ç”¨å½¢æ€å­¦é™å™ª
// 3. è½®å»“ç­›é€‰æ—¶è¿‡æ»¤å°é¢ç§¯
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜3: çº¢è‰²åªæ£€æµ‹åˆ°ä¸€åŠ&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// åŸå› ï¼šå¿˜è®°åˆå¹¶çº¢è‰²çš„ä¸¤æ®µ
// è§£å†³ï¼š
cv::bitwise_or(mask1, mask2, final_mask);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;æ£€æŸ¥æ¸…å•&lt;/h2&gt;
&lt;p&gt;å®Œæˆæœ¬é˜¶æ®µåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] ç†è§£BGRå’ŒHSVçš„åŒºåˆ«&lt;/li&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::split()&lt;/code&gt; åˆ†ç¦»é€šé“å¹¶è®¡ç®— R-B&lt;/li&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::inRange()&lt;/code&gt; æå–çº¢è‰²/è“è‰²&lt;/li&gt;
&lt;li&gt;[ ] çŸ¥é“çº¢è‰²éœ€è¦ä¸¤æ®µèŒƒå›´åˆå¹¶&lt;/li&gt;
&lt;li&gt;[ ] èƒ½ç”¨æ»‘å—è°ƒè¯•HSVå‚æ•°&lt;/li&gt;
&lt;li&gt;[ ] ç†è§£é€šé“ç›¸å‡æ³•å’ŒHSVæ³•çš„ä¼˜åŠ£&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RMè£…ç”²æ¿è¯†åˆ« - 04 è½®å»“æ£€æµ‹</title><link>https://www.nanye404.top/posts/rm_opencv_04/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_04/</guid><description>æ— </description><pubDate>Fri, 24 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;ğŸ“š æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;ä½œç”¨&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::findContours()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æŸ¥æ‰¾è½®å»“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::contourArea()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è®¡ç®—è½®å»“é¢ç§¯&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::minAreaRect()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æœ€å°æ—‹è½¬çŸ©å½¢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::RotatedRect&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ—‹è½¬çŸ©å½¢ç±»&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::drawContours()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ç»˜åˆ¶è½®å»“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::boundingRect()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ­£çŸ©å½¢åŒ…å›´æ¡†&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::fitEllipse()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ¤­åœ†æ‹Ÿåˆ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;æ ¸å¿ƒæ€è·¯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ç»è¿‡å½¢æ€å­¦å¤„ç†åï¼ŒäºŒå€¼å›¾å·²ç»å¾ˆå¹²å‡€ï¼š&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ç°åœ¨è¦åšçš„æ˜¯ï¼š&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;æ‰¾è½®å»“&lt;/strong&gt; - æŠŠæ¯ä¸ªç™½è‰²åŒºåŸŸçš„è¾¹ç•Œæ‰¾å‡ºæ¥&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;æ‹ŸåˆçŸ©å½¢&lt;/strong&gt; - ç”¨æ—‹è½¬çŸ©å½¢æè¿°æ¯ä¸ªè½®å»“&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ç­›é€‰ç¯æ¡&lt;/strong&gt; - æ ¹æ®é•¿å®½æ¯”ã€é¢ç§¯ã€è§’åº¦ç­‰ç‰¹å¾è¿‡æ»¤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::findContours() - æŸ¥æ‰¾è½®å»“&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::findContours(InputOutputArray image, 
                      OutputArrayOfArrays contours,
                      int mode, int method, 
                      Point offset = Point());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è¯¦è§£&lt;/h3&gt;
&lt;h4&gt;mode - è½®å»“æ£€ç´¢æ¨¡å¼&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;mode&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;th&gt;ç”¨é€”&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_EXTERNAL&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;åªæ£€æµ‹æœ€å¤–å±‚è½®å»“&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RMæ¨è&lt;/strong&gt;ï¼Œå¿½ç•¥å†…éƒ¨å­”æ´&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_LIST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ£€æµ‹æ‰€æœ‰è½®å»“ï¼Œä¸å»ºç«‹å±‚çº§&lt;/td&gt;
&lt;td&gt;å½“éœ€è¦æ‰€æœ‰è½®å»“æ—¶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_TREE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ£€æµ‹æ‰€æœ‰å¹¶å»ºç«‹å®Œæ•´å±‚çº§æ ‘&lt;/td&gt;
&lt;td&gt;å¤æ‚åµŒå¥—ç»“æ„&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RETR_CCOMP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä¸¤å±‚å±‚çº§ï¼ˆå¤–è½®å»“å’Œå­”ï¼‰&lt;/td&gt;
&lt;td&gt;è¾ƒå°‘ä½¿ç”¨&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;method - è½®å»“è¿‘ä¼¼æ–¹æ³•&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;method&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;th&gt;ä¼˜ç¼ºç‚¹&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CHAIN_APPROX_NONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä¿å­˜æ‰€æœ‰è½®å»“ç‚¹&lt;/td&gt;
&lt;td&gt;ç²¾ç¡®ä½†å å†…å­˜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CHAIN_APPROX_SIMPLE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;å‹ç¼©è½®å»“ï¼Œåªä¿ç•™å…³é”®ç‚¹&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;RMæ¨è&lt;/strong&gt;ï¼ŒèŠ‚çœå†…å­˜&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

int main() {
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    
    // è·å–äºŒå€¼å›¾ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = processImage(img);
    
    // æŸ¥æ‰¾è½®å»“
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, 
                     cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &amp;lt;&amp;lt; &quot;æ‰¾åˆ° &quot; &amp;lt;&amp;lt; contours.size() &amp;lt;&amp;lt; &quot; ä¸ªè½®å»“&quot; &amp;lt;&amp;lt; std::endl;
    
    // éå†æ‰€æœ‰è½®å»“
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        std::cout &amp;lt;&amp;lt; &quot;è½®å»“ &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; æœ‰ &quot; &amp;lt;&amp;lt; contours[i].size() 
                  &amp;lt;&amp;lt; &quot; ä¸ªç‚¹&quot; &amp;lt;&amp;lt; std::endl;
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é‡è¦æ³¨æ„äº‹é¡¹&lt;/h3&gt;
&lt;h4&gt;æ³¨æ„1: findContoursä¼šä¿®æ”¹è¾“å…¥å›¾åƒï¼&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//  é”™è¯¯ï¼šåŸå§‹binaryè¢«ä¿®æ”¹äº†
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

//  æ­£ç¡®ï¼šä¼ å…¥å‰¯æœ¬
cv::Mat binary_copy = binary.clone();
cv::findContours(binary_copy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// æˆ–è€…ç›´æ¥åœ¨ä¸´æ—¶å¯¹è±¡ä¸Šè°ƒç”¨
cv::findContours(binary.clone(), contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;æ³¨æ„2: è¾“å…¥å¿…é¡»æ˜¯äºŒå€¼å›¾&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;//  é”™è¯¯ï¼šå½©è‰²å›¾ä¸è¡Œ
cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
cv::findContours(img, contours, ...);  //  ç»“æœä¸å¯¹

//  æ­£ç¡®ï¼šå¿…é¡»æ˜¯äºŒå€¼å›¾ï¼ˆ0æˆ–255ï¼‰
cv::Mat binary;
cv::threshold(gray, binary, 128, 255, cv::THRESH_BINARY);
cv::findContours(binary, contours, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;2. è½®å»“æ•°æ®ç»“æ„ç†è§£&lt;/h2&gt;
&lt;h3&gt;è½®å»“çš„æœ¬è´¨&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è½®å»“ = ç‚¹çš„é›†åˆ
std::vector&amp;lt;cv::Point&amp;gt; contour = contours[0];

// æ¯ä¸ªç‚¹æ˜¯(x, y)åæ ‡
cv::Point p = contour[0];
std::cout &amp;lt;&amp;lt; &quot;ç¬¬ä¸€ä¸ªç‚¹: (&quot; &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; p.y &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è½®å»“æ“ä½œç¤ºä¾‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// è½®å»“æ•°é‡
int num = contours.size();

// ç¬¬iä¸ªè½®å»“çš„ç‚¹æ•°
int pointCount = contours[i].size();

// è®¿é—®ç¬¬iä¸ªè½®å»“çš„ç¬¬jä¸ªç‚¹
cv::Point p = contours[i][j];
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::contourArea() - è®¡ç®—è½®å»“é¢ç§¯&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;double cv::contourArea(InputArray contour, bool oriented = false);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    std::cout &amp;lt;&amp;lt; &quot;è½®å»“é¢ç§¯: &quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot; åƒç´ &quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ç”¨äºè¿‡æ»¤å™ªç‚¹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; validContours;

for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    
    // è¿‡æ»¤å¤ªå°çš„è½®å»“ï¼ˆå™ªç‚¹ï¼‰
    if (area &amp;lt; 100) continue;
    
    // è¿‡æ»¤å¤ªå¤§çš„è½®å»“ï¼ˆå¯èƒ½æ˜¯æ•´ä¸ªè£…ç”²æ¿æˆ–èƒŒæ™¯ï¼‰
    if (area &amp;gt; 10000) continue;
    
    // ä¿ç•™åˆç†å¤§å°çš„è½®å»“
    validContours.push_back(contour);
}

std::cout &amp;lt;&amp;lt; &quot;è¿‡æ»¤åå‰©ä½™ &quot; &amp;lt;&amp;lt; validContours.size() &amp;lt;&amp;lt; &quot; ä¸ªè½®å»“&quot; &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é¢ç§¯é˜ˆå€¼å¦‚ä½•é€‰æ‹©ï¼Ÿ&lt;/h3&gt;
&lt;p&gt;è¿™å–å†³äºï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;å›¾åƒåˆ†è¾¨ç‡&lt;/strong&gt; - 1920Ã—1080 vs 640Ã—480&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;è£…ç”²æ¿è·ç¦»&lt;/strong&gt; - è¿‘è·ç¦»ç¯æ¡å¤§ï¼Œè¿œè·ç¦»ç¯æ¡å°&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ç›¸æœºFOV&lt;/strong&gt; - è§†åœºè§’å¤§å°&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;æ¨èæ–¹æ³•&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// æ ¹æ®å›¾åƒå¤§å°è‡ªé€‚åº”
int imageArea = binary.rows * binary.cols;
double minArea = imageArea * 0.0001;  // 0.01%
double maxArea = imageArea * 0.05;    // 5%

for (const auto&amp;amp; contour : contours) {
    double area = cv::contourArea(contour);
    if (area &amp;gt; minArea &amp;amp;&amp;amp; area &amp;lt; maxArea) {
        // åˆç†èŒƒå›´
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::minAreaRect() - æœ€å°æ—‹è½¬çŸ©å½¢&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RotatedRect cv::minAreaRect(InputArray points);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ä¸ºä»€ä¹ˆç”¨æ—‹è½¬çŸ©å½¢ï¼Ÿ&lt;/h3&gt;
&lt;p&gt;ç¯æ¡é€šå¸¸æ˜¯&lt;strong&gt;å€¾æ–œ&lt;/strong&gt;çš„ï¼Œæ™®é€šçŸ©å½¢æ— æ³•å‡†ç¡®æè¿°ï¼š&lt;/p&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    // æ‹Ÿåˆæœ€å°æ—‹è½¬çŸ©å½¢
    cv::RotatedRect rect = cv::minAreaRect(contour);
    
    // è·å–çŸ©å½¢ä¿¡æ¯
    cv::Point2f center = rect.center;      // ä¸­å¿ƒç‚¹
    cv::Size2f size = rect.size;           // å°ºå¯¸(width, height)
    float angle = rect.angle;              // æ—‹è½¬è§’åº¦(-90åˆ°0)
    
    std::cout &amp;lt;&amp;lt; &quot;ä¸­å¿ƒ: (&quot; &amp;lt;&amp;lt; center.x &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; center.y &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;å°ºå¯¸: &quot; &amp;lt;&amp;lt; size.width &amp;lt;&amp;lt; &quot; Ã— &quot; &amp;lt;&amp;lt; size.height &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;è§’åº¦: &quot; &amp;lt;&amp;lt; angle &amp;lt;&amp;lt; &quot;Â°&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::RotatedRect ç±»è¯¦è§£&lt;/h2&gt;
&lt;h3&gt;æ ¸å¿ƒå±æ€§&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

// ä¸­å¿ƒç‚¹
cv::Point2f center = rect.center;  // çŸ©å½¢ä¸­å¿ƒçš„(x,y)åæ ‡

// å°ºå¯¸
cv::Size2f size = rect.size;       // width Ã— height
float width = size.width;
float height = size.height;

// æ—‹è½¬è§’åº¦
float angle = rect.angle;          // èŒƒå›´: -90Â° ~ 0Â°
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;angleçš„é™·é˜±&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OpenCVçš„angleå®šä¹‰å¾ˆåç›´è§‰ï¼&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// angleçš„å«ä¹‰ï¼š
// ä»æ°´å¹³æ–¹å‘é€†æ—¶é’ˆæ—‹è½¬åˆ°çŸ©å½¢é•¿è¾¹çš„è§’åº¦
// èŒƒå›´ï¼š-90Â° åˆ° 0Â°

// ä¾‹å­ï¼š
angle = -90Â°  â†’ çŸ©å½¢å‚ç›´ï¼ˆç«–ç€ï¼‰
angle = -45Â°  â†’ çŸ©å½¢å€¾æ–œ45åº¦
angle = 0Â°    â†’ çŸ©å½¢æ°´å¹³ï¼ˆæ¨ªç€ï¼‰
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ç¡®ä¿heightæ˜¯é•¿è¾¹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

float width = rect.size.width;
float height = rect.size.height;

//  OpenCVä¸ä¿è¯height &amp;gt; widthï¼
// éœ€è¦æ‰‹åŠ¨è°ƒæ•´
if (width &amp;gt; height) {
    std::swap(width, height);
    // å¦‚æœéœ€è¦ï¼Œä¹Ÿå¯ä»¥è°ƒæ•´angle
}

// ç°åœ¨ height ä¸€å®šæ˜¯é•¿è¾¹
float aspectRatio = height / width;  // é•¿å®½æ¯”
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è·å–å››ä¸ªé¡¶ç‚¹åæ ‡&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::RotatedRect rect = cv::minAreaRect(contour);

// è·å–å››ä¸ªé¡¶ç‚¹
cv::Point2f vertices[4];
rect.points(vertices);

// vertices[0], vertices[1], vertices[2], vertices[3]
// æŒ‰é€†æ—¶é’ˆé¡ºåºæ’åˆ—

// ç»˜åˆ¶æ—‹è½¬çŸ©å½¢
for (int i = 0; i &amp;lt; 4; i++) {
    cv::line(img, vertices[i], vertices[(i+1)%4], 
             cv::Scalar(0, 255, 0), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. ç¯æ¡ç‰¹å¾ç­›é€‰ï¼ˆæ ¸å¿ƒï¼‰&lt;/h2&gt;
&lt;h3&gt;ç¯æ¡çš„å…¸å‹ç‰¹å¾&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ç‰¹å¾&lt;/th&gt;
&lt;th&gt;åˆç†èŒƒå›´&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;é•¿å®½æ¯”&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2.0 ~ 10.0&lt;/td&gt;
&lt;td&gt;ç¯æ¡æ˜¯ç»†é•¿çš„&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;é¢ç§¯&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;100 ~ 5000åƒç´ &lt;/td&gt;
&lt;td&gt;æ ¹æ®åˆ†è¾¨ç‡è°ƒæ•´&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;è§’åº¦&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;æ¥è¿‘å‚ç›´&lt;/td&gt;
&lt;td&gt;é€šå¸¸åœ¨Â±30Â°å†…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;å¡«å……åº¦&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;gt; 0.5&lt;/td&gt;
&lt;td&gt;è½®å»“é¢ç§¯/å¤–æ¥çŸ©å½¢é¢ç§¯&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;å®Œæ•´ç­›é€‰ä»£ç &lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;

struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    float angle;
};

std::vector&amp;lt;LightBar&amp;gt; detectLightBars(const cv::Mat&amp;amp; binary) {
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::vector&amp;lt;LightBar&amp;gt; lightBars;
    
    for (const auto&amp;amp; contour : contours) {
        // 1. é¢ç§¯ç­›é€‰
        double area = cv::contourArea(contour);
        if (area &amp;lt; 100 || area &amp;gt; 5000) continue;
        
        // 2. æ‹Ÿåˆæ—‹è½¬çŸ©å½¢
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // 3. ç¡®ä¿heightæ˜¯é•¿è¾¹
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &amp;gt; height) {
            std::swap(width, height);
        }
        
        // 4. é•¿å®½æ¯”ç­›é€‰
        float aspectRatio = height / width;
        if (aspectRatio &amp;lt; 2.0 || aspectRatio &amp;gt; 10.0) continue;
        
        // 5. è§’åº¦ç­›é€‰ï¼ˆå¯é€‰ï¼Œæ ¹æ®å®é™…æƒ…å†µï¼‰
        // ç¯æ¡åº”è¯¥æ¥è¿‘å‚ç›´
        float angle = std::abs(rect.angle);
        if (angle &amp;gt; 30 &amp;amp;&amp;amp; angle &amp;lt; 60) continue;  // å¤ªæ–œçš„æ’é™¤
        
        // 6. å¡«å……åº¦ç­›é€‰ï¼ˆå¯é€‰ï¼‰
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &amp;lt; 0.5) continue;  // å¤ªç©ºçš„ä¸æ˜¯ç¯æ¡
        
        // é€šè¿‡æ‰€æœ‰ç­›é€‰ï¼Œä¿å­˜
        LightBar bar;
        bar.rect = rect;
        bar.area = area;
        bar.aspectRatio = aspectRatio;
        bar.angle = angle;
        lightBars.push_back(bar);
    }
    
    std::cout &amp;lt;&amp;lt; &quot;æ‰¾åˆ° &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; &quot; ä¸ªç¯æ¡&quot; &amp;lt;&amp;lt; std::endl;
    return lightBars;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ç­›é€‰æ•ˆæœå±•ç¤º&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// å‡è®¾æ‰¾åˆ°20ä¸ªè½®å»“ï¼š

è½®å»“1: é¢ç§¯=50      å¤ªå°ï¼Œè¿‡æ»¤
è½®å»“2: é¢ç§¯=800    é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=5.2    é€šè¿‡é•¿å®½æ¯”
       å¡«å……åº¦=0.8  é€šè¿‡å¡«å……åº¦
       ç»“æœ: ç¯æ¡å€™é€‰1 

è½®å»“3: é¢ç§¯=1200     é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=1.1   å¤ªçŸ®ï¼Œè¿‡æ»¤

è½®å»“4: é¢ç§¯=900      é€šè¿‡é¢ç§¯
       é•¿å®½æ¯”=4.8    é€šè¿‡é•¿å®½æ¯”
       å¡«å……åº¦=0.3   å¤ªç©ºï¼Œè¿‡æ»¤

...

æœ€ç»ˆ: æ‰¾åˆ°4ä¸ªç¯æ¡ï¼ˆ2å¯¹è£…ç”²æ¿ï¼‰
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;7. cv::drawContours() - ç»˜åˆ¶è½®å»“ï¼ˆè°ƒè¯•ï¼‰&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::drawContours(InputOutputArray image,
                      InputArrayOfArrays contours,
                      int contourIdx, 
                      const Scalar&amp;amp; color,
                      int thickness = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat display = img.clone();

// ç»˜åˆ¶æ‰€æœ‰è½®å»“
cv::drawContours(display, contours, -1, cv::Scalar(0, 255, 0), 2);
// -1 è¡¨ç¤ºç»˜åˆ¶æ‰€æœ‰è½®å»“

// ç»˜åˆ¶ç¬¬iä¸ªè½®å»“
cv::drawContours(display, contours, i, cv::Scalar(255, 0, 0), 2);

// å¡«å……è½®å»“
cv::drawContours(display, contours, i, cv::Scalar(0, 0, 255), -1);
// thickness=-1 è¡¨ç¤ºå¡«å……
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å½©è‰²è°ƒè¯•å¯è§†åŒ–&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void visualizeContours(const cv::Mat&amp;amp; img, 
                       const std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt;&amp;amp; contours) {
    cv::Mat display = img.clone();
    
    // ä¸ºæ¯ä¸ªè½®å»“éšæœºé¢œè‰²
    cv::RNG rng(12345);
    
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        cv::Scalar color(rng.uniform(0, 256), 
                        rng.uniform(0, 256), 
                        rng.uniform(0, 256));
        
        // ç»˜åˆ¶è½®å»“
        cv::drawContours(display, contours, i, color, 2);
        
        // æ ‡æ³¨åºå·
        cv::Moments m = cv::moments(contours[i]);
        cv::Point2f center(m.m10/m.m00, m.m01/m.m00);
        cv::putText(display, std::to_string(i), center,
                    cv::FONT_HERSHEY_SIMPLEX, 0.5, color, 2);
    }
    
    cv::imshow(&quot;è½®å»“å¯è§†åŒ–&quot;, display);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;8. ç»˜åˆ¶æ—‹è½¬çŸ©å½¢&lt;/h2&gt;
&lt;h3&gt;æ ‡å‡†æ–¹æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawRotatedRect(cv::Mat&amp;amp; img, const cv::RotatedRect&amp;amp; rect, 
                     const cv::Scalar&amp;amp; color, int thickness = 2) {
    cv::Point2f vertices[4];
    rect.points(vertices);
    
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], color, thickness);
    }
}

// ä½¿ç”¨
for (const auto&amp;amp; bar : lightBars) {
    drawRotatedRect(display, bar.rect, cv::Scalar(0, 255, 0), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ğŸ¨ å¢å¼ºç‰ˆï¼ˆå¸¦ä¸­å¿ƒç‚¹å’Œæ–‡å­—ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void drawLightBar(cv::Mat&amp;amp; img, const LightBar&amp;amp; bar, int id) {
    // ç»˜åˆ¶æ—‹è½¬çŸ©å½¢
    cv::Point2f vertices[4];
    bar.rect.points(vertices);
    for (int i = 0; i &amp;lt; 4; i++) {
        cv::line(img, vertices[i], vertices[(i+1)%4], 
                 cv::Scalar(0, 255, 0), 2);
    }
    
    // ç»˜åˆ¶ä¸­å¿ƒç‚¹
    cv::circle(img, bar.rect.center, 5, cv::Scalar(0, 0, 255), -1);
    
    // æ ‡æ³¨ä¿¡æ¯
    std::string text = &quot;ID:&quot; + std::to_string(id) + 
                       &quot; R:&quot; + std::to_string((int)bar.aspectRatio);
    cv::putText(img, text, 
                cv::Point(bar.rect.center.x + 10, bar.rect.center.y),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, 
                cv::Scalar(255, 255, 255), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;9. cv::boundingRect() - æ­£çŸ©å½¢åŒ…å›´æ¡†&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Rect cv::boundingRect(InputArray points);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    // è·å–æ­£çŸ©å½¢ï¼ˆæ°´å¹³/å‚ç›´è¾¹ï¼‰
    cv::Rect bbox = cv::boundingRect(contour);
    
    // ç»˜åˆ¶
    cv::rectangle(img, bbox, cv::Scalar(255, 0, 0), 2);
    
    // è£å‰ªROI
    cv::Mat roi = img(bbox);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ­£çŸ©å½¢ vs æ—‹è½¬çŸ©å½¢&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Rect bbox = cv::boundingRect(contour);         // æ­£çŸ©å½¢
cv::RotatedRect rect = cv::minAreaRect(contour);   // æ—‹è½¬çŸ©å½¢

// æ­£çŸ©å½¢ï¼šè¾¹å¹³è¡Œäºåæ ‡è½´ï¼Œé¢ç§¯å¯èƒ½è¾ƒå¤§
// æ—‹è½¬çŸ©å½¢ï¼šæœ€å°é¢ç§¯ï¼Œä½†è¾¹å¯èƒ½å€¾æ–œ

// ç”¨é€”ï¼š
// - æ­£çŸ©å½¢ï¼šè£å‰ªROIã€å¿«é€Ÿç¢°æ’æ£€æµ‹
// - æ—‹è½¬çŸ©å½¢ï¼šç²¾ç¡®æè¿°ç¯æ¡å½¢çŠ¶å’Œè§’åº¦
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;10. cv::fitEllipse() - æ¤­åœ†æ‹Ÿåˆï¼ˆèƒ½é‡æœºå…³ç”¨ï¼‰&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;RotatedRect cv::fitEllipse(InputArray points);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (const auto&amp;amp; contour : contours) {
    // è‡³å°‘éœ€è¦5ä¸ªç‚¹
    if (contour.size() &amp;lt; 5) continue;
    
    // æ‹Ÿåˆæ¤­åœ†
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // ç»˜åˆ¶æ¤­åœ†
    cv::ellipse(img, ellipse, cv::Scalar(0, 255, 255), 2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;èƒ½é‡æœºå…³æ‰‡å¶è¯†åˆ«&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// èƒ½é‡æœºå…³çš„Ræ ‡æ˜¯æ¤­åœ†å½¢
bool isEnergyRune(const std::vector&amp;lt;cv::Point&amp;gt;&amp;amp; contour) {
    if (contour.size() &amp;lt; 5) return false;
    
    cv::RotatedRect ellipse = cv::fitEllipse(contour);
    
    // æ¤­åœ†çš„é•¿çŸ­è½´æ¯”åº”è¯¥æ¥è¿‘1ï¼ˆè¿‘ä¼¼åœ†å½¢ï¼‰
    float ratio = ellipse.size.width / ellipse.size.height;
    if (ratio &amp;lt; 0.8 || ratio &amp;gt; 1.2) return false;
    
    // é¢ç§¯åˆç†
    double area = CV_PI * ellipse.size.width/2 * ellipse.size.height/2;
    if (area &amp;lt; 500 || area &amp;gt; 3000) return false;
    
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å®Œæ•´å®æˆ˜ä»£ç &lt;/h2&gt;
&lt;h3&gt;å®Œæ•´çš„ç¯æ¡æ£€æµ‹ç³»ç»Ÿ&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

// ç¯æ¡ç»“æ„ä½“
struct LightBar {
    cv::RotatedRect rect;
    double area;
    float aspectRatio;
    
    LightBar(const cv::RotatedRect&amp;amp; r, double a, float ar)
        : rect(r), area(a), aspectRatio(ar) {}
};

// ç¯æ¡æ£€æµ‹å‡½æ•°
std::vector&amp;lt;LightBar&amp;gt; detectLightBars(const cv::Mat&amp;amp; binary, 
                                      const cv::Mat&amp;amp; display) {
    // 1. æŸ¥æ‰¾è½®å»“
    std::vector&amp;lt;std::vector&amp;lt;cv::Point&amp;gt;&amp;gt; contours;
    cv::findContours(binary.clone(), contours, 
                     cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout &amp;lt;&amp;lt; &quot;æ€»è½®å»“æ•°: &quot; &amp;lt;&amp;lt; contours.size() &amp;lt;&amp;lt; std::endl;
    
    std::vector&amp;lt;LightBar&amp;gt; lightBars;
    
    // 2. éå†ç­›é€‰
    for (size_t i = 0; i &amp;lt; contours.size(); i++) {
        const auto&amp;amp; contour = contours[i];
        
        // é¢ç§¯ç­›é€‰
        double area = cv::contourArea(contour);
        if (area &amp;lt; 100) {
            std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: é¢ç§¯=&quot; &amp;lt;&amp;lt; area 
                      &amp;lt;&amp;lt; &quot;  å¤ªå°&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        if (area &amp;gt; 5000) {
            std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: é¢ç§¯=&quot; &amp;lt;&amp;lt; area 
                      &amp;lt;&amp;lt; &quot; å¤ªå¤§&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // æ‹Ÿåˆæ—‹è½¬çŸ©å½¢
        cv::RotatedRect rect = cv::minAreaRect(contour);
        
        // ç¡®ä¿heightæ˜¯é•¿è¾¹
        float width = rect.size.width;
        float height = rect.size.height;
        if (width &amp;gt; height) {
            std::swap(width, height);
        }
        
        // é•¿å®½æ¯”ç­›é€‰
        float aspectRatio = height / width;
        if (aspectRatio &amp;lt; 2.0) {
            std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: é•¿å®½æ¯”=&quot; &amp;lt;&amp;lt; aspectRatio 
                      &amp;lt;&amp;lt; &quot; å¤ªçŸ®&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        if (aspectRatio &amp;gt; 10.0) {
            std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: é•¿å®½æ¯”=&quot; &amp;lt;&amp;lt; aspectRatio 
                      &amp;lt;&amp;lt; &quot;å¤ªç»†&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // å¡«å……åº¦ç­›é€‰
        double rectArea = width * height;
        double fillRatio = area / rectArea;
        if (fillRatio &amp;lt; 0.5) {
            std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: å¡«å……åº¦=&quot; &amp;lt;&amp;lt; fillRatio 
                      &amp;lt;&amp;lt; &quot;  å¤ªç©º&quot; &amp;lt;&amp;lt; std::endl;
            continue;
        }
        
        // é€šè¿‡ç­›é€‰ï¼
        std::cout &amp;lt;&amp;lt; &quot;è½®å»“&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;:  ç¯æ¡å€™é€‰&quot; &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; &quot;    é¢ç§¯=&quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot;, é•¿å®½æ¯”=&quot; &amp;lt;&amp;lt; aspectRatio 
                  &amp;lt;&amp;lt; &quot;, å¡«å……åº¦=&quot; &amp;lt;&amp;lt; fillRatio &amp;lt;&amp;lt; std::endl;
        
        lightBars.emplace_back(rect, area, aspectRatio);
        
        // ç»˜åˆ¶ï¼ˆè°ƒè¯•ç”¨ï¼‰
        if (!display.empty()) {
            cv::Point2f vertices[4];
            rect.points(vertices);
            for (int j = 0; j &amp;lt; 4; j++) {
                cv::line(display, vertices[j], vertices[(j+1)%4],
                         cv::Scalar(0, 255, 0), 2);
            }
            cv::circle(display, rect.center, 5, cv::Scalar(0, 0, 255), -1);
        }
    }
    
    std::cout &amp;lt;&amp;lt; &quot;\næœ€ç»ˆæ‰¾åˆ° &quot; &amp;lt;&amp;lt; lightBars.size() &amp;lt;&amp;lt; &quot; ä¸ªç¯æ¡&quot; &amp;lt;&amp;lt; std::endl;
    return lightBars;
}

int main() {
    // è¯»å–å›¾åƒ
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;);
    if (img.empty()) {
        std::cerr &amp;lt;&amp;lt; &quot;æ— æ³•è¯»å–å›¾åƒ&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // é¢œè‰²æå–ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    cv::Mat binary = extractRedColor(img);
    
    // å½¢æ€å­¦å¤„ç†ï¼ˆå‡è®¾å·²å®ç°ï¼‰
    binary = morphologyProcess(binary);
    
    // ç¯æ¡æ£€æµ‹
    cv::Mat display = img.clone();
    std::vector&amp;lt;LightBar&amp;gt; lightBars = detectLightBars(binary, display);
    
    // æ˜¾ç¤ºç»“æœ
    cv::imshow(&quot;åŸå›¾&quot;, img);
    cv::imshow(&quot;äºŒå€¼å›¾&quot;, binary);
    cv::imshow(&quot;æ£€æµ‹ç»“æœ&quot;, display);
    cv::waitKey(0);
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å¸¸è§é—®é¢˜æ’æŸ¥&lt;/h2&gt;
&lt;h3&gt;é—®é¢˜1: æ‰¾ä¸åˆ°è½®å»“&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// æ£€æŸ¥æ¸…å•ï¼š
// 1. äºŒå€¼å›¾æ˜¯å¦æ­£ç¡®ï¼Ÿ
cv::imshow(&quot;binary&quot;, binary);  // åº”è¯¥æ˜¯é»‘ç™½çš„

// 2. å‰æ™¯æ˜¯ç™½è‰²å—ï¼Ÿ
// findContoursæ‰¾çš„æ˜¯ç™½è‰²åŒºåŸŸï¼å¦‚æœåäº†éœ€è¦åè½¬
cv::bitwise_not(binary, binary);

// 3. å›¾åƒæ˜¯å•é€šé“å—ï¼Ÿ
std::cout &amp;lt;&amp;lt; &quot;é€šé“æ•°: &quot; &amp;lt;&amp;lt; binary.channels() &amp;lt;&amp;lt; std::endl;  // åº”è¯¥æ˜¯1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜2: æ‰¾åˆ°å¤ªå¤šè½®å»“ï¼ˆéƒ½æ˜¯å™ªç‚¹ï¼‰&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è§£å†³æ–¹æ¡ˆï¼š
// 1. åŠ å¼ºå½¢æ€å­¦å¤„ç†
cv::morphologyEx(binary, binary, cv::MORPH_OPEN, kernel);

// 2. æé«˜é¢ç§¯é˜ˆå€¼
if (area &amp;lt; 200) continue;  // å¢å¤§

// 3. æ·»åŠ å¡«å……åº¦ç­›é€‰
double fillRatio = area / (width * height);
if (fillRatio &amp;lt; 0.6) continue;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜3: ç¯æ¡è¢«ç­›æ‰äº†&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// è°ƒè¯•æ­¥éª¤ï¼š
// 1. æ‰“å°æ¯ä¸ªè½®å»“çš„å‚æ•°
for (size_t i = 0; i &amp;lt; contours.size(); i++) {
    double area = cv::contourArea(contours[i]);
    cv::RotatedRect rect = cv::minAreaRect(contours[i]);
    float ratio = rect.size.height / rect.size.width;
    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;: area=&quot; &amp;lt;&amp;lt; area &amp;lt;&amp;lt; &quot;, ratio=&quot; &amp;lt;&amp;lt; ratio &amp;lt;&amp;lt; std::endl;
}

// 2. æ”¾å®½ç­›é€‰æ¡ä»¶
if (aspectRatio &amp;lt; 1.5 || aspectRatio &amp;gt; 15.0) continue;  // æ”¾å®½èŒƒå›´

// 3. å¯è§†åŒ–è¢«ç­›æ‰çš„è½®å»“
cv::drawContours(rejected_img, contours, i, cv::Scalar(0,0,255), 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;é—®é¢˜4: æ—‹è½¬çŸ©å½¢è§’åº¦ä¸å¯¹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// OpenCVçš„angleæœ‰æ—¶ä¸ç¬¦åˆé¢„æœŸ
// è§£å†³æ–¹æ¡ˆï¼šè‡ªå·±è®¡ç®—è§’åº¦
cv::Point2f vertices[4];
rect.points(vertices);

// è®¡ç®—é•¿è¾¹çš„è§’åº¦
cv::Point2f edge = vertices[1] - vertices[0];
float angle = std::atan2(edge.y, edge.x) * 180 / CV_PI;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>RMè£…ç”²æ¿è¯†åˆ« - 01 å›¾åƒè¯»å–ä¸æ˜¾ç¤º</title><link>https://www.nanye404.top/posts/rm_opencv_01/</link><guid isPermaLink="true">https://www.nanye404.top/posts/rm_opencv_01/</guid><description>æ— </description><pubDate>Thu, 23 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;æœ¬é˜¶æ®µæ ¸å¿ƒAPIæ¸…å•&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;ä½œç”¨&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imread()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;è¯»å–å›¾ç‰‡åˆ°å†…å­˜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imshow()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ˜¾ç¤ºå›¾ç‰‡çª—å£&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::waitKey()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ç­‰å¾…æŒ‰é”®&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::imwrite()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ä¿å­˜å›¾ç‰‡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::Mat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;å›¾åƒæ•°æ®ç±»å‹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cv::VideoCapture&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;æ‰“å¼€ç›¸æœº/è§†é¢‘&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;1. cv::imread() - è¯»å–å›¾ç‰‡&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat cv::imread(const String&amp;amp; filename, int flags = IMREAD_COLOR);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è¯´æ˜&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;ç±»å‹&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;filename&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;å›¾ç‰‡è·¯å¾„ï¼ˆç›¸å¯¹æˆ–ç»å¯¹è·¯å¾„ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;è¯»å–æ¨¡å¼ï¼ˆè§ä¸‹è¡¨ï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;flagså¸¸ç”¨å€¼:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_COLOR&lt;/code&gt; (é»˜è®¤) - è¯»å–å½©è‰²å›¾ï¼Œå¿½ç•¥é€æ˜åº¦&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_GRAYSCALE&lt;/code&gt; - è½¬ä¸ºç°åº¦å›¾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv::IMREAD_UNCHANGED&lt;/code&gt; - åŒ…å«Alphaé€šé“&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
    // è¯»å–å½©è‰²å›¾ï¼ˆè£…ç”²æ¿è¯†åˆ«ç”¨è¿™ä¸ªï¼‰
    cv::Mat img = cv::imread(&quot;armor.jpg&quot;, cv::IMREAD_COLOR);
    
    //  å¿…é¡»æ£€æŸ¥æ˜¯å¦è¯»å–æˆåŠŸï¼
    if (img.empty()) {
        std::cout &amp;lt;&amp;lt; &quot; å›¾ç‰‡è¯»å–å¤±è´¥ï¼&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // æ‰“å°å›¾ç‰‡ä¿¡æ¯
    std::cout &amp;lt;&amp;lt; &quot; å›¾ç‰‡è¯»å–æˆåŠŸ&quot; &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;   å°ºå¯¸: &quot; &amp;lt;&amp;lt; img.cols &amp;lt;&amp;lt; &quot; x &quot; &amp;lt;&amp;lt; img.rows &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;   é€šé“æ•°: &quot; &amp;lt;&amp;lt; img.channels() &amp;lt;&amp;lt; std::endl;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è¾“å‡ºç¤ºä¾‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; å›¾ç‰‡è¯»å–æˆåŠŸ
   å°ºå¯¸: 1280 x 720
   é€šé“æ•°: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å¸¸è§é”™è¯¯&lt;/h3&gt;
&lt;h4&gt;é”™è¯¯1: è·¯å¾„å†™é”™&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
// æ­£ç¡®å†™æ³•
cv::Mat img = cv::imread(&quot;/home/user/img.jpg&quot;);     // ç»å¯¹è·¯å¾„
cv::Mat img = cv::imread(&quot;img.jpg&quot;);       //ç›¸å¯¹è·¯å¾„

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;é”™è¯¯2: å¿˜è®°æ£€æŸ¥empty()&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåç»­æ“ä½œä¼šå´©æºƒ
cv::Mat img = cv::imread(&quot;not_exist.jpg&quot;);
cv::imshow(&quot;Window&quot;, img);  // å´©æºƒ

//  æ­£ç¡®å†™æ³•
cv::Mat img = cv::imread(&quot;not_exist.jpg&quot;);
if (img.empty()) {
    std::cerr &amp;lt;&amp;lt; &quot;æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ ¼å¼ä¸æ”¯æŒ&quot; &amp;lt;&amp;lt; std::endl;
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OpenCVè¯»å–çš„å›¾ç‰‡æ˜¯BGRæ ¼å¼ï¼Œä¸æ˜¯RGBï¼&lt;/strong&gt;&lt;br /&gt;
è¿™åœ¨åç»­é¢œè‰²è¯†åˆ«æ—¶éå¸¸é‡è¦ã€‚å¦‚æœä½ è¦è½¬RGBéœ€è¦ç”¨ &lt;code&gt;cv::cvtColor()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;2. cv::imshow() - æ˜¾ç¤ºå›¾ç‰‡&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void cv::imshow(const String&amp;amp; winname, InputArray mat);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è¯´æ˜&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;ç±»å‹&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;winname&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;çª—å£åç§°ï¼ˆè‡ªå·±èµ·åï¼‰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Mat&lt;/td&gt;
&lt;td&gt;è¦æ˜¾ç¤ºçš„å›¾åƒ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;armor.jpg&quot;);

// æ˜¾ç¤ºå›¾ç‰‡
cv::imshow(&quot;åŸå›¾&quot;, img);

//  å¿…é¡»é…åˆwaitKey()ï¼Œå¦åˆ™çª—å£é—ªç°å³æ¶ˆå¤±ï¼
cv::waitKey(0);  // 0è¡¨ç¤ºæ— é™ç­‰å¾…ï¼Œç›´åˆ°æŒ‰ä»»æ„é”®

// å…³é—­æ‰€æœ‰çª—å£
cv::destroyAllWindows();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ˜¾ç¤ºå¤šä¸ªçª—å£&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img1 = cv::imread(&quot;red_armor.jpg&quot;);
cv::Mat img2 = cv::imread(&quot;blue_armor.jpg&quot;);

cv::imshow(&quot;çº¢æ–¹è£…ç”²æ¿&quot;, img1);
cv::imshow(&quot;è“æ–¹è£…ç”²æ¿&quot;, img2);

cv::waitKey(0);
cv::destroyAllWindows();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å¸¸è§é”™è¯¯&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;//é”™è¯¯ï¼šçª—å£é—ªä¸€ä¸‹å°±æ¶ˆå¤±
cv::imshow(&quot;Window&quot;, img);
// ç¼ºå°‘ waitKey()

// æ­£ç¡®å†™æ³•
cv::imshow(&quot;Window&quot;, img);
cv::waitKey(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. cv::waitKey() - ç­‰å¾…æŒ‰é”®&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;int cv::waitKey(int delay = 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å‚æ•°è¯´æ˜&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;è¯´æ˜&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œ0è¡¨ç¤ºæ— é™ç­‰å¾…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;è¿”å›å€¼&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;æŒ‰ä¸‹çš„é”®çš„ASCIIç ï¼Œè¶…æ—¶è¿”å›-1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;å®ç”¨æŠ€å·§&lt;/h3&gt;
&lt;h4&gt;æŠ€å·§1: ç­‰å¾…ä»»æ„é”®&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cv::imshow(&quot;Image&quot;, img);
cv::waitKey(0);  // æŒ‰ä»»æ„é”®ç»§ç»­
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;æŠ€å·§2: æ£€æµ‹ç‰¹å®šæŒ‰é”®&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cv::imshow(&quot;Image&quot;, img);
int key = cv::waitKey(0);

if (key == 27) {  // ESCé”®
    std::cout &amp;lt;&amp;lt; &quot;ç”¨æˆ·å–æ¶ˆ&quot; &amp;lt;&amp;lt; std::endl;
} else if (key == &apos;s&apos; || key == &apos;S&apos;) {  // Sé”®
    cv::imwrite(&quot;saved.jpg&quot;, img);
    std::cout &amp;lt;&amp;lt; &quot;å›¾ç‰‡å·²ä¿å­˜&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;æŠ€å·§3: å®æ—¶è§†é¢‘æ˜¾ç¤ºï¼ˆ30fpsï¼‰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;while (true) {
    cv::Mat frame = getFrame();  // è·å–ä¸€å¸§
    cv::imshow(&quot;Video&quot;, frame);
    
    // ç­‰å¾…33msï¼ˆçº¦30fpsï¼‰ï¼ŒæŒ‰ESCé€€å‡º
    if (cv::waitKey(33) == 27) break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. cv::Mat - å›¾åƒæ•°æ®ç±»å‹&lt;/h2&gt;
&lt;h3&gt;æ ¸å¿ƒæ¦‚å¿µ&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cv::Mat&lt;/code&gt; æ˜¯OpenCVçš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ª&lt;strong&gt;å¤šç»´æ•°ç»„&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2Då›¾åƒ = äºŒç»´çŸ©é˜µ&lt;/li&gt;
&lt;li&gt;å½©è‰²å›¾åƒ = ä¸‰ç»´çŸ©é˜µï¼ˆå®½Ã—é«˜Ã—é€šé“ï¼‰&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;åˆ›å»ºMatå¯¹è±¡&lt;/h3&gt;
&lt;h4&gt;æ–¹æ³•1: é€šè¿‡imreadåˆ›å»º&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;image.jpg&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;æ–¹æ³•2: åˆ›å»ºç©ºç™½å›¾åƒ&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;// åˆ›å»º640Ã—480çš„é»‘è‰²å›¾åƒ
cv::Mat black(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));

// åˆ›å»ºç™½è‰²å›¾åƒ
cv::Mat white(480, 640, CV_8UC3, cv::Scalar(255, 255, 255));

// åˆ›å»ºçº¢è‰²å›¾åƒ
cv::Mat red(480, 640, CV_8UC3, cv::Scalar(0, 0, 255));  // BGRæ ¼å¼ï¼
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;å¸¸ç”¨å±æ€§&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;image.jpg&quot;);

// åŸºæœ¬ä¿¡æ¯
int width = img.cols;      // å®½åº¦ï¼ˆåˆ—æ•°ï¼‰
int height = img.rows;     // é«˜åº¦ï¼ˆè¡Œæ•°ï¼‰
int channels = img.channels();  // é€šé“æ•°ï¼ˆ1=ç°åº¦ï¼Œ3=å½©è‰²ï¼‰
bool isEmpty = img.empty();     // æ˜¯å¦ä¸ºç©º

// æ•°æ®ç±»å‹
int type = img.type();     // CV_8UC3 ç­‰
int depth = img.depth();   // CV_8U ç­‰

// å†…å­˜ä¿¡æ¯
size_t total = img.total();    // æ€»åƒç´ æ•° = rows Ã— cols
size_t bytes = img.total() * img.elemSize();  // å ç”¨å­—èŠ‚æ•°
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è®¿é—®åƒç´ å€¼&lt;/h3&gt;
&lt;h4&gt;æ–¹æ³•1: atè®¿é—®ï¼ˆå®‰å…¨ä½†æ…¢ï¼‰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;image.jpg&quot;);

// è®¿é—®(100, 200)ä½ç½®çš„åƒç´ 
cv::Vec3b pixel = img.at&amp;lt;cv::Vec3b&amp;gt;(100, 200);
uchar blue = pixel[0];
uchar green = pixel[1];
uchar red = pixel[2];

// ä¿®æ”¹åƒç´ 
img.at&amp;lt;cv::Vec3b&amp;gt;(100, 200) = cv::Vec3b(255, 0, 0);  // è®¾ä¸ºè“è‰²
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;æ–¹æ³•2: æŒ‡é’ˆè®¿é—®ï¼ˆå¿«ä½†éœ€å°å¿ƒï¼‰&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;for (int y = 0; y &amp;lt; img.rows; y++) {
    uchar* row = img.ptr&amp;lt;uchar&amp;gt;(y);  // è·å–ç¬¬yè¡Œçš„æŒ‡é’ˆ
    for (int x = 0; x &amp;lt; img.cols; x++) {
        uchar b = row[x * 3 + 0];
        uchar g = row[x * 3 + 1];
        uchar r = row[x * 3 + 2];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Matç±»å‹ä»£ç è¯´æ˜&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// CV_&amp;lt;bit-depth&amp;gt;{U|S|F}C&amp;lt;channels&amp;gt;
CV_8UC1   // 8ä½æ— ç¬¦å·ï¼Œ1é€šé“ï¼ˆç°åº¦å›¾ï¼‰
CV_8UC3   // 8ä½æ— ç¬¦å·ï¼Œ3é€šé“ï¼ˆBGRå½©è‰²å›¾ï¼‰
CV_32FC1  // 32ä½æµ®ç‚¹ï¼Œ1é€šé“
CV_16SC3  // 16ä½æœ‰ç¬¦å·ï¼Œ3é€šé“
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. cv::imwrite() - ä¿å­˜å›¾ç‰‡&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;bool cv::imwrite(const String&amp;amp; filename, InputArray img);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;åŸºç¡€ç”¨æ³•&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::Mat img = cv::imread(&quot;input.jpg&quot;);

// å¤„ç†å›¾åƒ...

// ä¿å­˜ä¸ºJPGï¼ˆæœ‰æŸå‹ç¼©ï¼‰
cv::imwrite(&quot;output.jpg&quot;, img);

// ä¿å­˜ä¸ºPNGï¼ˆæ— æŸå‹ç¼©ï¼Œæ¨èä¿å­˜äºŒå€¼å›¾ï¼‰
cv::imwrite(&quot;binary.png&quot;, binaryImg);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è®¾ç½®å‹ç¼©è´¨é‡&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// JPGè´¨é‡æ§åˆ¶ï¼ˆ0-100ï¼Œé»˜è®¤95ï¼‰
std::vector&amp;lt;int&amp;gt; jpg_params;
jpg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
jpg_params.push_back(90);  // è´¨é‡90%
cv::imwrite(&quot;output.jpg&quot;, img, jpg_params);

// PNGå‹ç¼©çº§åˆ«ï¼ˆ0-9ï¼Œé»˜è®¤3ï¼‰
std::vector&amp;lt;int&amp;gt; png_params;
png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
png_params.push_back(9);  // æœ€å¤§å‹ç¼©
cv::imwrite(&quot;output.png&quot;, img, png_params);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. cv::VideoCapture - æ‰“å¼€ç›¸æœº/è§†é¢‘&lt;/h2&gt;
&lt;h3&gt;å‡½æ•°åŸå‹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::VideoCapture cap(int device);         // æ‰“å¼€ç›¸æœº
cv::VideoCapture cap(const String&amp;amp; filename);  // æ‰“å¼€è§†é¢‘æ–‡ä»¶
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;æ‰“å¼€ç›¸æœº&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;

int main() {
    // æ‰“å¼€é»˜è®¤ç›¸æœºï¼ˆè®¾å¤‡ID=0ï¼‰
    cv::VideoCapture cap(0);
    
    // æ£€æŸ¥æ˜¯å¦æˆåŠŸæ‰“å¼€
    if (!cap.isOpened()) {
        std::cerr &amp;lt;&amp;lt; &quot;âŒ ç›¸æœºæ‰“å¼€å¤±è´¥&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    // è®¾ç½®ç›¸æœºå‚æ•°ï¼ˆå¯é€‰ï¼‰
    cap.set(cv::CAP_PROP_FRAME_WIDTH, 1280);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 720);
    cap.set(cv::CAP_PROP_FPS, 60);
    
    cv::Mat frame;
    while (true) {
        // è¯»å–ä¸€å¸§
        cap.read(frame);
        // æˆ–è€…: cap &amp;gt;&amp;gt; frame;
        
        if (frame.empty()) {
            std::cerr &amp;lt;&amp;lt; &quot;âŒ æ— æ³•è¯»å–å¸§&quot; &amp;lt;&amp;lt; std::endl;
            break;
        }
        
        // æ˜¾ç¤º
        cv::imshow(&quot;Camera&quot;, frame);
        
        // æŒ‰ESCé€€å‡º
        if (cv::waitKey(30) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;è¯»å–è§†é¢‘æ–‡ä»¶&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cv::VideoCapture cap(&quot;video.mp4&quot;);

if (!cap.isOpened()) {
    std::cerr &amp;lt;&amp;lt; &quot;è§†é¢‘æ–‡ä»¶æ‰“å¼€å¤±è´¥&quot; &amp;lt;&amp;lt; std::endl;
    return -1;
}

// è·å–è§†é¢‘ä¿¡æ¯
int fps = cap.get(cv::CAP_PROP_FPS);
int width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
int height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
int frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);

std::cout &amp;lt;&amp;lt; &quot;è§†é¢‘ä¿¡æ¯: &quot; &amp;lt;&amp;lt; width &amp;lt;&amp;lt; &quot;x&quot; &amp;lt;&amp;lt; height 
          &amp;lt;&amp;lt; &quot; @ &quot; &amp;lt;&amp;lt; fps &amp;lt;&amp;lt; &quot;fps, å…±&quot; &amp;lt;&amp;lt; frame_count &amp;lt;&amp;lt; &quot;å¸§&quot; &amp;lt;&amp;lt; std::endl;

cv::Mat frame;
while (cap.read(frame)) {
    cv::imshow(&quot;Video&quot;, frame);
    if (cv::waitKey(1000/fps) == 27) break;  // æŒ‰åŸé€Ÿæ’­æ”¾
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;æœ¬é˜¶æ®µå®æˆ˜ç»ƒä¹ &lt;/h2&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h3&gt;ç»ƒä¹ : ç›¸æœºå®æ—¶é¢„è§ˆ&lt;/h3&gt;
&lt;p&gt;å®ç°ä¸€ä¸ªç›¸æœºé¢„è§ˆç¨‹åºï¼Œæ˜¾ç¤ºå½“å‰FPS&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt; å‚è€ƒç­”æ¡ˆ&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;opencv2/opencv.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;

int main() {
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr &amp;lt;&amp;lt; &quot;ç›¸æœºæ‰“å¼€å¤±è´¥&quot; &amp;lt;&amp;lt; std::endl;
        return -1;
    }
    
    cv::Mat frame;
    auto last_time = std::chrono::high_resolution_clock::now();
    double fps = 0;
    
    while (true) {
        cap &amp;gt;&amp;gt; frame;
        if (frame.empty()) break;
        
        // è®¡ç®—FPS
        auto current_time = std::chrono::high_resolution_clock::now();
        double elapsed = std::chrono::duration&amp;lt;double&amp;gt;(current_time - last_time).count();
        fps = 1.0 / elapsed;
        last_time = current_time;
        
        // åœ¨å›¾åƒä¸Šç»˜åˆ¶FPS
        std::string fps_text = &quot;FPS: &quot; + std::to_string(int(fps));
        cv::putText(frame, fps_text, cv::Point(10, 30),
                    cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(0, 255, 0), 2);
        
        cv::imshow(&quot;Camera Preview&quot;, frame);
        if (cv::waitKey(1) == 27) break;
    }
    
    cap.release();
    cv::destroyAllWindows();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;æ£€æŸ¥æ¸…å•&lt;/h2&gt;
&lt;p&gt;å®Œæˆæœ¬é˜¶æ®µåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::imread()&lt;/code&gt; è¯»å–å›¾ç‰‡å¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸ&lt;/li&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::imshow()&lt;/code&gt; å’Œ &lt;code&gt;cv::waitKey()&lt;/code&gt; æ˜¾ç¤ºå›¾ç‰‡&lt;/li&gt;
&lt;li&gt;[ ] ç†è§£Matå¯¹è±¡çš„åŸºæœ¬å±æ€§ï¼ˆrows, cols, channelsï¼‰&lt;/li&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::imwrite()&lt;/code&gt; ä¿å­˜å¤„ç†ç»“æœ&lt;/li&gt;
&lt;li&gt;[ ] ç”¨ &lt;code&gt;cv::VideoCapture&lt;/code&gt; æ‰“å¼€ç›¸æœºå¹¶å®æ—¶æ˜¾ç¤º&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
</content:encoded></item><item><title>æ›´æ–°æ—¥å¿—</title><link>https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</link><guid isPermaLink="true">https://www.nanye404.top/posts/%E6%97%A5%E5%BF%97/</guid><description>è¿™é‡Œæ˜¯æ›´æ–°æ—¥å¿—</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;2025-10-22&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;æ›´æ–°äº†ä¸ªäººç®€ä»‹&lt;/li&gt;
&lt;li&gt;æ›´æ–°äº†rmç¬”è®°&lt;/li&gt;
&lt;li&gt;æ›´æ–°äº†åŒæŒ‡é’ˆçš„æ¡†æ¶&lt;/li&gt;
&lt;li&gt;è¯„è®ºæ²¡æŒ‚æœåŠ¡å™¨æ‰€ä»¥ä¸èƒ½ç”¨&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2025-10-23&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;æ›´æ–°äº†å¿«æ…¢æŒ‡é’ˆ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2025-10-24&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;æ›´æ–°äº†ä¸¤ç¯‡opencvå…¥é—¨ï¼Œaiå†™çš„ï¼Œä»¥åçœ‹ç€èƒ½ä¸èƒ½ç²¾ç®€ä¸€ä¸‹&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>åŒæŒ‡é’ˆ</title><link>https://www.nanye404.top/posts/twop/</link><guid isPermaLink="true">https://www.nanye404.top/posts/twop/</guid><description>åŒæŒ‡é’ˆå¸¸è§æŠ€å·§</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%94%A8&quot;&gt;åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88&quot;&gt;å¿«æ…¢æŒ‡é’ˆ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2&quot;&gt;äºŒåˆ†æœç´¢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3&quot;&gt;æ»‘åŠ¨çª—å£&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9E%E6%96%87/%E5%8F%8D%E8%BD%AC&quot;&gt;å›æ–‡/åè½¬&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E4%B9%8B%E5%92%8C&quot;&gt;æ•°ä¹‹å’Œ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%94%A8&quot;&gt;åŒæŒ‡é’ˆåœ¨é“¾è¡¨çš„è¿ç”¨&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%88%E5%B9%B6&quot;&gt;åˆå¹¶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E8%A7%A3&quot;&gt;åˆ†è§£&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B6%E4%BB%96&quot;&gt;å…¶ä»–&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;æ€»ç»“&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;åŒæŒ‡é’ˆåœ¨æ•°ç»„çš„è¿ç”¨&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;å¿«æ…¢æŒ‡é’ˆ&lt;/h2&gt;
&lt;h3&gt;æ•°ç»„çš„åŸåœ°ä¿®æ”¹&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;åŠ›æ‰£ç¬¬ 26 é¢˜ã€Œåˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ã€ï¼Œè®©ä½ åœ¨æœ‰åºæ•°ç»„å»é‡ï¼š
https://leetcode.cn/problems/remove-duplicates-from-sorted-array/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;ç»™ä½ ä¸€ä¸ª&lt;strong&gt;éä¸¥æ ¼é€’å¢æ’åˆ—&lt;/strong&gt;çš„æ•°ç»„&lt;code&gt;nums&lt;/code&gt; ï¼Œè¯·ä½ &lt;strong&gt;åŸåœ°&lt;/strong&gt;åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ &lt;strong&gt;åªå‡ºç°ä¸€æ¬¡&lt;/strong&gt;ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„&lt;strong&gt;ç›¸å¯¹é¡ºåº&lt;/strong&gt;åº”è¯¥ä¿æŒ&lt;strong&gt;ä¸€è‡´&lt;/strong&gt;ã€‚ç„¶åè¿”å› &lt;code&gt;nums&lt;/code&gt; ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚&lt;/li&gt;
&lt;li&gt;è€ƒè™‘ &lt;code&gt;nums &lt;/code&gt;çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º &lt;code&gt;k&lt;/code&gt;ã€‚å»é‡åï¼Œè¿”å›å”¯ä¸€å…ƒç´ çš„æ•°é‡ kã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; çš„å‰ k ä¸ªå…ƒç´ åº”åŒ…å« æ’åºå çš„å”¯ä¸€æ•°å­—ã€‚ä¸‹æ ‡ &lt;code&gt;k - 1 &lt;/code&gt;ä¹‹åçš„å‰©ä½™å…ƒç´ å¯ä»¥å¿½ç•¥ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;åˆ¤é¢˜æ ‡å‡†:&lt;/p&gt;
&lt;p&gt;ç³»ç»Ÿä¼šç”¨ä¸‹é¢çš„ä»£ç æ¥æµ‹è¯•ä½ çš„é¢˜è§£:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] nums = [...]; // è¾“å…¥æ•°ç»„
int[] expectedNums = [...]; // é•¿åº¦æ­£ç¡®çš„æœŸæœ›ç­”æ¡ˆ
int k = removeDuplicates(nums); // è°ƒç”¨
assert k == expectedNums.length;
for (int i = 0; i &amp;lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å¦‚æœæ‰€æœ‰æ–­è¨€éƒ½é€šè¿‡ï¼Œé‚£ä¹ˆæ‚¨çš„é¢˜è§£å°†è¢«&lt;strong&gt;é€šè¿‡&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;ç¤ºä¾‹ 1ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š2, nums = [1,2,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2 ï¼Œå¹¶ä¸”åŸæ•°ç»„ nums çš„å‰ä¸¤ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 1, 2 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ç¤ºä¾‹ 2ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;è¾“å…¥ï¼šnums = [0,0,1,1,1,2,2,3,3,4]
è¾“å‡ºï¼š5, nums = [0,1,2,3,4,_,_,_,_,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 5 ï¼Œ å¹¶ä¸”åŸæ•°ç»„ nums çš„å‰äº”ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 0, 1, 2, 3, 4 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;åŸåœ°&lt;/strong&gt;æ„å‘³ç€åªèƒ½å¯¹å½“å‰æ•°ç»„è¿›è¡Œä¿®æ”¹ï¼Œä¸èƒ½æ–°å»ºä¸€ä¸ªæ•°ç»„&lt;/li&gt;
&lt;li&gt;è¿™é‡Œæ‰€éœ€è¦ç”¨åˆ°çš„å°±æ˜¯&lt;strong&gt;å¿«æ…¢æŒ‡é’ˆ&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ç®€å•æ¥è¯´å°±æ˜¯ä¸€ä¸ªå¿«æŒ‡é’ˆå»è¯†åˆ«ï¼Œå¦ä¸€ä¸ªæ…¢æŒ‡é’ˆå»æ“ä½œ&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;æ³¨æ„&lt;/strong&gt;  è¿™é‡ŒæŒ‡é’ˆæ˜¯å¹¿ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œæ•°ç»„çš„ç´¢å¼•ä¹Ÿå¯ä»¥æ˜¯&lt;strong&gt;æŒ‡é’ˆ&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;å¦‚æœ &lt;code&gt;fast&lt;/code&gt; é‡åˆ°å€¼ä¸º &lt;code&gt;val &lt;/code&gt;çš„å…ƒç´ ï¼Œåˆ™ç›´æ¥è·³è¿‡ï¼Œå¦åˆ™å°±èµ‹å€¼ç»™ &lt;code&gt;slow&lt;/code&gt; æŒ‡é’ˆï¼Œå¹¶è®© &lt;code&gt;slow &lt;/code&gt;å‰è¿›ä¸€æ­¥ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å…·ä½“ä»£ç å¦‚ä¸‹&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        if (nums.empty()) return 0;

        int slow = 0;
        for (int fast = 1; fast &amp;lt; nums.size(); fast++) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }

        return slow + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;æ³¨æ„è¿™é‡Œéœ€è¦&lt;strong&gt;å…ˆ&lt;code&gt;slow++&lt;/code&gt;å†èµ‹å€¼&lt;/strong&gt;ï¼Œè¦ä¸ç„¶ç¬¬ä¸€ä¸ªä¼šè¢«åæ‰&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;ä¸‹é¢ä¸€é“é¢˜ä¹Ÿæ˜¯å¿«æ…¢æŒ‡é’ˆçš„æ€æƒ³ï¼Œå¦‚æœæŒæ¡äº†å‰ä¸€é“é¢˜ï¼Œè¿™é¢˜ä¼šå¾ˆç®€å•&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;åŠ›æ‰£283ç§»åŠ¨0&lt;/strong&gt;https://leetcode.cn/problems/move-zeroes/&lt;/li&gt;
&lt;li&gt;ç»™å®šä¸€ä¸ªæ•°ç»„ &lt;strong&gt;nums&lt;/strong&gt;ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚&lt;/li&gt;
&lt;li&gt;è¯·æ³¨æ„ ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ç¤ºä¾‹ 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;è¾“å…¥: nums = [0,1,0,3,12]
è¾“å‡º: [1,3,12,0,0]
ç¤ºä¾‹ 2:
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;è¾“å…¥: nums = [0]
è¾“å‡º: [0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;è¿™é‡Œæˆ‘å°±ç›´æ¥ä¸Šä»£ç äº†&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int slow = 0;  // æŒ‡å‘ä¸‹ä¸€ä¸ªéé›¶åº”æ”¾ç½®çš„ä½ç½®
        for (int fast = 0; fast &amp;lt; nums.size(); fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // slow ä¹‹åçš„å…¨éƒ¨ç½®ä¸º 0
        for (int i = slow; i &amp;lt; nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;äºŒåˆ†æœç´¢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;åœ¨æˆ‘ä»¬éƒ½ç©è¿‡çš„çŒœæ•°å­—æ¸¸æˆä¸­ï¼Œç”¨çš„å°±æ˜¯äºŒåˆ†æœç´ çš„æŠ€å·§&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;æˆ‘ä»¬å…ˆçœ‹æœ€ç¬¨çš„é¡ºåºæŸ¥æ‰¾ï¼Œæˆ‘ä»¬ä»1-100éå†å…¨éƒ¨æ•°å­—ï¼Œè™½ç„¶è¯´è¿æ°”å¥½å¯èƒ½ä¸€ä¸‹ä¼šçŒœä¸­ï¼Œä½†æ˜¯æœŸæœ›çš„æ¬¡æ•°è¿˜æ˜¯å¾ˆå¤šï¼Œå¤æ‚åº¦ä¸ºO(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;å¦‚æœæ˜¯å‡­æ„Ÿè§‰æ‰¾ï¼Œä¸€æ ·è¿˜æ˜¯è¦çœ‹è¿æ°”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;å¦‚æœç¬¬ä¸€æ¬¡çŒœ50ï¼Œç„¶åç»§ç»­ä¸€åŠä¸€åŠç¼©å°åŒºé—´ï¼Œæœ€åä¹Ÿèƒ½åœ¨7æ¬¡å†…è§£å†³&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¦‚ä½•æ•°å­—æ¥åˆ°1-1000000ï¼ŒäºŒåˆ†æœç´¢æœ€å20æ¬¡å°±èƒ½æ‰¾åˆ°ç­”æ¡ˆ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(log  N)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ä¸‹é¢æ˜¯æœ€åŸºæœ¬ä»£ç &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) {
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    int left = 0, right = nums.size() - 1;
    while(left &amp;lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &amp;lt; target)
            left = mid + 1; 
        else if (nums[mid] &amp;gt; target)
            right = mid - 1;
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>è£…ç”²æ¿è‡ªåŠ¨è¯†åˆ«ä¸ä½å§¿ä¼°è®¡å­¦ä¹ </title><link>https://www.nanye404.top/posts/armor/</link><guid isPermaLink="true">https://www.nanye404.top/posts/armor/</guid><description>ä¸€äº›å°ç¬”è®°</description><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;ç›®å½•&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E8%A7%88%E7%B3%BB%E7%BB%9F%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E9%80%9F%E9%80%9A&quot;&gt;å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F%E5%A6%82%E4%BD%95%E8%A2%AB%E5%A4%84%E7%90%86&quot;&gt;ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A8%A1%E5%9D%97%E9%80%90%E4%B8%AA%E6%8B%86%E8%A7%A3%E5%90%AB%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5&quot;&gt;æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;4.1 æ•°å­—åˆ†ç±»å™¨ &lt;code&gt;NumberClassifier&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.2 è§†è§‰æ£€æµ‹å™¨ &lt;code&gt;Detector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® &lt;code&gt;LightCornerCorrector&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.4 ä½å§¿ä¼°è®¡ &lt;code&gt;ArmorPoseEstimator&lt;/code&gt;ï¼ˆPnP + BAï¼‰&lt;/li&gt;
&lt;li&gt;4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ &lt;code&gt;BaSolver&lt;/code&gt; / &lt;code&gt;GraphOptimizer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4.6 ROS2 èŠ‚ç‚¹ &lt;code&gt;ArmorDetectorNode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%95%88%E6%9E%9C%E8%B0%83%E5%8F%82%E6%8C%87%E5%8D%97&quot;&gt;å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%9E%E6%88%98%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96&quot;&gt;å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF&quot;&gt;å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%E9%A2%98%E5%B8%A6%E6%96%B9%E5%90%91%E6%8F%90%E7%A4%BA&quot;&gt;è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B0%8F%E6%8A%84&quot;&gt;æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;æ€»è§ˆï¼šç³»ç»Ÿåšçš„äº‹æƒ…æ˜¯ä»€ä¹ˆ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ç›®æ ‡&lt;/strong&gt;ï¼šä»ç›¸æœºæ¥çš„å½©è‰²å›¾åƒä¸­ï¼Œè‡ªåŠ¨æ‰¾å‡ºâ€œ&lt;strong&gt;ä¸¤æ ¹ç¯æ¡ç»„æˆçš„è£…ç”²æ¿&lt;/strong&gt;â€ï¼Œ&lt;strong&gt;è¯†åˆ«è£…ç”²æ•°å­—&lt;/strong&gt;ï¼Œå¹¶ä¼°è®¡è£…ç”²æ¿åœ¨&lt;strong&gt;ç›¸æœºåæ ‡ç³»&lt;/strong&gt;ä¸‹çš„ä¸‰ç»´ä½å§¿ï¼ˆä½ç½® + å§¿æ€ï¼‰ï¼Œæœ€åé€šè¿‡ &lt;strong&gt;ROS2&lt;/strong&gt; å‘å¸ƒç»“æœä¸å¯è§†åŒ–ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;å…³é”®é˜¶æ®µ&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;å›¾åƒé¢„å¤„ç† â†’ äºŒå€¼åŒ–è½®å»“ â†’ &lt;strong&gt;ç¯æ¡å€™é€‰&lt;/strong&gt;ã€‚&lt;/li&gt;
&lt;li&gt;ç¯æ¡å‡ ä½•ç­›é€‰ &amp;amp; é¢œè‰²åˆ¤å®š â†’ &lt;strong&gt;ç¯æ¡é…å¯¹æˆè£…ç”²æ¿&lt;/strong&gt;ã€‚&lt;/li&gt;
&lt;li&gt;é€è§†å±•å¼€ä¸­éƒ¨åŒºåŸŸ â†’ &lt;strong&gt;æ•°å­—åˆ†ç±»&lt;/strong&gt;ï¼ˆONNX æ¨¡å‹ï¼‰ã€‚&lt;/li&gt;
&lt;li&gt;å¯¹ç¯æ¡ä¸Šä¸‹è§’ç‚¹åš&lt;strong&gt;å‡ ä½•ç»†åŒ–&lt;/strong&gt;ï¼ˆæå‡ PnP ç¨³å®šæ€§ï¼‰ã€‚&lt;/li&gt;
&lt;li&gt;ç”¨ &lt;strong&gt;PnP æ±‚åˆè§£&lt;/strong&gt; â†’ æ¡ä»¶å…è®¸æ—¶ç”¨ **BAï¼ˆä»…ä¼˜åŒ– yawï¼‰**åšå°ä¼˜åŒ–ã€‚&lt;/li&gt;
&lt;li&gt;å°è£…ä¸º ROS2 èŠ‚ç‚¹ï¼š&lt;strong&gt;è®¢é˜…å›¾åƒ/ç›¸æœºå†…å‚/TF&lt;/strong&gt;ï¼Œå‘å¸ƒè°ƒè¯•å›¾åƒä¸ &lt;strong&gt;Marker&lt;/strong&gt;ã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;å…³é”®çŸ¥è¯†ç‚¹é€Ÿé€š&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;å›¾åƒè¯»å–ä¸æ˜¾ç¤º&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_02/&quot;&amp;gt;è£…ç”²æ¿é¢œè‰²æå–&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_03/&quot;&amp;gt;å½¢æ€å­¦å¤„ç†&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_04/&quot;&amp;gt;è½®å»“æ£€æµ‹&amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;a href=&quot;/posts/rm_opencv_01/&quot;&amp;gt;æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« &amp;lt;/a&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ç«¯åˆ°ç«¯æµç¨‹å›¾ï¼ˆä¸€å¸§å›¾åƒå¦‚ä½•è¢«å¤„ç†ï¼‰&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Image(rgb8)
   â””â”€â–º é¢„å¤„ç†(ç°åº¦/é˜ˆå€¼)
          â””â”€â–º è½®å»“â†’ç¯æ¡(Light)
                 â””â”€â–º åŒè‰² + å‡ ä½•å…³ç³» â†’ è£…ç”²(Armor)
                        â”œâ”€â–º (å¯é€‰) ç¯æ¡è§’ç‚¹ç²¾ä¿®
                        â”œâ”€â–º é€è§†å±•å¼€æ•°å­—ROI â†’ äºŒå€¼åŒ– â†’ åˆ†ç±»
                        â””â”€â–º PnPæ±‚ä½å§¿ â†’ (å¯é€‰) BAä¼˜åŒ–yaw
                               â””â”€â–º å‘å¸ƒArmors + RViz Marker + è°ƒè¯•å›¾åƒ
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;æ¨¡å—é€ä¸ªæ‹†è§£ï¼ˆå«æ ¸å¿ƒä»£ç ç‰‡æ®µï¼‰&lt;/h2&gt;
&lt;h3&gt;4.1 æ•°å­—åˆ†ç±»å™¨ &lt;code&gt;NumberClassifier&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;èŒè´£&lt;/strong&gt;ï¼šä»è£…ç”²æ¿ä¸¤æ ¹ç¯æ¡ä¹‹é—´è£å‡ºæ•°å­—å›¾ï¼ˆå›ºå®šå°ºå¯¸ï¼‰ï¼ŒäºŒå€¼åŒ–åå–‚ç»™ ONNX åˆ†ç±»ç½‘ç»œï¼Œå¾—åˆ°ç±»åˆ«ä¸ç½®ä¿¡åº¦ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æ ¸å¿ƒï¼šé€è§†å±•å¼€ + äºŒå€¼åŒ– + DNN å‰å‘&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// é€è§†å±•å¼€å¹¶è£ ROIï¼ˆå®½åº¦éšå¤§å°è£…ç”²è€Œå˜ï¼‰
cv::Mat NumberClassifier::extractNumber(const cv::Mat&amp;amp; src, const Armor&amp;amp; armor) const noexcept {
  static const int light_length = 12, warp_height = 28;
  static const int small_armor_width = 32, large_armor_width = 54;
  static const cv::Size roi_size(20, 28), input_size(28, 28);

  cv::Point2f lights_vertices[4] = {
    armor.left_light.bottom, armor.left_light.top,
    armor.right_light.top,   armor.right_light.bottom
  };
  const int top_light_y    = (warp_height - light_length) / 2 - 1;
  const int bottom_light_y = top_light_y + light_length;
  const int warp_width     = (armor.type == ArmorType::SMALL ? small_armor_width : large_armor_width);
  cv::Point2f target_vertices[4] = {
    {0, bottom_light_y}, {0, top_light_y},
    {warp_width - 1, top_light_y}, {warp_width - 1, bottom_light_y},
  };

  cv::Mat number_image, M = cv::getPerspectiveTransform(lights_vertices, target_vertices);
  cv::warpPerspective(src, number_image, M, cv::Size(warp_width, warp_height));

  // ä¸­éƒ¨ ROI â†’ ç°åº¦&amp;amp;OTSU â†’ 28x28
  number_image = number_image(cv::Rect((warp_width - roi_size.width) / 2, 0, roi_size.width, roi_size.height));
  cv::cvtColor(number_image, number_image, cv::COLOR_RGB2GRAY);
  cv::threshold(number_image, number_image, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
  cv::resize(number_image, number_image, input_size);
  return number_image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// å‰å‘åˆ†ç±» + ç»“æœè§£ç 
void NumberClassifier::classify(const cv::Mat&amp;amp;, Armor&amp;amp; armor) noexcept {
  cv::Mat input = armor.number_img / 255.0;  // [0,1]
  cv::Mat blob; cv::dnn::blobFromImage(input, blob);
  mutex_.lock(); net_.setInput(blob); cv::Mat out = net_.forward().clone(); mutex_.unlock();

  double conf; cv::Point idp;
  minMaxLoc(out.reshape(1, 1), nullptr, &amp;amp;conf, nullptr, &amp;amp;idp);
  int label_id = idp.x;
  armor.confidence = conf;
  armor.number     = class_names_[label_id];
  armor.classfication_result = fmt::format(&quot;{}:{:.1f}%&quot;, armor.number, armor.confidence * 100.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// è¿‡æ»¤ï¼šæŒ‰é˜ˆå€¼/å¿½ç•¥åˆ—è¡¨ + å¤§å°è£…ç”²ä¸ç±»åˆ«çš„äº’æ–¥è§„åˆ™
void NumberClassifier::eraseIgnoreClasses(std::vector&amp;lt;Armor&amp;gt;&amp;amp; armors) noexcept {
  armors.erase(std::remove_if(armors.begin(), armors.end(), [this](const Armor &amp;amp;a) {
    if (a.confidence &amp;lt; threshold) return true;
    for (auto&amp;amp; ig : ignore_classes_) if (a.number == ig) return true;

    bool mismatch = false;
    if (a.type == ArmorType::LARGE)  mismatch = (a.number == &quot;outpost&quot; || a.number == &quot;2&quot; || a.number == &quot;sentry&quot;);
    if (a.type == ArmorType::SMALL)  mismatch = (a.number == &quot;1&quot;      || a.number == &quot;base&quot;);
    return mismatch;
  }), armors.end());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;è¦ç‚¹&lt;/strong&gt;ï¼šROI å®½åº¦ä¸è£…ç”²å°ºå¯¸åŒ¹é…ï¼›OTSU è®©é˜ˆå€¼æ›´ç¨³ï¼›&lt;code&gt;blobFromImage&lt;/code&gt; å°è£…å½’ä¸€åŒ–ä¸ NHWCâ†’NCHWã€‚&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;4.2 è§†è§‰æ£€æµ‹å™¨ &lt;code&gt;Detector&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;èŒè´£&lt;/strong&gt;ï¼šç°åº¦/é˜ˆå€¼ â†’ è½®å»“ â†’ ç¯æ¡ï¼ˆå½¢çŠ¶ + å€¾è§’ï¼‰â†’ ç»Ÿè®¡é¢œè‰² â†’ å·¦å³åŒè‰²é…å¯¹ â†’ è£…ç”²ã€‚è‹¥æœ‰åˆ†ç±»å™¨ä¸è§’ç‚¹ä¿®æ­£å™¨ï¼Œåˆ™å¹¶è¡Œè¿›è¡Œæ•°å­—åˆ†ç±»ä¸è§’ç‚¹ç»†åŒ–ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æ€»ä½“æµç¨‹&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;Armor&amp;gt; Detector::detect(const cv::Mat&amp;amp; input) noexcept {
  binary_img = preprocessImage(input);               // ç°åº¦+å›ºå®šé˜ˆå€¼
  lights_    = findLights(input, binary_img);        // è½®å»“â†’Lightï¼ˆæ¯”ä¾‹/è§’åº¦/é¢œè‰²ï¼‰
  armors_    = matchLights(lights_);                 // å·¦å³é…å¯¹ â†’ Armor

  if (!armors_.empty() &amp;amp;&amp;amp; classifier) {
    std::for_each(std::execution::par, armors_.begin(), armors_.end(), [this,&amp;amp;input](Armor&amp;amp; a){
      a.number_img = classifier-&amp;gt;extractNumber(input, a);
      classifier-&amp;gt;classify(input, a);
      if (corner_corrector) corner_corrector-&amp;gt;correctCorners(a, gray_img_);
    });
    classifier-&amp;gt;eraseIgnoreClasses(armors_);
  }
  return armors_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;å…³é”®åˆ¤å®šï¼šç¯æ¡ä¸é…å¯¹&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// ç¯æ¡ç­›é€‰ï¼šçŸ­é•¿è¾¹æ¯” + å€¾è§’
bool Detector::isLight(const Light&amp;amp; l) noexcept {
  float ratio = l.width / l.length;
  bool ratio_ok = light_params.min_ratio &amp;lt; ratio &amp;amp;&amp;amp; ratio &amp;lt; light_params.max_ratio;
  bool angle_ok = l.tilt_angle &amp;lt; light_params.max_angle;
  return ratio_ok &amp;amp;&amp;amp; angle_ok;
}

// é¢œè‰²ï¼šåœ¨è½®å»“åƒç´ ä¸­ç»Ÿè®¡R/Bå¼ºåº¦å·®ï¼ˆçº¢/è“ï¼‰
for (auto&amp;amp; pt: contour) { sum_r += rgb(pt)[0]; sum_b += rgb(pt)[2]; }
if (abs(sum_r - sum_b)/contour.size() &amp;gt; light_params.color_diff_thresh)
  light.color = (sum_r &amp;gt; sum_b ? RED : BLUE);

// å¤¹ç¯æ£€æµ‹ï¼šä¸¤ç¯æ¡å¤–æ¥çŸ©å½¢å†…æ˜¯å¦è¿˜â€œå¤¹â€ç€åˆ«çš„ç¯æ¡ï¼ˆä¸”æ’é™¤æ•°å­—/çº¢ç‚¹ç­‰å¹²æ‰°ï¼‰
bool containLight(int i, int j, const std::vector&amp;lt;Light&amp;gt;&amp;amp; lights);

// é…å¯¹ï¼šåŒè‰² + Xæ–¹å‘æ‰«æ + ä¸­å¿ƒè·çª—å£ï¼ˆåŒºåˆ†å¤§å°è£…ç”²ï¼‰+ ä¸¤ç¯æ¡é•¿åº¦ç›¸è¿‘ + å¤¹è§’é™åˆ¶
std::vector&amp;lt;Armor&amp;gt; Detector::matchLights(const std::vector&amp;lt;Light&amp;gt;&amp;amp; lights) noexcept;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.3 ç¯æ¡è§’ç‚¹ç²¾ä¿® &lt;code&gt;LightCornerCorrector&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;èŒè´£&lt;/strong&gt;ï¼šæ›´ç²¾ç¡®åœ°æ‰¾åˆ°æ¯æ ¹ç¯æ¡çš„&lt;strong&gt;ä¸Šä¸‹ç«¯ç‚¹&lt;/strong&gt;ä¸&lt;strong&gt;ä¸­å¿ƒ/è½´å‘&lt;/strong&gt;ï¼Œæå‡ PnP çš„ 2D-3D å¯¹åº”ç²¾åº¦ï¼ˆåœ¨äºŒå€¼åŒ–æˆ–å™ªå£°ç¯å¢ƒä¸‹å°¤å…¶æœ‰ç”¨ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ç®—æ³•æ€è·¯&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ä»¥ç¯æ¡å¤–æ¥æ¡†ä¸ºåŸºç¡€åš&lt;strong&gt;é€‚åº¦æ‰©å±•&lt;/strong&gt;å¹¶æ£€æŸ¥è¾¹ç•Œï¼›&lt;/li&gt;
&lt;li&gt;å¯¹è¯¥å°åŒºåŸŸåš&lt;strong&gt;é‡å¿ƒä¸ä¸»æ–¹å‘&lt;/strong&gt;ä¼°è®¡ï¼ˆäº®åº¦åŠ æƒ + PCA/ä¸€é˜¶çŸ©ï¼‰ï¼Œå¾—åˆ°&lt;strong&gt;å¯¹ç§°è½´&lt;/strong&gt;ï¼›&lt;/li&gt;
&lt;li&gt;æ²¿å¯¹ç§°è½´çš„ä¸Šä¸‹æ–¹å‘ï¼Œä»¥å¤šä¸ªå¹³è¡Œâ€œæ‰«æçº¿â€å¯»æ‰¾&lt;strong&gt;äº®åº¦çªå˜æœ€å¤§&lt;/strong&gt;çš„ä½ç½®ä½œä¸ºç«¯ç‚¹å€™é€‰ï¼Œæœ€åæ±‚å¹³å‡ã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;è¦ç‚¹ä»£ç &lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// è§’ç‚¹ä¿®æ­£å…¥å£ï¼šå®½åº¦å¤ªå°åˆ™è·³è¿‡ï¼Œé¿å…å™ªå£°
void LightCornerCorrector::correctCorners(Armor&amp;amp; armor, const cv::Mat&amp;amp; gray) {
  constexpr int PASS_OPTIMIZE_WIDTH = 3;
  if (armor.left_light.width  &amp;gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp;amp; è§’ç‚¹ */ }
  if (armor.right_light.width &amp;gt; PASS_OPTIMIZE_WIDTH) { /* æ±‚ axis &amp;amp; è§’ç‚¹ */ }
}

// æ²¿å¯¹ç§°è½´å¯»æ‰¾â€œäº®åº¦çªå˜æœ€å¤§â€çš„ç‚¹ä½œä¸ºè§’ç‚¹ï¼ˆå¤šæ¡å¹³è¡Œçº¿ï¼Œå–å€™é€‰å¹³å‡ï¼‰
cv::Point2f LightCornerCorrector::findCorner(const cv::Mat&amp;amp; gray, const Light&amp;amp; light,
                                             const SymmetryAxis&amp;amp; axis, std::string order) {
  // ... æ‰«æ START~END çš„å°æ®µï¼Œç´¯è®¡äº®åº¦å·®æœ€å¤§å¤„ ...
  // è¿”å›å‡å€¼ç‚¹ï¼›æ— å€™é€‰åˆ™è¿”å› (-1,-1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.4 ä½å§¿ä¼°è®¡ &lt;code&gt;ArmorPoseEstimator&lt;/code&gt;ï¼ˆPnP + BAï¼‰&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;èŒè´£&lt;/strong&gt;ï¼šæŠŠè£…ç”²å››è§’çš„ 2D åƒç´ ç‚¹ä¸å·²çŸ¥ 3D æ¨¡å‹ç‚¹ï¼ˆå¤§/å°è£…ç”²çš„çœŸå®å°ºå¯¸ï¼‰å¯¹åº”ï¼Œè§£å‡º R/tã€‚è‹¥ roll å°ä¸”å¼€å¯ BAï¼Œåˆ™è¿›ä¸€æ­¥ä»…åœ¨ &lt;strong&gt;yaw&lt;/strong&gt; ç»´è¿›è¡Œå›¾ä¼˜åŒ–ï¼Œä½¿æŠ•å½±è¯¯å·®æ›´å°ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æ ¸å¿ƒæµç¨‹&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1) PnP åˆè§£ï¼ˆsolvePnPGeneric å¯èƒ½è¿”å›ä¸¤ç»„è§£ï¼‰
if (pnp_solver_-&amp;gt;solvePnPGeneric(armor.landmarks(), rvecs, tvecs, type_name)) {
  sortPnPResult(armor, rvecs, tvecs);   // 2) è§£çš„é€‰æ‹©ï¼ˆè¯¯å·®/roll/ç¯æ¡å€¾è§’â†’yawæ­£è´Ÿï¼‰

  cv::Mat rmat; cv::Rodrigues(rvecs[0], rmat);
  Eigen::Matrix3d R = cvToEigen(rmat);
  Eigen::Vector3d t = cvToEigen(tvecs[0]);

  double roll = rotationMatrixToRPY(R_gimbal_camera_ * R)[0] * 180/M_PI;
  if (use_ba_ &amp;amp;&amp;amp; roll &amp;lt; 15) {
    // 3) BAï¼šä»…ä¼˜åŒ– yawï¼Œå°å¹…ä¿®æ­£ R ä»¥å‡å°æŠ•å½±è¯¯å·®
    R = ba_solver_-&amp;gt;solveBa(armor, t, R, R_imu_camera);
  }
  // 4) å¡«å……æ¶ˆæ¯ï¼ˆä½å§¿ + æ–‡æœ¬ï¼‰
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ä¸¤è§£é€‰æ‹©ï¼ˆç›´è§‰ï¼‰&lt;/strong&gt;ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å…ˆçœ‹&lt;strong&gt;é‡æŠ•å½±è¯¯å·®&lt;/strong&gt;ä¸ &lt;strong&gt;roll&lt;/strong&gt;ï¼ˆå¤ªå·®çš„è§£ç›´æ¥æ”¾å¼ƒåˆ‡æ¢ï¼‰ï¼›&lt;/li&gt;
&lt;li&gt;å†ç”¨&lt;strong&gt;ç¯æ¡åœ¨åƒé¢ä¸Šçš„æ•´ä½“å€¾æ–œ&lt;/strong&gt;æ¥åˆ¤æ–­å½“å‰&lt;strong&gt;yaw çš„æ­£è´Ÿæ˜¯å¦â€œåˆç†â€&lt;/strong&gt;ï¼Œå¿…è¦æ—¶å¯¹è°ƒè§£ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;4.5 BA ä¼˜åŒ–å™¨ä¸å›¾ä¼˜åŒ–ç®—å­ &lt;code&gt;BaSolver&lt;/code&gt; / &lt;code&gt;GraphOptimizer&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;æ€æƒ³&lt;/strong&gt;ï¼šåªæŠŠ&lt;strong&gt;è£…ç”² yaw&lt;/strong&gt; å½“æˆä¼˜åŒ–å˜é‡ï¼ˆä¸€ä¸ªé¡¶ç‚¹ &lt;code&gt;VertexYaw&lt;/code&gt;ï¼‰ï¼Œè£…ç”²çš„ 3D è§’ç‚¹ä¸ºå›ºå®šé¡¶ç‚¹ã€‚è§‚æµ‹ä¸ºæ¯ä¸ªè§’ç‚¹åœ¨å›¾åƒé‡Œçš„åƒç´ ä½ç½®ï¼Œè¯¯å·®å°±æ˜¯&lt;strong&gt;è§‚æµ‹åƒç´ &lt;/strong&gt;å‡å»&lt;strong&gt;æŠ•å½±åƒç´ &lt;/strong&gt;ã€‚è¿™æ · BA æ—¢è½»é‡åˆèƒ½ç¨³ä½å§¿æ€ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;æ„å›¾ä¸ä¼˜åŒ–&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// å¡«å›¾ï¼šä¸€ä¸ª yaw é¡¶ç‚¹ + å››ä¸ªå›ºå®šçš„ 3D é¡¶ç‚¹ + å››æ¡æŠ•å½±è¯¯å·®è¾¹ï¼ˆå¸¦ Huber é²æ£’æ ¸ï¼‰
VertexYaw* v_yaw = new VertexYaw(); v_yaw-&amp;gt;setEstimate(initial_armor_yaw);
for (i in 4 corners) {
  VertexPointXYZ* vp = new VertexPointXYZ(); vp-&amp;gt;setFixed(true);
  EdgeProjection* e = new EdgeProjection(R_camera_imu, R_pitch, t, K);
  e-&amp;gt;setVertex(0, v_yaw); e-&amp;gt;setVertex(1, vp);
  e-&amp;gt;setMeasurement(pixel_observation);
  e-&amp;gt;setRobustKernel(new g2o::RobustKernelHuber);
}
optimizer.initializeOptimization(); optimizer.optimize(20);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// è‡ªå®šä¹‰é¡¶ç‚¹å¢é‡ï¼šåœ¨ SO3 ä¸Šç”¨æä»£æ•°æ›´æ–° yawï¼Œé¿å…è§’åº¦è·³å˜
void VertexYaw::oplusImpl(const double* update) {
  Sophus::SO3d R_yaw = Sophus::SO3d::exp({0,0,update[0]}) * Sophus::SO3d::exp({0,0,_estimate});
  _estimate = R_yaw.log()(2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// æŠ•å½±è¾¹è¯¯å·®ï¼šåƒç´ è§‚æµ‹ - æŠ•å½±(R_camera_imu * R_yaw * R_pitch * P + t)
void EdgeProjection::computeError() {
  double yaw = static_cast&amp;lt;VertexYaw*&amp;gt;(_vertices[0])-&amp;gt;estimate();
  Sophus::SO3d R = R_camera_imu_ * Sophus::SO3d::exp({0,0,yaw}) * R_pitch_;
  Eigen::Vector3d p = R * P3D + t_;
  Eigen::Vector2d proj = (K_ * (p / p.z())).head&amp;lt;2&amp;gt;();
  _error = obs - proj;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;4.6 ROS2 èŠ‚ç‚¹ &lt;code&gt;ArmorDetectorNode&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;èŒè´£&lt;/strong&gt;ï¼šæŠŠæ£€æµ‹ â†’ åˆ†ç±» â†’ï¼ˆå¯é€‰ï¼‰è§’ç‚¹ä¿®æ­£ â†’ PnP/BA â†’ å‘å¸ƒå¯è§†åŒ–ï¼Œå…¨æµç¨‹åœ¨ ROS2 ä¸­è·‘èµ·æ¥ã€‚è´Ÿè´£ï¼šå‚æ•°ã€è®¢é˜…/å‘å¸ƒã€TFã€è°ƒè¯•ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;èŠ‚ç‚¹åˆå§‹åŒ–ï¼ˆèŠ‚é€‰ï¼‰&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// è¯»å–å‚æ•°ï¼Œåˆå§‹åŒ– Detectorã€NumberClassifierã€LightCornerCorrector
int binary_thres = declare_parameter(&quot;binary_thres&quot;, 160);
Detector::LightParams l_params = {.min_ratio=0.08, .max_ratio=0.4, .max_angle=40.0, .color_diff_thresh=25};
Detector::ArmorParams a_params = { .min_light_ratio=0.6, .min_small_center_distance=0.8, .max_small_center_distance=3.2,
                                   .min_large_center_distance=3.2, .max_large_center_distance=5.0, .max_angle=35.0 };
detector_ = std::make_unique&amp;lt;Detector&amp;gt;(binary_thres, EnemyColor::RED, l_params, a_params);

auto model_path = utils::URLResolver::getResolvedPath(&quot;package://armor_detector/model/lenet.onnx&quot;);
auto label_path = utils::URLResolver::getResolvedPath(&quot;package://armor_detector/model/label.txt&quot;);
double threshold = declare_parameter(&quot;classifier_threshold&quot;, 0.7);
auto ignores = declare_parameter&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&quot;ignore_classes&quot;, {&quot;negative&quot;});
detector_-&amp;gt;classifier = std::make_unique&amp;lt;NumberClassifier&amp;gt;(model_path, label_path, threshold, ignores);

bool use_pca = declare_parameter(&quot;use_pca&quot;, true);
if (use_pca) detector_-&amp;gt;corner_corrector = std::make_unique&amp;lt;LightCornerCorrector&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;å›¾åƒå›è°ƒï¼ˆèŠ‚é€‰ï¼‰&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1) TF: odom â†’ ç›¸æœºçš„æ—‹è½¬çŸ©é˜µï¼ˆIMUâ†’Cameraï¼‰
auto odom_to_cam = tf2_buffer_-&amp;gt;lookupTransform(odom_frame_, img_msg-&amp;gt;header.frame_id, img_msg-&amp;gt;header.stamp, 10ms);
Eigen::Matrix3d imu_to_camera = tf2MatrixFrom(odom_to_cam.transform.rotation);

// 2) æ£€æµ‹ + åˆ†ç±» + è§’ç‚¹ä¿®æ­£
auto armors = detector_-&amp;gt;detect(cv_bridge::toCvShare(img_msg, &quot;rgb8&quot;)-&amp;gt;image);

// 3) PnP/BA æå–ä½å§¿
armors_msg_.armors = armor_pose_estimator_-&amp;gt;extractArmorPoses(armors, imu_to_camera);

// 4) å¯è§†åŒ–ä¸å‘å¸ƒï¼šMarker / è°ƒè¯•å›¾åƒ / Armors
publishMarkersAndDebugImages(...);
armors_pub_-&amp;gt;publish(armors_msg_);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;å‚æ•°å¦‚ä½•å½±å“æ•ˆæœï¼ˆè°ƒå‚æŒ‡å—ï¼‰&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;binary_thres&lt;/code&gt;ï¼šé˜ˆå€¼é«˜â†’å™ªç‚¹å°‘ä½†ç¯æ¡å¯èƒ½æ–­ï¼›é˜ˆå€¼ä½â†’è¿é€šåŸŸç²˜è¿ã€‚å…ˆæ‰“å¼€è°ƒè¯•å›¾åƒè¯é¢˜è§‚å¯Ÿå†è°ƒã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;light.min_ratio / max_ratio / max_angle&lt;/code&gt;ï¼šæ§åˆ¶ç¯æ¡çš„â€œç»†é•¿â€å’Œâ€œè¿‘å‚ç›´â€ç¨‹åº¦ï¼›è¯¯æ£€å¤šå°±æ”¶ç´§ï¼Œæ¼æ£€å¤šå°±æ”¾å®½ã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;light.color_diff_thresh&lt;/code&gt;ï¼šè¶Šå¤§è¶Šâ€œä¿å®ˆâ€åœ°åˆ¤æ–­é¢œè‰²ï¼›å¤ªå°ä¼šæŠŠæ‚æ•£å…‰å½“æˆçº¢/è“ã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;armor.*_center_distance&lt;/code&gt;ï¼šä¸¤ç¯æ¡ä¸­å¿ƒè·çª—å£ï¼›ä¸ç„¦è·/è·ç¦»æœ‰å…³ï¼Œé•œå¤´å˜åŒ–åè¦é‡è°ƒã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;classifier_threshold / ignore_classes&lt;/code&gt;ï¼šåˆ†ç±»é˜ˆå€¼ä¸å¿½ç•¥ç±»ï¼Œå…ˆæ¾åç´§ï¼Œç»“åˆå®æµ‹æ··æ·†å†æ”¶æ•›ã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use_pca&lt;/code&gt;ï¼šè§’ç‚¹ä¿®æ­£ï¼Œå™ªå£°ç¯å¢ƒæˆ–åˆ†è¾¨ç‡ä¸é«˜æ—¶å¸¸æœ‰å¸®åŠ©ã€‚&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use_ba&lt;/code&gt;ï¼šè½»é‡çš„ yaw ä¼˜åŒ–ï¼Œèƒ½å‡æŠ–ã€ç¨³å§¿æ€ï¼›ä½†åœ¨æç«¯è§†è§’ä¸‹å¯èƒ½æ”¶ç›Šæœ‰é™ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;å®æˆ˜ï¼šä»æºç åˆ°è¿è¡Œä¸å¯è§†åŒ–&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;å‡†å¤‡&lt;/strong&gt;ï¼šç›¸æœºè¯é¢˜ &lt;code&gt;image_raw&lt;/code&gt;ã€&lt;code&gt;camera_info&lt;/code&gt;ï¼Œå¹¶ç¡®è®¤ TF é“¾è·¯ï¼ˆ&lt;code&gt;odom â†’ camera&lt;/code&gt;ï¼‰ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;å¯åŠ¨èŠ‚ç‚¹&lt;/strong&gt;ï¼šåŠ è½½å‚æ•°ï¼ˆä¸Šé¢æåˆ°çš„é˜ˆå€¼ä¸çª—å£ï¼‰å¹¶æ‰“å¼€ &lt;code&gt;debug&lt;/code&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RViz&lt;/strong&gt;ï¼šæ·»åŠ  &lt;code&gt;MarkerArray&lt;/code&gt; è®¢é˜… &lt;code&gt;armor_detector/marker&lt;/code&gt;ï¼›æŠŠè°ƒè¯•å›¾åƒè¯é¢˜ï¼ˆ&lt;code&gt;binary_img/number_img/result_img&lt;/code&gt;ï¼‰ä¹Ÿå¼€å‡ºæ¥ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;è§‚å¯Ÿä¸è°ƒæ•´&lt;/strong&gt;ï¼š
&lt;ul&gt;
&lt;li&gt;å…ˆè®©&lt;strong&gt;ç¯æ¡å€™é€‰&lt;/strong&gt;ç¨³å®š â†’ å†çœ‹&lt;strong&gt;é…å¯¹&lt;/strong&gt;æ˜¯å¦åˆç† â†’ æœ€åçœ‹&lt;strong&gt;æ•°å­—åˆ†ç±»&lt;/strong&gt;ä¸&lt;strong&gt;ä½å§¿&lt;/strong&gt;æ˜¯å¦ç¨³å®šã€‚&lt;/li&gt;
&lt;li&gt;é€é¡¹å¾®è°ƒå‚æ•°ï¼Œè®°å½•æ¯é¡¹è°ƒæ•´å¯¹å¬å›/ç²¾åº¦çš„å½±å“ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;å¸¸è§é—®é¢˜ä¸å®šä½æ€è·¯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ç¯æ¡â€œå¤¹ç¯â€/è¯¯é…å¯¹&lt;/strong&gt;ï¼šæ£€æŸ¥ &lt;code&gt;containLight&lt;/code&gt; è§„åˆ™ä¸æ•°å­—/çº¢ç‚¹å®½åº¦è¿‡æ»¤ï¼›é€‚å½“æé«˜ &lt;code&gt;color_diff_thresh&lt;/code&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;åˆ†ç±»ä¸ç¨³&lt;/strong&gt;ï¼šå¯¹æ¯” &lt;code&gt;number_img&lt;/code&gt; æ˜¯å¦å¹²å‡€ï¼›æ£€æŸ¥ ROI å®½åº¦æ˜¯å¦ä¸å¤§/å°è£…ç”²ä¸€è‡´ï¼›é€‚å½“è°ƒé˜ˆå€¼æˆ–å¿½ç•¥ç±»ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ä½å§¿â€œç¿»é¢â€&lt;/strong&gt;ï¼šç†è§£ &lt;code&gt;sortPnPResult&lt;/code&gt; çš„é€‰æ‹©é€»è¾‘ï¼ˆè¯¯å·®ã€rollã€ç¯æ¡å€¾è§’ä¸ yaw æ­£è´Ÿï¼‰ï¼Œå¿…è¦æ—¶åœ¨è¿‘æ™¯è´´çº¸çº¹ç†ä¸Šåšè¾…åŠ©ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;å§¿æ€æŠ–åŠ¨&lt;/strong&gt;ï¼šå¼€å¯ &lt;code&gt;use_ba&lt;/code&gt;ï¼›æˆ–åœ¨ &lt;code&gt;LightCornerCorrector&lt;/code&gt; ä¸­åŠ å¤§å€™é€‰æ¡æ•°ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;è¿›é˜¶ç»ƒä¹ é¢˜ï¼ˆå¸¦æ–¹å‘æç¤ºï¼‰&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;æŠŠé˜ˆå€¼æ”¹æˆè‡ªé€‚åº”&lt;/strong&gt;ï¼šå°è¯• &lt;code&gt;cv::adaptiveThreshold&lt;/code&gt; æˆ–æ ¹æ®åŒºåŸŸäº®åº¦åŠ¨æ€è°ƒ &lt;code&gt;binary_thres&lt;/code&gt;ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;åŠ å…¥æ—¶åºç¨³å®š&lt;/strong&gt;ï¼šåœ¨ &lt;code&gt;Detector&lt;/code&gt; è¾“å‡ºä¸Šåšè·Ÿè¸ªï¼ˆKalman/åŒˆç‰™åˆ©åŒ¹é…ï¼‰ï¼Œè®©æ•°å­—ä¸å§¿æ€åœ¨å¸§é—´æ›´ç¨³ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;æ•°æ®å¢å¼ºä¸å†è®­ç»ƒ&lt;/strong&gt;ï¼šå¯¹ &lt;code&gt;number_img&lt;/code&gt; åšéšæœºä»¿å°„/å™ªå£°å¢å¼ºï¼Œå¾®è°ƒ ONNX æ¨¡å‹ï¼Œè§‚å¯Ÿæ··æ·†ç±»çš„æ”¹å–„ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;å¤šç›®æ ‡é€‰æ‹©ç­–ç•¥&lt;/strong&gt;ï¼šå½“åŒå±å¤šå—è£…ç”²æ—¶ï¼ŒåŸºäº &lt;code&gt;distance_to_image_center&lt;/code&gt;ã€ç½®ä¿¡åº¦æˆ–å†å² ID é€‰æ‹©ç›®æ ‡ã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;æœ¯è¯­ä¸åæ ‡ç³»å°æŠ„&lt;/h2&gt;
</content:encoded></item><item><title>è§†é¢‘æµ‹è¯•</title><link>https://www.nanye404.top/posts/video/</link><guid isPermaLink="true">https://www.nanye404.top/posts/video/</guid><description>è§†é¢‘æµ‹è¯•ã€‚</description><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;è¿™æ˜¯è§†é¢‘æµ‹è¯•&lt;/p&gt;
&lt;h2&gt;YouTube&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;https://www.youtube.com/embed/5gIf0_xpFPI?si=N1WTorLKL0uwLsU_&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;h2&gt;Bilibili&lt;/h2&gt;
&lt;p&gt;&amp;lt;iframe width=&quot;100%&quot; height=&quot;468&quot; src=&quot;//player.bilibili.com/player.html?bvid=BV1fK4y1s7Qf&amp;amp;p=1&amp;amp;autoplay=0&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; &amp;amp;autoplay=0&amp;gt; &amp;lt;/iframe&amp;gt;&lt;/p&gt;
</content:encoded></item></channel></rss>